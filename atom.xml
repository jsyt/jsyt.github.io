<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GOYTH</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.goyth.com/"/>
  <updated>2018-04-24T04:08:42.000Z</updated>
  <id>http://www.goyth.com/</id>
  
  <author>
    <name>Luke Hu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 原型链与继承</title>
    <link href="http://www.goyth.com/2018/04/23/prototypeAndExtend/"/>
    <id>http://www.goyth.com/2018/04/23/prototypeAndExtend/</id>
    <published>2018-04-23T04:23:43.000Z</published>
    <updated>2018-04-24T04:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性指向 <code>prototype</code> 属性所在的函数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/04/23/prototypeAndExtend/Person.png" alt=""></p><p>当我们用构造函数创建一个实例时，也会为这个实例创建一个 <code>__proto__</code> 属性，这个<code>__proto__</code> 属性是一个指针指向构造函数的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person = new Person();</span><br><span class="line">person.__proto__ === Person.prototype    // true</span><br><span class="line">let person1 = new Person();</span><br><span class="line">person1.__proto__ === Person.prototype    // true</span><br></pre></td></tr></table></figure><p>由于同一个构造函数创建的所有实例对象的<code>__proto__</code> 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Luke&quot;;</span><br><span class="line">Person.prototype.age = 18;</span><br><span class="line">let person1 = new Person();</span><br><span class="line">let person2 = new Person();</span><br><span class="line">alert(person1.name)    // &quot;Luke&quot;</span><br><span class="line">alert(person2.name)    // &quot;Luke&quot;</span><br><span class="line">Person.prototype.name = &quot;Jack&quot;;</span><br><span class="line">alert(person1.name)    // &quot;Jack&quot;</span><br><span class="line">alert(person2.name)    // &quot;Jack&quot;</span><br></pre></td></tr></table></figure><h3 id="重写原型对象"><a href="#重写原型对象" class="headerlink" title="重写原型对象"></a>重写原型对象</h3><p>我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Luke&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将 <code>Person.prototype</code> 设置为一个新对象，而这个对象中没有<code>constructor</code>属性，这导致 <code>constructor</code> 属性不再指向 <code>Person</code>，而是指向 <code>Object</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let friend = new Person();</span><br><span class="line">alert(friend.constructor  === Person);    //false </span><br><span class="line">alert(friend.constructor  === Object);    //true</span><br></pre></td></tr></table></figure><p>如果 <code>constructor</code> 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    name : &quot;Luke&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链及原型链继承"><a href="#原型链及原型链继承" class="headerlink" title="原型链及原型链继承"></a>原型链及原型链继承</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();    //继承了 Super </span><br><span class="line"></span><br><span class="line">Sub.prototype.getSubValue = function ()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = new Sub();</span><br><span class="line">console.log(instance.getSuperValue());    //true</span><br><span class="line"></span><br><span class="line">console.log(instance.__proto__ === Sub.prototype);    //true</span><br><span class="line">console.log(Sub.prototype.__proto__ === Super.prototype);    //true</span><br></pre></td></tr></table></figure><p>上面的代码中<code>Sub.prototype = new Super();</code>通过创建Super的实例，并将该实例赋值给<code>Sub.prototype</code>来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的<code>__proto__</code>属性指向Sub的原型对象<code>Sub.prototype</code>，Sub原型对象的<code>__proto__</code>属性又指向Super的原型对象<code>Super.prototype</code>。</p><h4 id="原型链搜索机制"><a href="#原型链搜索机制" class="headerlink" title="原型链搜索机制"></a>原型链搜索机制</h4><p>当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链<code>Object.prototype</code>中，任然没有找到则返回<code>undefined</code>。就拿上面的例子来说，调用<code>instance.getSuperValue()</code>会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。</p><h4 id="原型链问题"><a href="#原型链问题" class="headerlink" title="原型链问题"></a>原型链问题</h4><p>原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Sub()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super();    // 继承了Super</span><br><span class="line"></span><br><span class="line">let instance1 = new Sub();</span><br><span class="line"></span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new Sub();</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green, black&quot;</span><br></pre></td></tr></table></figure><p>上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。<br>原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。</p><h3 id="构造函数继承（经典继承）"><a href="#构造函数继承（经典继承）" class="headerlink" title="构造函数继承（经典继承）"></a>构造函数继承（经典继承）</h3><p>即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Sub()&#123;</span><br><span class="line">    Super.call(this);    //继承了Super </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new Sub();</span><br><span class="line"></span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new Sub();</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br></pre></td></tr></table></figure><p>上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。</p><h4 id="构造函数继承问题"><a href="#构造函数继承问题" class="headerlink" title="构造函数继承问题"></a>构造函数继承问题</h4><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Sup(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sup.prototype.sayName = function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this);    //继承了Super 属性 (第二次调用Sup构造函数)</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();    // 继承了Super 原型链上的方法 (第一次调用Sup构造函数)</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.sayAge = function ()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;Luke&quot;, 18);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line">instance1.sayName();    //&quot;Luke&quot;</span><br><span class="line">instance1.sayAge()    //18</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Jack&quot;, 20);</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br><span class="line">instance2.sayName();    //&quot;Jack&quot;</span><br><span class="line">instance2.sayAge()    //20</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。<br>组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。但是美中不足的是，上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。</p><h3 id="优化后的组合继承"><a href="#优化后的组合继承" class="headerlink" title="优化后的组合继承"></a>优化后的组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Sup(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sup.prototype.sayName = function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this);    //继承了Super 属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F()&#123;</span><br><span class="line">&#125;</span><br><span class="line">F.prototype = Super.prototype; </span><br><span class="line">Sub.prototype = new F();    // 继承了Super 原型链上的方法</span><br><span class="line"></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.sayAge = function ()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;Luke&quot;, 18);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line">instance1.sayName();    //&quot;Luke&quot;</span><br><span class="line">instance1.sayAge()    //18</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Jack&quot;, 20);</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br><span class="line">instance2.sayName();    //&quot;Jack&quot;</span><br><span class="line">instance2.sayAge()    //20</span><br></pre></td></tr></table></figure><p>上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。这是最理想的继承方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h3&gt;&lt;p&gt;无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 &lt;code&gt;prototype&lt;/code&gt; 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 &lt;code&gt;constructor&lt;/code&gt;（构造函数）属性，这个属性指向 &lt;code&gt;prototype&lt;/code&gt; 属性所在的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
      <category term="extend" scheme="http://www.goyth.com/categories/JavaScript/extend/"/>
    
    
      <category term="JavaScript" scheme="http://www.goyth.com/tags/JavaScript/"/>
    
      <category term="prototype" scheme="http://www.goyth.com/tags/prototype/"/>
    
      <category term="extend" scheme="http://www.goyth.com/tags/extend/"/>
    
  </entry>
  
  <entry>
    <title>JS 的正则表达式</title>
    <link href="http://www.goyth.com/2018/04/01/JSRegExp/"/>
    <id>http://www.goyth.com/2018/04/01/JSRegExp/</id>
    <published>2018-04-01T08:22:03.000Z</published>
    <updated>2018-04-02T15:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。<br>核心是 匹配，匹配位置或者匹配字符</p><a id="more"></a><h3 id="先简单的介绍一下语法"><a href="#先简单的介绍一下语法" class="headerlink" title="先简单的介绍一下语法"></a>先简单的介绍一下语法</h3><h4 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h4><ol><li><code>.</code>： 匹配除了换行符之外的任何单个字符</li><li><code>\</code> ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前<code>\</code>的<code>&#39;b&#39;</code>通常匹配小写<code>&#39;b&#39;</code>，无论它们出现在哪里。如果加了<code>&#39;\&#39;</code>,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 <code>/a*/</code> 代表会匹配 0   a。相反，模式 <code>/a\*/</code> 将 ‘ <code>*</code> ‘ 的特殊性移除，从而可以匹配像 <code>&quot;a*&quot;</code> 这样的字符串。</li><li><code>|</code> ： 逻辑或操作符</li><li><code>[ ]</code> ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 <code>.</code> ，<code>\</code>这些字符都表示其本身</li><li><code>[^ ]</code> ：对上面一个集合取非</li><li><code>-</code> ：定义一个区间，例如<code>[A-Z]</code>，其首尾字符在 ASCII 字符集里面<!-- <font style="background:#FFF5F5" color="#FC563C" >-</font>  --></li></ol><h4 id="数量元字符"><a href="#数量元字符" class="headerlink" title="数量元字符"></a>数量元字符</h4><ol><li><code>{m,n}</code> ：匹配前面一个字符至少 m 次至多 n 次重复，还有<code>{m}</code>表示匹配 m 次，<code>{m,}</code>表示至少 m 次</li><li><code>+</code> ： 匹配前面一个表达式一次或者多次，相当于 <code>{1,}</code>，记忆方式追加(+)，起码得有一次</li><li><code>*</code> ： 匹配前面一个表达式零次或者多次，相当于 <code>{0,}</code>，记忆方式乘法(*)，可以一次都没有</li><li><code>?</code> ： 单独使用匹配前面一个表达式零次或者一次，相当于 <code>{0,1}</code>，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词<code>*</code>, <code>+</code>, <code>?</code>, <code>{}</code> 后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 <code>/\d+/</code> 将会返回 “123”，如果使用 <code>/\d+?/</code>,那么就只会匹配到 “1”。</li></ol><h4 id="位置元字符"><a href="#位置元字符" class="headerlink" title="位置元字符"></a>位置元字符</h4><ol><li><code>^</code> ： 单独使用匹配表达式的开始</li><li><code>\$</code> ： 匹配表达式的结束</li><li><code>\b</code> ：匹配单词边界</li><li><code>\B</code> ：匹配非单词边界</li><li><code>(?=p)</code> ：匹配 p 前面的位置</li><li><code>(?!p)</code> ：匹配不是 p 前面的位置</li></ol><h4 id="标志字符"><a href="#标志字符" class="headerlink" title="标志字符"></a>标志字符</h4><ol><li><code>g</code> : 全局搜索 记忆方式global</li><li><code>i</code> ：不区分大小写 记忆方式 ignore</li><li><code>m</code> ：多行搜索</li></ol><h3 id="在-js-中的使用"><a href="#在-js-中的使用" class="headerlink" title="在 js 中的使用"></a>在 js 中的使用</h3><h4 id="支持正则的-String-对象的方法"><a href="#支持正则的-String-对象的方法" class="headerlink" title="支持正则的 String 对象的方法"></a>支持正则的 String 对象的方法</h4><ul><li><code>search</code><br>search 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1</li><li><code>match</code><br>match 接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;For more information, see Chapter 3.4.5.1&apos;;</span><br><span class="line"> var re = /see (chapter \d+(\.\d)*)/i;</span><br><span class="line"> var found = str.match(re);</span><br><span class="line"> console.log(found);</span><br><span class="line"> // (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;]</span><br><span class="line"> // 0:&quot;see Chapter 3.4.5.1&quot;</span><br><span class="line"> // 1:&quot;Chapter 3.4.5.1&quot;</span><br><span class="line"> // 2:&quot;.1&quot;</span><br><span class="line"> // index:22</span><br><span class="line"> // input:&quot;For more information, see Chapter 3.4.5.1&quot;</span><br><span class="line"> // length:3</span><br><span class="line"> // __proto__:Array(0)</span><br><span class="line"></span><br><span class="line"> // &apos;see Chapter 3.4.5.1&apos; 是整个匹配。</span><br><span class="line"> // &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。</span><br><span class="line"> // &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。</span><br><span class="line"> // &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。</span><br><span class="line"> // &apos;input&apos; 属性是被解析的原始字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;</span><br><span class="line">var regexp = /[A-E]/gi;</span><br><span class="line">var matches_array = str.match(regexp);</span><br><span class="line"></span><br><span class="line">console.log(matches_array);</span><br><span class="line">// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><ul><li><code>replace</code><br>replace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串</li></ul><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:left">代表的值</th></tr></thead><tbody><tr><td style="text-align:center">$$</td><td style="text-align:left">插入一个 “$”。</td></tr><tr><td style="text-align:center">$&amp;</td><td style="text-align:left">插入匹配的子串。</td></tr><tr><td style="text-align:center">$`</td><td style="text-align:left">插入当前匹配的子串左边的内容。</td></tr><tr><td style="text-align:center">$’</td><td style="text-align:left">插入当前匹配的子串右边的内容。</td></tr><tr><td style="text-align:center">$n</td><td style="text-align:left">假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var re = /(\w+)\s(\w+)/;</span><br><span class="line">var str = &quot;John Smith&quot;;</span><br><span class="line">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class="line">// Smith, John</span><br><span class="line">console.log(newstr);</span><br></pre></td></tr></table></figure><p>如果是函数的话，函数入参如下，返回替换成的文本</p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的<code>$&amp;</code>。）</td></tr><tr><td>p1,p2,…</td><td>假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的<code>$1</code>，<code>$2</code>等。）</td></tr><tr><td>offset</td><td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function replacer(match, p1, p2, p3, offset, string) &#123;</span><br><span class="line">  // p1 is nondigits, p2 digits, and p3 non-alphanumerics</span><br><span class="line">  return [p1, p2, p3].join(&apos; - &apos;);</span><br><span class="line">&#125;</span><br><span class="line">var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);</span><br><span class="line">// newString   abc - 12345 - #$*%</span><br></pre></td></tr></table></figure><ol><li><code>split</code><br>接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/\d/);</span><br><span class="line"></span><br><span class="line">console.log(splits);</span><br><span class="line">// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]</span><br><span class="line"></span><br><span class="line">splits = myString.split(/(\d)/);</span><br><span class="line">console.log(splits);</span><br><span class="line">// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure><h4 id="正则对象的方法"><a href="#正则对象的方法" class="headerlink" title="正则对象的方法"></a>正则对象的方法</h4><ol><li><code>test</code><br>接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false</li><li><code>exec</code><br>同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 <code>null</code>。匹配时，返回值跟 <code>match</code> 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 <code>index</code> 和 <code>input</code>同时它会在正则实例的 <code>lastIndex</code> 属性指定的字符处开始检索字符串 string。当 <code>exec()</code> 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 <code>lastIndex</code> 属性设置为匹配文本的最后一个字符的下一个位置。有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 <code>exec()</code> 方法来遍历字符串中的所有匹配文本。当 <code>exec()</code> 再也找不到匹配的文本时，它将返回 <code>null</code>，并把 <code>lastIndex</code> 属性重置为 0。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017.06.27&quot;;</span><br><span class="line">var regex2 = /\b(\d+)\b/g;</span><br><span class="line">console.log( regex2.exec(string) );</span><br><span class="line">console.log( regex2.lastIndex);</span><br><span class="line">console.log( regex2.exec(string) );</span><br><span class="line">console.log( regex2.lastIndex);</span><br><span class="line">console.log( regex2.exec(string) );</span><br><span class="line">console.log( regex2.lastIndex);</span><br><span class="line">console.log( regex2.exec(string) );</span><br><span class="line">console.log( regex2.lastIndex);</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; 4</span><br><span class="line">// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; 7</span><br><span class="line">// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]</span><br><span class="line">// =&gt; 10</span><br><span class="line">// =&gt; null</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure><pre><code>其中正则实例lastIndex属性，表示下一次匹配开始的位置。</code></pre><p>比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。</p><p>从上述代码看出，在使用exec时，经常需要配合使用while循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;2017.06.27&quot;;</span><br><span class="line">var regex2 = /\b(\d+)\b/g;</span><br><span class="line">var result;</span><br><span class="line">while ( result = regex2.exec(string) ) &#123;</span><br><span class="line">    console.log( result, regex2.lastIndex );</span><br><span class="line">&#125;</span><br><span class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4</span><br><span class="line">// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7</span><br><span class="line">// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10</span><br></pre></td></tr></table></figure><h4 id="正则的匹配"><a href="#正则的匹配" class="headerlink" title="正则的匹配"></a>正则的匹配</h4><h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><p>精确匹配就不说了，比如<code>/hello/</code>，也只能匹配字符串中的<code>&quot;hello&quot;</code>这个子串。<br>正则表达式之所以强大，是因为其能实现模糊匹配。</p><h5 id="匹配多种数量"><a href="#匹配多种数量" class="headerlink" title="匹配多种数量"></a>匹配多种数量</h5><p>用<code>{m,n}</code>来匹配多种数量，其他几种形式<code>(+*?)</code>都可以等价成这种。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /ab&#123;2,5&#125;c/g;</span><br><span class="line">var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;</span><br><span class="line">console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;]</span><br></pre></td></tr></table></figure><h5 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h5><p>默认贪婪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;/g;</span><br><span class="line">var string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;]</span><br></pre></td></tr></table></figure><p>两次后面加一个 ？ 就可以表示非贪婪，非贪婪时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;?/g;</span><br><span class="line">var string = &quot;123 1234 12345 123456&quot;;</span><br><span class="line">console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;]</span><br></pre></td></tr></table></figure><h5 id="匹配多种情况"><a href="#匹配多种情况" class="headerlink" title="匹配多种情况"></a>匹配多种情况</h5><p>用字符组<code>[]</code>来匹配多种情况，其他几种形式<code>(\d\D\s\S\w\W)</code>都可以等价成这种。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /a[123]b/g;</span><br><span class="line">var string = &quot;a0b a1b a2b a3b a4b&quot;;</span><br><span class="line">console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;]</span><br></pre></td></tr></table></figure></p><p>如果字符组里面字符特别多的话可以用<code>-</code>来表示范围，比如<code>[123456abcdefGHIJKLM]</code>，可以写成<code>[1-6a-fG-M]</code>，用[<code>^0-9]</code>表示非除了数字以外的字符<br>多种情况还可以是多种分支，用管道符来连接<code>|</code>，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /good|goodbye/g;</span><br><span class="line">var string = &quot;goodbye&quot;;</span><br><span class="line">console.log( string.match(regex) ); // [&quot;good&quot;]</span><br></pre></td></tr></table></figure><p>这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。</p><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>掌握这两种方式就可以解决比较简单的正则问题了。</p><ol><li>最多保留2位小数的数字<br><code>/^([1-9]\d*|0)(\.\d{1,2})?$/</code></li><li>电话号码<br><code>/(\+86)?1\d{10}/</code></li><li>身份证<br><code>/^(\d{15}|\d{17}([xX]|\d))$/</code></li></ol><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="什么是位置"><a href="#什么是位置" class="headerlink" title="什么是位置"></a>什么是位置</h5><p>位置是相邻字符之间的，比如，有一个字符串 <code>hello</code> ，这个字符串一共有6个位置 <code>*h*e*l*l*o*</code> ， <code>*</code>代表位置</p><p><img src="/2018/04/01/JSRegExp/regwz" alt="" title="位置"></p><p>上面说到了 6 种位置元字符</p><ol><li><code>^</code>，<code>$</code> 匹配字符的开头和结尾，比如<code>/^hello$/</code> 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 <code>h</code> 然后是 <code>e</code>,<code>l</code>,<code>l</code>,<code>o</code> 最后是字符串结尾的位置位置还可以被替换成字符串，比如<code>&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;)</code> 结果是 <code>#hello#</code></li><li><code>/b</code>，<code>/B</code> 匹配单词边界和非单词边界，单词边界具体指 <code>\w([a-zA-Z0-9_])</code> 和 <code>\W</code> 之间的位置，包括 <code>\w</code> 和 <code>^</code> 以及 <code>$</code> 之间的位置，比如<code>&#39;hello word [js]_reg.exp-01&#39;.replace(/\b/g, &#39;#&#39;)</code> 结果是<code>#hello# #word# [#js#]#_reg#.#exp#-#01#</code></li><li><code>(?=p)</code>，<code>(?!p)</code> 匹配 <code>p</code> 前面的位置和不是 <code>p</code> 前面位置，比如<code>&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;)</code> 结果是 <code>he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;)</code> 结果是 <code>#h#ell#o#</code></li></ol><h5 id="位置的特性"><a href="#位置的特性" class="headerlink" title="位置的特性"></a>位置的特性</h5><p>字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 <code>&#39;&#39;</code>，比如<code>hello</code> 可以是一般的 <code>&#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;</code>，也可以是 <code>&#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;</code>，所以<code>/^h\Be\Bl\Bl\Bo$/.test(&#39;hello&#39;)</code> 结果是 <code>true</code>，<code>/^^^h\B\B\Be\Bl\Bl\Bo$$$/.test(&#39;hello&#39;)</code> 结果也是 <code>true</code></p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>-. 千分位，将 <code>123123123</code> 转换成 <code>123,123,123</code>数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 <code>&#39;,&#39;</code> 就好了，写成正则就是<code>123123213.replace(/(?=(\d{3})+$)/g, &#39;,&#39;)</code> 但是这样的话会在最前面也加一个 <code>&#39;,&#39;</code> 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 <code>/(?!^)(?=(\d{3})+$)/g</code> 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 <code>/\d(?=(\d{3})+$)/g</code>，但是这个正则匹配的结果是 <code>12,12,123</code>，发现这个正则匹配的不是位置而是字符，将数字换成了 <code>&#39;,&#39;</code>  可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>分组主要是括号的使用</p><h5 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h5><p>在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love JavaScript</span><br><span class="line">I love Regular Expression</span><br></pre></td></tr></table></figure><p>可以用正则<code>/^I love (JavaScript|Regular Expression)$/</code> 而不是 <code>/^I love JavaScript|Regular Expression$/</code>表示一个整体还比如 <code>/(abc)+/</code> 一个或者多个 <code>abc</code> 字符串上面这些使用 <code>()</code> 包起来的地方就叫做分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)</span><br><span class="line">// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;]</span><br></pre></td></tr></table></figure><p>输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容</p><h4 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h4><h5 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h5><p>比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则<code>/\d{4}-\d{2}-\d{2}/</code>，这个正则还可以改成分组形式的<code>/(\d{4})-(\d{2})-(\d{2})/</code>这样我们可以分别提取出一个日期的年月日，用 <code>String</code> 的 <code>match</code> 方法或者用正则的 <code>exec</code> 方法都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-08-09&quot;;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;]</span><br></pre></td></tr></table></figure></p><p>也可以用正则对象构造函数的全局属性 $1 - $9 来获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-08-09&quot;;</span><br><span class="line"></span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">//regex.exec(string);</span><br><span class="line">//string.match(regex);</span><br><span class="line"></span><br><span class="line">console.log(RegExp.$1); // &quot;2017&quot;</span><br><span class="line">console.log(RegExp.$2); // &quot;08&quot;</span><br><span class="line">console.log(RegExp.$3); // &quot;09&quot;</span><br></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。<br>String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-08-09&quot;;</span><br><span class="line">var result = string.replace(regex, &quot;$2/$3/$1&quot;);</span><br><span class="line">console.log(result); // &quot;08/09/2017&quot;</span><br><span class="line">等价</span><br><span class="line">var result = string.replace(regex, function() &#123;</span><br><span class="line">    return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // &quot;08/09/2017&quot;</span><br><span class="line">等价</span><br><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = &quot;2017-08-09&quot;;</span><br><span class="line">var result = string.replace(regex, function(match, year, month, day) &#123;</span><br><span class="line">    return month + &quot;/&quot; + day + &quot;/&quot; + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // &quot;08/09/2017&quot;</span><br></pre></td></tr></table></figure><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2017-08-09</span><br><span class="line"></span><br><span class="line">2017/08/09</span><br><span class="line"></span><br><span class="line">2017.08.09</span><br></pre></td></tr></table></figure></p><p>要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下<code>/(\d{4})[-/.](\d{2})[-/.](\d{2})/</code>，把 <code>-</code> 改成 <code>[-/.]</code> 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 <code>2017-08.09</code> 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 <code>/(\d{4})([-/.])(\d{2})\2(\d{2})/</code></p><p><strong><em>那么出现括号嵌套怎么办，比如</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = &quot;1231231233&quot;;</span><br><span class="line">console.log( regex.test(string) ); // true</span><br><span class="line">console.log( RegExp.$1 ); // 123</span><br><span class="line">console.log( RegExp.$2 ); // 1</span><br><span class="line">console.log( RegExp.$3 ); // 23</span><br><span class="line">console.log( RegExp.$4 ); // 3</span><br></pre></td></tr></table></figure></p><p>嵌套的括号以左括号为准</p><h5 id="引用了不存在的分组呢"><a href="#引用了不存在的分组呢" class="headerlink" title="引用了不存在的分组呢"></a>引用了不存在的分组呢</h5><p>如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如<code>\1</code>就匹配<code>\1</code></p><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><p>我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组</p><h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><ol><li><p>驼峰改短横</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function dash(str) &#123;</span><br><span class="line">return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取链接的 search 值链接：<code>https://www.baidu.com?name=jawil&amp;age=23</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getParamName(attr) &#123;</span><br><span class="line"></span><br><span class="line">let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里</span><br><span class="line"> .exec(window.location.search)</span><br><span class="line">//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]</span><br><span class="line">return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉</span><br><span class="line">&#125;</span><br><span class="line">console.log(getParamName(&apos;name&apos;))  // &quot;jawil&quot;</span><br></pre></td></tr></table></figure></li><li><p>去掉字符串前后的空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trim(str) &#123;</span><br><span class="line"> return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个数是否是质数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isPrime(num) &#123;</span><br><span class="line">return !/^1?$|^(11+?)\1+$/.test(Array(num+1).join(&apos;1&apos;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1  然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><h5 id="正则是怎么匹配的"><a href="#正则是怎么匹配的" class="headerlink" title="正则是怎么匹配的"></a>正则是怎么匹配的</h5><p>有这么一个字符串 <code>&#39;abbbc&#39;</code> 和这么一个正则 <code>/ab{1,3}bbc//ab{1,3}bbc/.test(&#39;abbbc&#39;)</code> 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢<br><img src="/2018/04/01/JSRegExp/huisu" alt="回溯" title="回溯"></p><h5 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h5><p>例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”<br>贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如<code>/^(test|te)sts$/.test(&#39;tests&#39;)</code>前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 <code>s</code> 的时候还是成功的，匹配到 <code>st</code> 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。</p><h5 id="读正则"><a href="#读正则" class="headerlink" title="读正则"></a>读正则</h5><p>读懂其他人写的正则也是一个很重要的方面。</p><h5 id="结构和操作符"><a href="#结构和操作符" class="headerlink" title="结构和操作符"></a>结构和操作符</h5><p>结构：<code>字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用</code>。</p><p>操作符：</p><ol><li>转义符 <code>\</code></li><li>括号和方括号 <code>(...)</code>、<code>(?:...)</code>、<code>(?=...)</code>、<code>(?!...)</code>、<code>[...]</code></li><li>量词限定符 <code>{m}</code>、<code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>、<code>+</code></li><li>位置和序列 <code>^</code> 、<code>$</code>、 <code>\</code>元字符、 一般字符</li><li>管道符（竖杠） <code>|</code></li></ol><p>操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如<br><code>/ab?(c|de*)+|fg/</code></p><ol><li>因为括号是一个整体，所以<code>/ab?()+|fg/</code>,括号里面具体是什么可以放到后面再分析</li><li>根据量词和管道符的优先级，所以<code>a</code>, <code>b?</code>, ()+和管道符后面的<code>f</code>,<code>g</code></li><li>同理分析括号里面的<code>c|de* =&gt; c</code>和<code>d</code>, <code>e*</code></li><li>综上，这个正则描述的是</li></ol><p><img src="/2018/04/01/JSRegExp/reglc" alt=""></p><p>以这种模式来分析，再复杂的正则都可以看懂。有一个可视化的<a href="https://jex.im/regulex/" target="_blank" rel="noopener">正则分析网站</a></p><p><em>转载自<a href="https://juejin.im/post/59b5e50f51882519777c4815" target="_blank" rel="noopener">网易考拉前端团队</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。&lt;br&gt;核心是 匹配，匹配位置或者匹配字符&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
      <category term="RegExp" scheme="http://www.goyth.com/categories/JavaScript/RegExp/"/>
    
    
      <category term="JavaScript" scheme="http://www.goyth.com/tags/JavaScript/"/>
    
      <category term="RegExp" scheme="http://www.goyth.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://www.goyth.com/2018/03/29/hello/"/>
    <id>http://www.goyth.com/2018/03/29/hello/</id>
    <published>2018-03-29T14:26:35.000Z</published>
    <updated>2018-04-01T09:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/29/hello/dog.JPG" alt="makedown picture" title="Title"></p><h1 id="hello-Hexo-Makedown-语法测试一"><a href="#hello-Hexo-Makedown-语法测试一" class="headerlink" title="hello Hexo Makedown 语法测试一"></a>hello Hexo Makedown 语法测试一</h1><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.goyth.com/" title="tittle">个人博客地址</a><br>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="/2018/03/29/hello/dog.JPG" alt="makedown picture" title="Title"></p><h3 id="指定大小图片"><a href="#指定大小图片" class="headerlink" title="指定大小图片"></a>指定大小图片</h3><p> <img src="/2018/03/29/hello/dog.JPG" width="100" height="100" alt="图片名称" align="center"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><h3 id="指定语言代码块"><a href="#指定语言代码块" class="headerlink" title="指定语言代码块"></a>指定语言代码块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Hello World!'</span>);</span><br></pre></td></tr></table></figure><h3 id="反引号代码块"><a href="#反引号代码块" class="headerlink" title="反引号代码块"></a>反引号代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hexo</span><br></pre></td></tr></table></figure><!-- <img src="/2018/03/29/hello/dog.JPG"> –&gt;-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/29/hello/dog.JPG&quot; alt=&quot;makedown picture&quot; title=&quot;Title&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;hello-Hexo-Makedown-语法测试一&quot;&gt;&lt;a href=&quot;#hello-Hexo-Makedown-语法测试一&quot; class=&quot;headerlink&quot; title=&quot;hello Hexo Makedown 语法测试一&quot;&gt;&lt;/a&gt;hello Hexo Makedown 语法测试一&lt;/h1&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://www.goyth.com/categories/Diary/"/>
    
      <category term="Life" scheme="http://www.goyth.com/categories/Diary/Life/"/>
    
    
      <category term="TEST" scheme="http://www.goyth.com/tags/TEST/"/>
    
      <category term="HYT" scheme="http://www.goyth.com/tags/HYT/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.goyth.com/2018/03/03/hello-world/"/>
    <id>http://www.goyth.com/2018/03/03/hello-world/</id>
    <published>2018-03-03T08:46:06.221Z</published>
    <updated>2018-03-30T13:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Tests"><a href="#Quick-Tests" class="headerlink" title="Quick Tests"></a>Quick Tests</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="test" scheme="http://www.goyth.com/categories/test/"/>
    
    
      <category term="TEST" scheme="http://www.goyth.com/tags/TEST/"/>
    
  </entry>
  
</feed>
