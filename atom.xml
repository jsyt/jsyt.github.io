<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GOYTH</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.goyth.com/"/>
  <updated>2018-07-07T15:01:14.382Z</updated>
  <id>http://www.goyth.com/</id>
  
  <author>
    <name>Luke Hu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DNS知识点梳理</title>
    <link href="http://www.goyth.com/2018/07/07/DNS/"/>
    <id>http://www.goyth.com/2018/07/07/DNS/</id>
    <published>2018-07-07T10:29:09.000Z</published>
    <updated>2018-07-07T15:01:14.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。</p><a id="more"></a><p><img src="/2018/07/07/DNS/dns02.png" alt=""></p><p>全世界所有的人每天上网都会使用DNS服务器，所以DNS服务器是分布式、高并发、高可用的架构，如下图：</p><p><img src="/2018/07/07/DNS/dns01.jpg" alt=""></p><ul><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ul><h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>当用户在浏览器中输入<a href="http://www.abc.com并按下回车键后：" target="_blank" rel="noopener">www.abc.com并按下回车键后：</a></p><h3 id="第一步查找本地DNS缓存"><a href="#第一步查找本地DNS缓存" class="headerlink" title="第一步查找本地DNS缓存"></a>第一步查找本地DNS缓存</h3><p>本地DNS缓存有浏览器DNS缓存，操作系统（OS）DNS缓存，路由器DNS缓存，按照浏览器、操作系统、路由器的顺序依次查找<a href="http://www.abc.com对应的DNS缓存，如果缓存命中则停止。" target="_blank" rel="noopener">www.abc.com对应的DNS缓存，如果缓存命中则停止。</a></p><h4 id="1、浏览器DNS缓存"><a href="#1、浏览器DNS缓存" class="headerlink" title="1、浏览器DNS缓存"></a>1、浏览器DNS缓存</h4><p>浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。<br>当浏览器收到一个DNS解析请求后，首先会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。<br><strong>浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。</strong><br>通常每种浏览器都有一个固定的DNS缓存时间，其中Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://net-internals/#dns</span><br></pre></td></tr></table></figure></p><h4 id="2、系统（OS）DNS缓存"><a href="#2、系统（OS）DNS缓存" class="headerlink" title="2、系统（OS）DNS缓存"></a>2、系统（OS）DNS缓存</h4><p>如果用户浏览器缓存中没有数据，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，在Linux中可以通过/etc/hosts文件来设置，用户可以将任何域名解析到任何能够访问的IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以有黑客就可能通过修改用户的域名来把特定的域名解析到他指定的IP地址上，导致这些域名被劫持。</p><h3 id="第二步查找ISP-DNS缓存"><a href="#第二步查找ISP-DNS缓存" class="headerlink" title="第二步查找ISP DNS缓存"></a>第二步查找ISP DNS缓存</h3><p>如果本地DNS缓存没有对应的记录，就要用到我们网络配置中的”DNS服务器地址”了。操作系统会把这个域名发送给这个ISP，也就是本地区的域名服务器。这个DNS通常都提供给用户本地互联网接入的一个DNS解析服务，例如用户是在学校接入互联网，那么用户的DNS服务器肯定在学校；如果用户是在小区接入互联网，那么用户的DNS就是再提供接入互联网的应用提供商，即电信或联通，也就是通常说的SPA，那么这个DNS通常也会在用户所在城市的某个角落，不会很远。Windows环境下通过命令行输入ipconfig，Linux环境下通过cat /etc/resolv.conf就可以查询配置的DNS服务器了。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，所以ISP主要承担了域名的解析工作。</p><h3 id="递归搜索"><a href="#递归搜索" class="headerlink" title="递归搜索"></a>递归搜索</h3><p>在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根DNS（即一个完整域名最后面的那个点，通常省略不写）。(2)根DNS将所要查询域名中的顶级域（假设要查询<a href="http://www.abc.com，该域名的顶级域就是.com）的服务器IP地址返回到本地DNS。(3)" target="_blank" rel="noopener">www.abc.com，该域名的顶级域就是.com）的服务器IP地址返回到本地DNS。(3)</a> 本地DNS根据返回的IP地址，再向顶级域（就是.com域）发送请求。(4) .com域服务器再将域名中的权威域名服务器（abc.com）的IP地址返回给本地DNS。(5) 本地DNS再向权威域名服务器（abc.com）发送请求进行查询。(6) 权威DNS查询到对应的IP后，就将IP返回给本地DNS服务器，本地 DNS 再将 IP 地址返回客户端。</p><p><img src="/2018/07/07/DNS/dns03.jpg" alt=""></p><h2 id="DNS有关的网络性能优化"><a href="#DNS有关的网络性能优化" class="headerlink" title="DNS有关的网络性能优化"></a>DNS有关的网络性能优化</h2><p>1、减少DNS查找，避免重定向，浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</p><ul><li>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</li><li>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</li><li>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</li></ul><p>2、DNS的预解析<br>DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。 </p><p>在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。</p><p>这样可以极大的加速（尤其是移动网络环境下）页面的加载。在某些图片较多的页面中，在发起图片加载请求之前预先把域名解析好将会有至少 5% 的图片加载速度提升。</p><ul><li>打开和关闭 DNS 预读取<br>你可以通过在服务器端发送 <code>X-DNS-Prefetch-Control</code> 报头，或是在文档中使用值为 <code>http-equiv</code> 的 <code>&lt;meta&gt;</code> 标签：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"off"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>您可以通过将 <code>content</code> 的参数设置为<code>on</code>来改变设置。</p><ul><li>强制查询特定主机名<br>你可以通过使用 <code>rel</code> 属性值为 <code>link type</code> 中的 <code>dns-prefetch</code> 的<code>&lt;link&gt;</code> 标签来对特定域名进行预读取：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.spreadfirefox.com/"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>在这个例子中，Firefox将预解析域名”<a href="http://www.spreadfirefox.com&quot;。" target="_blank" rel="noopener">www.spreadfirefox.com&quot;。</a></p><p>而且，<code>&lt;link&gt;</code> 元素也可以使用不完整的 URL 的主机名来标记预解析，但这些主机名前必需要有双斜线：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//www.spreadfirefox.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>强制对域名进行预读取在有的情况下很有用, 比如, 在网站的主页上，强制在整个网站上频繁引用的域名的预解析，即使它们不在主页本身上使用。即使主页的性能可能不受影响，这将提高整体站点性能。</p><p>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</p><h2 id="几种域名解析方式"><a href="#几种域名解析方式" class="headerlink" title="几种域名解析方式"></a>几种域名解析方式</h2><p>域名解析记录主要分为A记录、MX记录、CNAME记录、NS记录和TXT记录：</p><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>A代表Address，用来指定域名对应的IP地址，如将item.taobao.com指定到115.238.23.xxx，将switch.taobao.com指定到121.14.24.xxx。A记录可以将多个域名解析到一个IP地址，但是不能将一个域名解析到多个IP地址</p><h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>Mail Exchange，就是可以将某个域名下的邮件服务器指向自己的Mail Server，如taobao.com域名的A记录IP地址是115.238.25.xxx，如果将MX记录设置为115.238.25.xxx，即<a href="mailto:xxx@taobao.com" target="_blank" rel="noopener">xxx@taobao.com</a>的邮件路由，DNS会将邮件发送到115.238.25.xxx所在的服务器，而正常通过Web请求的话仍然解析到A记录的IP地址</p><h3 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h3><p>Canonical Name，即别名解析。所谓别名解析就是可以为一个域名设置一个或者多个别名，如将aaa.com解析到bbb.net、将ccc.com也解析到bbb.net，其中bbb.net分别是aaa.com和ccc.com的别名</p><h3 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h3><p>为某个域名指定DNS解析服务器，也就是这个域名由指定的IP地址的DNS服务器取解析</p><h3 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h3><p>为某个主机名或域名设置说明，如可以为ddd.net设置TXT记录为”这是XXX的博客”这样的说明</p><hr><p><em>参考链接：<br><a href="https://www.cnblogs.com/xrq730/p/4931418.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4931418.html</a><br><a href="http://imweb" target="_blank" rel="noopener">http://imweb</a>.<br><a href="https://blog.csdn.net/kkdelta/article/details/53404005io/topic/55e3ba46771670e207a16bc8s" target="_blank" rel="noopener">https://blog.csdn.net/kkdelta/article/details/53404005io/topic/55e3ba46771670e207a16bc8s</a><br><a href="https://time.geekbang.org/column/article/9895" target="_blank" rel="noopener">https://time.geekbang.org/column/article/9895</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DNS-服务器&quot;&gt;&lt;a href=&quot;#DNS-服务器&quot; class=&quot;headerlink&quot; title=&quot;DNS 服务器&quot;&gt;&lt;/a&gt;DNS 服务器&lt;/h2&gt;&lt;p&gt;DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="DNS" scheme="http://www.goyth.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议知识点梳理</title>
    <link href="http://www.goyth.com/2018/07/04/TcpIp/"/>
    <id>http://www.goyth.com/2018/07/04/TcpIp/</id>
    <published>2018-07-04T06:09:31.000Z</published>
    <updated>2018-07-05T13:16:57.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><h3 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h3><p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p><a id="more"></a><p><img src="/2018/07/04/TcpIp/tcpip" alt=""></p><ul><li>物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换</li><li>链路层代表驱动</li><li>网络层<ul><li>使用 IP 协议，IP 协议基于 IP 转发分包数据</li><li>IP 协议是个不可靠协议，不会重发</li><li>IP 协议发送失败会使用ICMP 协议通知失败</li><li>ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供</li><li>IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信</li></ul></li><li>传输层<ul><li>通用的 TCP 和 UDP 协议<ul><li>TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费</li><li>UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层</li></ul></li></ul></li><li>会话层以上分层<ul><li>TCP/IP 分层中，会话层，表示层，应用层集中在一起</li><li>网络管理通过 SNMP 协议</li></ul></li></ul><h3 id="TCP-IP-协议模型封包解包"><a href="#TCP-IP-协议模型封包解包" class="headerlink" title="TCP/IP 协议模型封包解包"></a>TCP/IP 协议模型封包解包</h3><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p><p><img src="/2018/07/04/TcpIp/tcp02" alt=""></p><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p><p><img src="/2018/07/04/TcpIp/tcp03" alt=""></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><p><img src="/2018/07/04/TcpIp/tcp04" alt=""></p><p><strong>第一次握手</strong>： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br><strong>第二次握手</strong>： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br><strong>第三次握手</strong>： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。<br>如果采用两次握手，那么若Client向Server发起的包A1如果在传输链路上遇到的故障，导致传输到Server的时间相当滞后，在这个时间段由于Client没有收到Server的对于包A1的确认，那么就会重传一个包A2，假设服务器正常收到了A2的包，然后返回确认B2包。由于没有第三次握手，这个时候Client和Server已经建立连接了。再假设A1包随后在链路中传到了Server，这个时候Server又会返回B1包确认，但是由于Client已经清除了A1包，所以Client会丢弃掉这个确认包，但是Server会保持这个相当于“僵尸”的连接，浪费资源。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><p><img src="/2018/07/04/TcpIp/tcp05" alt=""></p><p><strong>第一次分手</strong>： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br><strong>第二次分手</strong>： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br><strong>第三次分手</strong>： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br><strong>第四次分手</strong>： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h4 id="为什么要四次分手？"><a href="#为什么要四次分手？" class="headerlink" title="为什么要四次分手？"></a>为什么要四次分手？</h4><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h4><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二：</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据段从网络中消失</li></ul><p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。<br>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><p><img src="/2018/07/04/TcpIp/06" alt=""></p><h4 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h4><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。</p><h4 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h4><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><h4 id="TCP和UDP协议的一些应用"><a href="#TCP和UDP协议的一些应用" class="headerlink" title="TCP和UDP协议的一些应用"></a>TCP和UDP协议的一些应用</h4><p><img src="/2018/07/04/TcpIp/tcp07" alt=""></p><h4 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><h4 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h4><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>　　原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。<br>　　影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）。RTO的值被设置过大过小都会对协议造成不利影响。<br>　　（1）RTO设长了，重发就慢，没有效率，性能差。<br>　　（2）RTO设短了，重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。<br>　　连接往返时间（RTT，Round Trip Time），指发送端从发送TCP包开始到接收它的立即响应所消耗的时间。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p>作用：（1）提供TCP的可靠性；（2）提供TCP的流控特性 </p><p><img src="/2018/07/04/TcpIp/tcp08.jpg" alt=""></p><p><img src="/2018/07/04/TcpIp/tcp09.jpg" alt=""></p><p>TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。<br>发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。<br>接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><p><img src="/2018/07/04/TcpIp/tcp10" alt=""></p><p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制<br>TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）。</p><p>发送方维持一个 <strong>拥塞窗口 cwnd ( congestion window )</strong> 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><img src="/2018/07/04/TcpIp/tcp11" alt=""></p><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<strong>一个传输轮次所经历的时间其实就是往返时间RTT</strong>。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下： </p><ul><li>当cwnd &lt; ssthresh时，使用慢开始算法。 </li><li>当cwnd &gt; ssthresh时，改用拥塞避免算法。 </li><li>当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p><img src="/2018/07/04/TcpIp/tcp12" alt=""></p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<br>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。<br>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><p><img src="/2018/07/04/TcpIp/tcp13" alt=""></p><p>拥塞控制的具体过程如下：<br>（1）TCP连接初始化，将拥塞窗口设置为1<br>（2）执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长<br>（3）当网络发生拥塞，把ssthresh值更新为拥塞前cwnd值的一半，cwnd重新设置为1，按照步骤（2）执行</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><img src="/2018/07/04/TcpIp/tcp14" alt=""></p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。<br>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p><strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</strong></p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh设置为cwnd值的一半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为ssthresh的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><p><img src="/2018/07/04/TcpIp/tcp15" alt=""></p><hr><p><em>参考链接：<br><a href="https://blog.csdn.net/qq_26499321/article/details/71429813" target="_blank" rel="noopener">https://blog.csdn.net/qq_26499321/article/details/71429813</a><br><a href="https://juejin.im/post/5ad4094e6fb9a028d7011069" target="_blank" rel="noopener">https://juejin.im/post/5ad4094e6fb9a028d7011069</a><br><a href="https://juejin.im/post/598ba1d06fb9a03c4d6464ab" target="_blank" rel="noopener">https://juejin.im/post/598ba1d06fb9a03c4d6464ab</a><br><a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h2&gt;&lt;p&gt;TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。&lt;/p&gt;
&lt;h3 id=&quot;TCP-IP-协议分层模型&quot;&gt;&lt;a href=&quot;#TCP-IP-协议分层模型&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议分层模型&quot;&gt;&lt;/a&gt;TCP/IP 协议分层模型&lt;/h3&gt;&lt;p&gt;基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="TCP/IP" scheme="http://www.goyth.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制梳理</title>
    <link href="http://www.goyth.com/2018/07/01/browseCache/"/>
    <id>http://www.goyth.com/2018/07/01/browseCache/</id>
    <published>2018-07-01T00:52:09.000Z</published>
    <updated>2018-07-01T03:44:57.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><a id="more"></a><p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p><p><img src="/2018/07/01/browseCache/1.webp" alt=""></p><p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图</p><p><img src="/2018/07/01/browseCache/2.webp" alt=""></p><p>注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><p>以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。</p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="/2018/07/01/browseCache/3.webp" alt=""></p><p>由上图我们可以知道：</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ul><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</li></ul><p><img src="/2018/07/01/browseCache/4.webp" alt=""></p><ul><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</li></ul><p><img src="/2018/07/01/browseCache/5.webp" alt=""></p><ul><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</li></ul><p><img src="/2018/07/01/browseCache/6.webp" alt=""></p><p><strong><em>那么强制缓存的缓存规则是什么？</em></strong></p><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于<code>Expires</code>的值时，直接使用缓存结果。</p><p><strong><em>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</em></strong></p><p>到了HTTP/1.1，<code>Expire</code>已经被<code>Cache-Control</code>替代，原因在于<code>Expires</code>控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么<code>Cache-Control</code>又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，<code>Cache-Control</code>是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li><p><strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存）</p></li><li><p><strong>private</strong>：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值</p></li><li><p><strong>no-cache</strong>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p></li><li><p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p><strong>max-age=xxx (xxx is numeric)</strong>：缓存内容将在xxx秒后失效</p></li></ul><p>接下来，我们直接看一个例子，如下：</p><p><img src="/2018/07/01/browseCache/7.png" alt=""></p><p>由上面的例子我们可以知道：</p><ul><li><p>HTTP响应报文中<code>expires</code>的时间值，是一个绝对值</p></li><li><p>HTTP响应报文中<code>Cache-Control</code>为<code>max-age=600</code>，是相对值</p></li></ul><p>由于<code>Cache-Control</code>的优先级比<code>expires</code>，那么直接根据<code>Cache-Control</code>的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p><em>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</em></p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><p><strong><em>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</em></strong></p><p><img src="/2018/07/01/browseCache/8.webp" alt=""></p><p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的<strong>Size</strong>值则代表该缓存存放的位置，分别为<strong>from memory cache</strong> 和 <strong>from disk cache</strong>。</p><p><strong><em>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</em></strong></p><p><strong>from memory cache</strong>代表使用内存中的缓存，<strong>from disk cache</strong>则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p><p><strong>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</strong></p><p>过程如下：</p><ul><li>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></li></ul><p><img src="/2018/07/01/browseCache/9.webp" alt=""></p><ul><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></p></li></ul><p><img src="/2018/07/01/browseCache/10.jpeg" alt=""></p><ul><li>刷新</li></ul><p><img src="/2018/07/01/browseCache/11.webp" alt="from disk memory"></p><p><strong><em>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</em></strong></p><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li><p><strong>内存缓存(from memory cache)</strong>：内存缓存具有两个特点，分别是快速读取和时效性：</p><ul><li><p><strong>快速读取</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p></li><li><p><strong>时效性</strong>：一旦该进程关闭，则该进程的内存则会清空。</p></li></ul></li><li><p><strong>硬盘缓存(from disk cache)</strong>：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p></li></ul><p>在浏览器中，浏览器会在<strong>js</strong>和<strong>图片</strong>等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而<strong>css文件</strong>则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。主要有以下两种情况：</p><ul><li>协商缓存生效，返回<strong>304</strong>，如下</li></ul><p><img src="/2018/07/01/browseCache/12.webp" alt="协商缓存生效，返回304"></p><ul><li>协商缓存失效，返回<strong>200</strong>和请求结果结果，如下</li></ul><p><img src="/2018/07/01/browseCache/13.webp" alt="协商缓存失效，返回200"></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h4><ul><li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</li></ul><p><img src="/2018/07/01/browseCache/14.webp" alt="Last-Modified"></p><ul><li><strong>If-Modified-Since</strong> 则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有<code>If-Modified-Since</code>字段，则会根据<code>If-Modified-Since</code>的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为<strong>200</strong>；否则则返回<strong>304</strong>，代表资源无更新，可继续使用缓存文件，如下。</li></ul><p><img src="/2018/07/01/browseCache/15.webp" alt="If-Modified-Since"></p><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><ul><li><strong>Etag</strong> 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</li></ul><p><img src="/2018/07/01/browseCache/16.webp" alt="Etag"></p><ul><li><strong>If-None-Match</strong> 是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，一致则返回<strong>304</strong>，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为<strong>200</strong>，如下。</li></ul><p><img src="/2018/07/01/browseCache/17.webp" alt="If-None-Match"></p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(<code>Expires</code>和<code>Cache-Control</code>)生效则直接使用缓存，若不生效则进行协商缓存(<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回<code>304</code>，继续使用缓存，主要过程如下：</p><p><img src="/2018/07/01/browseCache/18.webp" alt=""></p><p><em>转载自：<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="browserCache" scheme="http://www.goyth.com/tags/browserCache/"/>
    
  </entry>
  
  <entry>
    <title>常见跨域方式梳理</title>
    <link href="http://www.goyth.com/2018/06/29/crossDomain/"/>
    <id>http://www.goyth.com/2018/06/29/crossDomain/</id>
    <published>2018-06-29T13:59:32.000Z</published>
    <updated>2018-06-30T11:16:00.675Z</updated>
    
    <content type="html"><![CDATA[<p>跨域是由于<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源策略</a>导致的，所以跨域只存在于浏览器端，非浏览器端不存在跨域问题，浏览器对跨域的请求、应答都能正常发送接收，只是浏览器在接收跨域应答时，将应答拦截了，所以我们需要一些额外的处理或设置让浏览器将跨域的应答返回给我们。</p><a id="more"></a><h4 id="常见的跨域处理方式有："><a href="#常见的跨域处理方式有：" class="headerlink" title="常见的跨域处理方式有："></a>常见的跨域处理方式有：</h4><ul><li>jsonp</li><li>CORS</li><li>iframe + postMessage</li><li>iframe + window.name</li><li>iframe + location.hash</li><li>iframe + domain</li><li>nginx代理</li><li>Nodejs中间件</li><li>WebSocket</li></ul><h2 id="jsonp-跨域"><a href="#jsonp-跨域" class="headerlink" title="jsonp 跨域"></a>jsonp 跨域</h2><p>jsonp 跨域是利用<code>script</code>标签天生具备跨域的特性，<code>script</code>的<code>src</code>属性发起的请求不受浏览器同源策略的限制，所以我们可以动态生成一个<code>script</code>标签对象，将要请求数据的<code>url</code>赋值给<code>script</code>标签的<code>src</code>属性，然后将此<code>script</code>标签<code>append</code>到<code>body</code>中。但是服务端怎么返回数据呢，返回的数据又如何处理呢？此时我们还需要预先写好一个解析数据的函数<code>analyzeData</code>，并将这个函数名通过请求的<code>url</code>一并传给后端，后端收到后，直接请求的数据放在解析函数<code>analyzeData</code>的参数中<code>analyzeData({a:1,b:2,c:3})</code>并返回，当次<code>script</code>标签加载完毕后就会直接执行<code>analyzeData({a:1,b:2,c:3})</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预先写好一个解析数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">analyzeData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sct = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">sct.src = <span class="string">'http://goyth.com/json?callback=analyzeData'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(sct)</span><br></pre></td></tr></table></figure><p>jsop 的优点是兼容性好，能兼容低版本的浏览器，缺点是只支持<code>get</code>请求，不支持其他方式的请求，并且对回调函数的错误处理不太友好。</p><h2 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h2><p>CORS 全称为跨域资源共享（Cross-origin resource sharing），它是 W3C 用来允许<code>XMLHttpRequest</code>请求跨域的一个标准，也是现在主流的跨域方案。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。</p><p><img src="/2018/06/29/crossDomain/cors.png" alt=""></p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p>跨域请求只需要在服务端应答报文头增加一个<code>Access-Control-Allow-Origin</code>字段，该字段是的值要么是请求时<code>Origin</code>字段的值，要么是一个 <em> ，<code>Access-Control-Allow-Origin=Origin字段的值</code> 表示只接受该域的请求，`Access-Control-Allow-Origin=</em><code>表示接受任意域名的请求。此时的请求是不带</code>Cookie<code>的，如果需要带上</code>Cookie<code>，则需要在发起请求时将</code>XMLHttpRequest<code>实例的</code>withCredentials<code>属性设置为</code>true<code>，在服务端将</code>Access-Control-Allow-Credentials<code>字段设置为</code>true`。</p><p>以下内容直接参考<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰老师的微博</a><br>CORS 分为简单请求和非简单请求，简繁请求符合以下要求：<br>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p><p>（1）Access-Control-Allow-Origin</p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个*，表示接受任意域名的请求。</p><p>（2）Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p><p>（3）Access-Control-Expose-Headers</p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回FooBar字段的值。</p><h4 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h4><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p><p>（1）Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><p>（2）Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><h4 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h4><p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他CORS相关字段如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p>（1）Access-Control-Allow-Methods</p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p>（2）Access-Control-Allow-Headers</p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p>（3）Access-Control-Allow-Credentials</p><p>该字段与简单请求时的含义相同。</p><p>（4）Access-Control-Max-Age</p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h4 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h4><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p><h3 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h2 id="iframe-postMessage"><a href="#iframe-postMessage" class="headerlink" title="iframe + postMessage"></a>iframe + postMessage</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>以 a.com 域下的 a.html 页面向 b.com 域下 b.html 页面通讯为例</p><p>a.com/a.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">iframe.src = <span class="string">'http://b.com/b.html'</span></span><br><span class="line">iframe.style.display = <span class="string">'none'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendElement(iframe)</span><br><span class="line"></span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = &#123;<span class="attr">domain</span> : <span class="string">'a.html'</span>&#125;</span><br><span class="line">  iframe.contentWindow.postMessage(msg, <span class="string">'http://b.com'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = msg.origin  <span class="comment">// 消息来源地址 'http://b.com'</span></span><br><span class="line">  <span class="keyword">let</span> data = msg.data  <span class="comment">// 传送过来的数据 this message is from b.html</span></span><br><span class="line">  <span class="keyword">let</span> source = msg.source  <span class="comment">// 源window对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(data)  <span class="comment">//this message is from b.html</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>b.com/b.html<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = msg.origin  <span class="comment">// 消息来源地址 'http://a.com'</span></span><br><span class="line">  <span class="keyword">let</span> data = msg.data  <span class="comment">// 传送过来的数据 &#123;domain : 'a.html'&#125;</span></span><br><span class="line">  <span class="keyword">let</span> source = msg.source  <span class="comment">// 源window对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(data)  <span class="comment">//&#123;domain : 'a.html'&#125;</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">let</span> data = <span class="string">'this message is from b.html'</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(data, <span class="string">'http://a.html'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="postMessage的使用方法："><a href="#postMessage的使用方法：" class="headerlink" title="postMessage的使用方法："></a>postMessage的使用方法：</h3><ul><li>otherWindow.postMessage(message, targetOrigin);<ul><li>otherWindow<br>其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li><li>message<br>不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li>targetOrigin<br>通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”<em>“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是</em>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</li></ul></li></ul><h3 id="message-的属性有"><a href="#message-的属性有" class="headerlink" title="message 的属性有:"></a>message 的属性有:</h3><ul><li>data<br>从其他 window 中传递过来的对象。</li><li>origin<br>调用 postMessage  时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “<a href="https://example.org" target="_blank" rel="noopener">https://example.org</a> (隐含端口 443)”、“<a href="http://example.net" target="_blank" rel="noopener">http://example.net</a> (隐含端口 80)”、“<a href="http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。" target="_blank" rel="noopener">http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。</a></li><li>source<br>对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。</li></ul><h2 id="iframe-window-name"><a href="#iframe-window-name" class="headerlink" title="iframe + window.name"></a>iframe + window.name</h2><p>window.name 有一个特性就是，在一个窗口（window）下的所有的页面都是共享一个 window.name 对象，只要是同域的情况下，每个页面都可以对window.name 进行读写，不同域是读取不到的。因此我们可以用一个代理iframe将这个iframe的域设置为要请求数据的域，此时是同域请求，是可以请求到数据的，然后将请求的数据赋值给 window.name 对象，再将iframe的域跳转到当前域，然后读取window.name 的值，就实现了跨域通讯。<br>我们以<a href="http://a.com域下的a.html页面向http://b.com域发起一个http://b.com/json请求为例" target="_blank" rel="noopener">http://a.com域下的a.html页面向http://b.com域发起一个http://b.com/json请求为例</a></p><p>我们首先创建一个<a href="http://b.com域下的代理页面proxy.html，通过proxy.html" target="_blank" rel="noopener">http://b.com域下的代理页面proxy.html，通过proxy.html</a> 去发起<a href="http://b.com/json请求，注意此时是同域的所以可以请求成功" target="_blank" rel="noopener">http://b.com/json请求，注意此时是同域的所以可以请求成功</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span>(xhr.readystate === <span class="string">'4'</span> &amp;&amp; xhr.status === <span class="string">'200'</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = xhr.responseText  <span class="comment">// 将获取到的数据赋值给window.name</span></span></span><br><span class="line"><span class="javascript">    location.href = <span class="string">'http://a.com/index.html'</span>  <span class="comment">// 将iframe 的域设置回http://a.com</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">xhr.open(<span class="string">'http://b.com/json'</span>)</span></span><br><span class="line"><span class="undefined">xht.send()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过iframe将代理页面proxy.html与a.html放到一个窗口下，这样就可以读取到 proxy.html 页面设置的 window.name 的值。</p><p><a href="http://a.com/a.html" target="_blank" rel="noopener">http://a.com/a.html</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> time = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span>(++time = <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data  = iframe.contentWindow.name  <span class="comment">// 取出window.name</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.com/proxy.html'</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="iframe-location-hash"><a href="#iframe-location-hash" class="headerlink" title="iframe + location.hash"></a>iframe + location.hash</h2><p>与 iframe + window.name 一样，此方法也是通过一个与请求同域的代理页面去发起请求，然后将请求到的数据放在a.com 域 的hash 部分，赋值给 <code>parent.location.href</code>，这样就可以触发 a.com 域下的 onhashchange 事件，然后通过 <code>location.hash</code> 就可以读取到 hash 部分的数据了</p><p>代理页面 <a href="http://b.com/proxy.html" target="_blank" rel="noopener">http://b.com/proxy.html</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span>(xhr.readystate === <span class="string">'4'</span> &amp;&amp; xhr.status === <span class="string">'200'</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> hash = <span class="built_in">JSON</span>.stringify(xhr.responseText)  <span class="comment">// 将获取到的数据赋值给window.name</span></span></span><br><span class="line"><span class="javascript">    parent.location.href = <span class="string">'http://a.com/index.html#'</span>+ hash <span class="comment">// 此时会触发父页面的onhashchange事件</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 注意这个地方不能使用parent.location.hash，子页面需要与父页面同域才能修改父页面的location.hash，此时是不同域的</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">xhr.open(<span class="string">'http://b.com/json'</span>)</span></span><br><span class="line"><span class="undefined">xht.send()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="http://a.com/a.html" target="_blank" rel="noopener">http://a.com/a.html</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.com/proxy.html'</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe)</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> data = location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="iframe-domain"><a href="#iframe-domain" class="headerlink" title="iframe + domain"></a>iframe + domain</h2><p>这种跨域方式只适用与主域相同的情况下的跨域通信，假如我们现在有两个页面a.html和b.html分别在a.goyth.com和b.goyth.com域下，此时他们的主域都是goyth.com，我们现在只用把两个页面下的 <code>document.domain</code> 都设置成一样，就可以跨域通信了，可以相互读取对方window对象下的数据。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p><p>a.goyth.com/a.html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span> = <span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://b.goyth.com/b.html"</span> <span class="attr">onload</span> = <span class="string">"test()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'￼ifame'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> win = <span class="built_in">document</span>.contentWindow;<span class="comment">//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> doc = win.document;<span class="comment">//这里获取不到iframe里的document对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> name = win.name;<span class="comment">//这里同样获取不到window对象的name属性</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>此时将a.html和b.html的<code>document.domain</code>都设置为<code>goyth.com</code></p><p>a.goyth.com/a.html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span> = <span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://b.goyth.com/b.html"</span> <span class="attr">onload</span> = <span class="string">"test()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">'goyth.com'</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'￼ifame'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> win = <span class="built_in">document</span>.contentWindow;<span class="comment">//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> doc = win.document;<span class="comment">//这里获取不到iframe里的document对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> name = win.name;<span class="comment">//这里同样获取不到window对象的name属性</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>b.goyth.com/b.html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">'goyth.com'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h2><h3 id="nginx配置解决iconfont跨域"><a href="#nginx配置解决iconfont跨域" class="headerlink" title="nginx配置解决iconfont跨域"></a>nginx配置解决iconfont跨域</h3><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nginx反向代理接口跨域"><a href="#nginx反向代理接口跨域" class="headerlink" title="nginx反向代理接口跨域"></a>nginx反向代理接口跨域</h3><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.) 前端代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>2.) Nodejs后台示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Nodejs中间件代理跨域"><a href="#Nodejs中间件代理跨域" class="headerlink" title="Nodejs中间件代理跨域"></a>Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。</p><h3 id="非vue框架的跨域（2次跨域）"><a href="#非vue框架的跨域（2次跨域）" class="headerlink" title="非vue框架的跨域（2次跨域）"></a>非vue框架的跨域（2次跨域）</h3><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:3000/login?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>2.）中间件服务器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    target: <span class="string">'http://www.domain2.com:8080'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    onProxyRes: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Proxy server is listen at port 3000...'</span>);</span><br></pre></td></tr></table></figure></p><p>3.）Nodejs后台同（六：nginx）</p><h3 id="vue框架的跨域（1次跨域）"><a href="#vue框架的跨域（1次跨域）" class="headerlink" title="vue框架的跨域（1次跨域）"></a>vue框架的跨域（1次跨域）</h3><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.）Nodejs socket后台：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a><br><a href="https://www.cnblogs.com/roam/p/7520433.html" target="_blank" rel="noopener">https://www.cnblogs.com/roam/p/7520433.html</a><br><a href="http://web.jobbole.com/88519/" target="_blank" rel="noopener">http://web.jobbole.com/88519/</a><br><a href="https://juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">https://juejin.im/post/5a2f92c65188253e2470f16d</a><br><a href="https://juejin.im/post/5a6320d56fb9a01cb64ee191" target="_blank" rel="noopener">https://juejin.im/post/5a6320d56fb9a01cb64ee191</a><br><a href="https://juejin.im/post/58e8c932ac502e4957bde78b" target="_blank" rel="noopener">https://juejin.im/post/58e8c932ac502e4957bde78b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域是由于&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浏览器同源策略&lt;/a&gt;导致的，所以跨域只存在于浏览器端，非浏览器端不存在跨域问题，浏览器对跨域的请求、应答都能正常发送接收，只是浏览器在接收跨域应答时，将应答拦截了，所以我们需要一些额外的处理或设置让浏览器将跨域的应答返回给我们。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="cross-domain" scheme="http://www.goyth.com/tags/cross-domain/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之apply、call和bind的模拟实现</title>
    <link href="http://www.goyth.com/2018/05/27/applyAndCall/"/>
    <id>http://www.goyth.com/2018/05/27/applyAndCall/</id>
    <published>2018-05-27T09:25:50.000Z</published>
    <updated>2018-05-28T14:11:34.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 <code>null</code> 时，函数上下文为 <code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(obj, [<span class="number">18</span>, <span class="string">'male'</span>]);    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="apply模拟实现"><a href="#apply模拟实现" class="headerlink" title="apply模拟实现"></a>apply模拟实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, arrArgs</span>)</span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>, len=arrArgs.length; i&lt;len; i++)&#123;</span><br><span class="line">    args.push(<span class="string">'arrArgs['</span>+i+<span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span>+args+<span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply2(obj, [<span class="number">18</span>, <span class="string">'male'</span>]);    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。当第一个参数为 <code>null</code> 时，函数上下文也是 <code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, <span class="number">18</span>, <span class="string">'male'</span>);    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure><h2 id="call模拟实现"><a href="#call模拟实现" class="headerlink" title="call模拟实现"></a>call模拟实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>, len=<span class="built_in">arguments</span>.length; i&lt;len; i++)&#123;</span><br><span class="line">    args.push(<span class="string">'arguments['</span>+i+<span class="string">']'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span>+args+<span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call2(obj, <span class="number">18</span>, <span class="string">'male'</span>);    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindfn = func.bind(obj, <span class="number">18</span>);</span><br><span class="line">bindfn(<span class="string">'male'</span>)    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure><h2 id="bind模拟实现"><a href="#bind模拟实现" class="headerlink" title="bind模拟实现"></a>bind模拟实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = [].shift.call(<span class="built_in">arguments</span>) || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Bd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> Bd ? <span class="keyword">this</span> : context, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">  Bd.prototype = <span class="built_in">Object</span>.create(self.prototype);</span><br><span class="line">  <span class="keyword">return</span> Bd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'luke'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">age, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' '</span> + age + <span class="string">' '</span> + gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bindfn = func.bind2(obj, <span class="number">18</span>);</span><br><span class="line">bindfn(<span class="string">'male'</span>)    <span class="comment">// luke 18 male</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;apply&quot;&gt;&lt;a href=&quot;#apply&quot; class=&quot;headerlink&quot; title=&quot;apply()&quot;&gt;&lt;/a&gt;apply()&lt;/h2&gt;&lt;p&gt;apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 &lt;code&gt;null&lt;/code&gt; 时，函数上下文为 &lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : &lt;span class=&quot;string&quot;&gt;&#39;luke&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;age, gender&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name + &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt; + age + &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt; + gender);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func.apply(obj, [&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;male&#39;&lt;/span&gt;]);    &lt;span class=&quot;comment&quot;&gt;// luke 18 male&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.goyth.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染之回流（Reflow）与重绘（Repaint）</title>
    <link href="http://www.goyth.com/2018/05/25/reflowAndRepaint/"/>
    <id>http://www.goyth.com/2018/05/25/reflowAndRepaint/</id>
    <published>2018-05-25T10:39:42.000Z</published>
    <updated>2018-05-28T14:15:46.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p>浏览器渲染流程如下图所示：</p><p><img src="/2018/05/25/reflowAndRepaint/webkitflow.png" alt=""></p><p>大概可以划分成以下几个步骤：</p><ol><li>通过HTML解析器解析HTML文本并构建DOM tree</li><li>通过CSS解析器解析CSS样式表并构建CSSOM tree</li><li>根据DOM tree 和 CSSOM tree 构建 Render tree</li><li>Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Reflow(Layout)进行布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。</li><li>遍历渲染树，对每一个元素节点进行绘制（Painting）</li></ol><p>回流（Reflow）与重绘（Repaint）就分别发生在第四步和第五步</p><a id="more"></a><h2 id="回流（Reflow）和重绘（Repaint）的定义"><a href="#回流（Reflow）和重绘（Repaint）的定义" class="headerlink" title="回流（Reflow）和重绘（Repaint）的定义"></a>回流（Reflow）和重绘（Repaint）的定义</h2><h3 id="回流（Reflow）"><a href="#回流（Reflow）" class="headerlink" title="回流（Reflow）"></a>回流（Reflow）</h3><p>对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算，并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。</p><h3 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a>重绘（Repaint）</h3><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。</p><blockquote><p>回流（Reflow）和重绘（Repaint）会对性能产生一定的影响，尤其是当引发全局的回流和重绘时。</p></blockquote><h2 id="导致回流（Reflow）和重绘（Repaint）的操作"><a href="#导致回流（Reflow）和重绘（Repaint）的操作" class="headerlink" title="导致回流（Reflow）和重绘（Repaint）的操作"></a>导致回流（Reflow）和重绘（Repaint）的操作</h2><ol><li>调整窗口大小</li><li>改变字体</li><li>增加或者移除样式表</li><li>内容变化，比如用户在input框中输入文字</li><li>激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)</li><li>操作 class 属性</li><li>脚本操作 DOM</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值 </li></ol><h2 id="如何尽量避免回流（Reflow）和重绘（Repaint）"><a href="#如何尽量避免回流（Reflow）和重绘（Repaint）" class="headerlink" title="如何尽量避免回流（Reflow）和重绘（Repaint）"></a>如何尽量避免回流（Reflow）和重绘（Repaint）</h2><ol><li><p>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className，即将多次改变样式属性的操作合并成一次操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>,</span><br><span class="line">top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line">el.style.background = <span class="string">'#eee'</span>; </span><br><span class="line"><span class="comment">// 比较好的写法</span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br></pre></td></tr></table></figure></li><li><p>让要操作的元素进行”离线处理”，处理完后一起更新 </p></li></ol><ul><li>使用documentFragment对象进行缓存操作,引发一次回流和重绘； </li><li>使用display:none技术，只引发两次回流和重绘。原理：由于display属性为none的元素不在渲染树中，对隐藏的元素操 作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 </li><li>先克隆Dom节点(cloneNode) 修改完后，再用克隆的Dom节点将原来的节点替换掉，只引发一次回流和重绘； </li></ul><ol><li>将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。因为,它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低</li><li>不要用tables布局的一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li><li>尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。<br>因为改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面 </li><li>不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</li><li>避免使用CSS的JavaScript表达式，如果css里有expression，每次都会重新计算一遍。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器渲染流程&quot;&gt;&lt;a href=&quot;#浏览器渲染流程&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染流程&quot;&gt;&lt;/a&gt;浏览器渲染流程&lt;/h2&gt;&lt;p&gt;浏览器渲染流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/25/reflowAndRepaint/webkitflow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概可以划分成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过HTML解析器解析HTML文本并构建DOM tree&lt;/li&gt;
&lt;li&gt;通过CSS解析器解析CSS样式表并构建CSSOM tree&lt;/li&gt;
&lt;li&gt;根据DOM tree 和 CSSOM tree 构建 Render tree&lt;/li&gt;
&lt;li&gt;Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Reflow(Layout)进行布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。&lt;/li&gt;
&lt;li&gt;遍历渲染树，对每一个元素节点进行绘制（Painting）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回流（Reflow）与重绘（Repaint）就分别发生在第四步和第五步&lt;/p&gt;
    
    </summary>
    
      <category term="Browser" scheme="http://www.goyth.com/categories/Browser/"/>
    
    
      <category term="Reflow" scheme="http://www.goyth.com/tags/Reflow/"/>
    
      <category term="Repaint" scheme="http://www.goyth.com/tags/Repaint/"/>
    
  </entry>
  
  <entry>
    <title>N-Sum 问题</title>
    <link href="http://www.goyth.com/2018/05/25/nsum/"/>
    <id>http://www.goyth.com/2018/05/25/nsum/</id>
    <published>2018-05-25T09:26:18.000Z</published>
    <updated>2018-05-28T14:15:33.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解</p><a id="more"></a><h3 id="JavaScript-版本"><a href="#JavaScript-版本" class="headerlink" title="JavaScript 版本"></a>JavaScript 版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; result</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; results 结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findNsum</span>(<span class="params">nums, target, n, result, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span> || nums.length &lt; n || target &lt; nums[<span class="number">0</span>] * n || target &gt; nums[nums.length<span class="number">-1</span>] * n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> l = <span class="number">0</span>,</span><br><span class="line">            r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">let</span> s = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(s == target)&#123;</span><br><span class="line">                results.push(result.concat(nums[l], nums[r]));</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>])&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &lt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>])&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums.length - n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || ( i&gt;<span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))&#123;</span><br><span class="line">                findNsum(nums.slice(i+<span class="number">1</span>), target - nums[i], n - <span class="number">1</span>, result.concat(nums[i]), results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNsum</span><span class="params">(nums, target, N, result, results)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; N <span class="keyword">or</span> N &lt; <span class="number">2</span> <span class="keyword">or</span> target &lt; nums[<span class="number">0</span>]*N <span class="keyword">or</span> target &gt; nums[<span class="number">-1</span>]*N:  <span class="comment"># early termination</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">2</span>: <span class="comment"># two pointers solve sorted 2-sum problem</span></span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            s = nums[l] + nums[r]</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                results.append(result + [nums[l], nums[r]])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l<span class="number">-1</span>]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r+<span class="number">1</span>]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l<span class="number">-1</span>]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r+<span class="number">1</span>]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># recursively reduce N</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] != nums[i]):</span><br><span class="line">                findNsum(nums[i+<span class="number">1</span>:], target-nums[i], N<span class="number">-1</span>, result+[nums[i]], results)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&amp;gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>浏览器页面渲染流程梳理</title>
    <link href="http://www.goyth.com/2018/05/23/browserRendering/"/>
    <id>http://www.goyth.com/2018/05/23/browserRendering/</id>
    <published>2018-05-23T09:14:52.000Z</published>
    <updated>2018-05-28T14:11:44.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染基本流程"><a href="#浏览器渲染基本流程" class="headerlink" title="浏览器渲染基本流程"></a>浏览器渲染基本流程</h2><p>浏览器渲染流程如下图所示：</p><p><img src="/2018/05/23/browserRendering/webkitflow.png" alt=""><br><em>图片来源：<a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a></em></p><p>大概可以划分成以下几个步骤：</p><ol><li>通过HTML解析器解析HTML文本并构建DOM tree</li><li>通过CSS解析器解析CSS样式表并构建CSSOM tree</li><li>根据DOM tree 和 CSSOM tree 构建 Render tree</li><li>Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Layout(Reflow)进行布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。</li><li>遍历渲染树，对每一个元素节点进行绘制（Painting）</li></ol><a id="more"></a><h3 id="解析（Parsing）"><a href="#解析（Parsing）" class="headerlink" title="解析（Parsing）"></a>解析（Parsing）</h3><p>解析的过程分为两个步骤：词法分析和语法分析。<br>词法分析负责将输入内容分解成一个个有效标记；而语法分析负责根据语言的语法规则分析文档的结构，从而构建解析树。通过词法分析可以将无关的字符（比如空格和换行符）分离出来。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/parsing.png" alt="从源文档到解析树" align="center"><br></div><br><div align="center"><br><em>图：从源文档到解析树</em><br></div><p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p><p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p><h3 id="转译-Translation"><a href="#转译-Translation" class="headerlink" title="转译(Translation)"></a>转译(Translation)</h3><p>很多时候，解析树还不是最终产品。解析通常是在转译过程中使用的，而转译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/translate.png" alt="编译流程" align="center"><br></div><br><div align="center"><br><em>图：编译流程</em><br></div><h3 id="HTML解析"><a href="#HTML解析" class="headerlink" title="HTML解析"></a>HTML解析</h3><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“<a href="https://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document" target="_blank" rel="noopener">Document</a>”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt; &lt;img src="example.png"/</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><p>可翻译成如下的 DOM 树：</p><div align="center"><br> <img src="/2018/05/23/browserRendering/domtree.png" alt="示例标记的 DOM 树" align="center"><br></div><br><div align="center"><br><em>图：示例标记的 DOM 树</em><br></div><h5 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h5><p><a href="https://html.spec.whatwg.org/multipage/parsing.html" target="_blank" rel="noopener">HTML5 规范详细地描述了解析算法</a>。此算法由两个阶段组成：标记化和树构建。</p><p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/htmlparse.png" alt="HTML 解析流程（摘自 HTML5 规范）" align="center"><br></div><br><div align="center"><br><em>图：HTML 解析流程（摘自 HTML5 规范）</em><br></div><h3 id="CSS解析"><a href="#CSS解析" class="headerlink" title="CSS解析"></a>CSS解析</h3><p>和 HTML 不同，CSS 是上下文无关的语法。事实上，<a href="https://www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="noopener">CSS 规范定义了 CSS 的词法和语法</a>。</p><p>WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/cssparse.png" alt="解析 CSS" align="center"><br></div><br><div align="center"><br><em>图：解析 CSS</em><br></div><h3 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>网络的模型是同步的。网页解析器遇到 <code>&lt;script&gt;</code> 标记时文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。你可以在<code>&lt;script&gt;</code> 标签上添加“defer”属性（<code>&lt;script defer&gt;</code>），这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个async属性，可将脚本标记为异步<code>&lt;script async&gt;</code>），以便由其他线程解析和执行。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p><h3 id="Render-tree构建"><a href="#Render-tree构建" class="headerlink" title="Render tree构建"></a>Render tree构建</h3><div align="center"><br> <img src="/2018/05/23/browserRendering/render-tree-construction.png" alt="Render tree构建" align="center"><br></div><br><div align="center"><br><em>图：Render tree构建</em><br></div><p>Render tree是由 DOM 和 CSSOM 组合构建而成的。也是页面可视化元素按照其显示顺序而组成的树，是文档的可视化表示。它的作用是让浏览器按照正确的顺序绘制内容。</p><p>Firefox 将Render tree中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。 </p><h4 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h4><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。<br>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p><p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/render&dom.png" alt="呈现树及其对应的 DOM 树" align="center"><br></div><br><div align="center"><br><em>图：呈现树及其对应的 DOM 树</em><br></div><h3 id="布局（Layout-Reflow）"><a href="#布局（Layout-Reflow）" class="headerlink" title="布局（Layout/Reflow）"></a>布局（Layout/Reflow）</h3><p>当Render Tree刚构建完时，并不包含元素节点的位置和大小信息。计算这些值的过程称为布局或重排。</p><p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历。</p><p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p><p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</html></p><p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。<br>所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p><h4 id="Dirty-位系统"><a href="#Dirty-位系统" class="headerlink" title="Dirty 位系统"></a>Dirty 位系统</h4><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p><p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p><h4 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h4><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p><ol><li>影响所有呈现器的全局样式更改，例如字体大小更改。</li><li>屏幕大小调整。</li></ol><p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p><div align="center"><br> <img src="/2018/05/23/browserRendering/reflow.png" alt="增量布局 - 只有 dirty 呈现器及其子代进行布局" align="center"><br></div><br><div align="center"><br><em>图：增量布局 - 只有 dirty 呈现器及其子代进行布局</em><br></div><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><h4 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h4><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p><h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p><a href="https://www.w3.org/TR/CSS21/zindex.html" target="_blank" rel="noopener">CSS2 规范定义了绘制流程的顺序</a>。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><h4 id="WebKit-矩形存储"><a href="#WebKit-矩形存储" class="headerlink" title="WebKit 矩形存储"></a>WebKit 矩形存储</h4><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图(Bitmap)，然后只绘制新旧矩形之间的差异部分。</p><h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p><p>参考链接</p><ul><li><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a></li><li><a href="https://www.youtube.com/watch?v=SmE4OwHztCc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=SmE4OwHztCc</a></li><li><a href="https://www.youtube.com/watch?v=0IsQqJ7pwhw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=0IsQqJ7pwhw</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器渲染基本流程&quot;&gt;&lt;a href=&quot;#浏览器渲染基本流程&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染基本流程&quot;&gt;&lt;/a&gt;浏览器渲染基本流程&lt;/h2&gt;&lt;p&gt;浏览器渲染流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/23/browserRendering/webkitflow.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;em&gt;图片来源：&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;大概可以划分成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过HTML解析器解析HTML文本并构建DOM tree&lt;/li&gt;
&lt;li&gt;通过CSS解析器解析CSS样式表并构建CSSOM tree&lt;/li&gt;
&lt;li&gt;根据DOM tree 和 CSSOM tree 构建 Render tree&lt;/li&gt;
&lt;li&gt;Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Layout(Reflow)进行布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。&lt;/li&gt;
&lt;li&gt;遍历渲染树，对每一个元素节点进行绘制（Painting）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Browser" scheme="http://www.goyth.com/categories/Browser/"/>
    
    
      <category term="Browser rendering" scheme="http://www.goyth.com/tags/Browser-rendering/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之函数防抖与节流</title>
    <link href="http://www.goyth.com/2018/05/10/debounceAndThrottle/"/>
    <id>http://www.goyth.com/2018/05/10/debounceAndThrottle/</id>
    <published>2018-05-10T08:31:07.000Z</published>
    <updated>2018-05-28T14:12:44.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数防抖（debounce"><a href="#函数防抖（debounce" class="headerlink" title="函数防抖（debounce)"></a>函数防抖（debounce)</h2><p>函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。</p><p>根据描述，我们可以用<code>setTimeout</code>来实现一个简单版的防抖函数</p><a id="more"></a><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ delay 延迟时间 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(fn, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- mo--><p>由于<code>setTimeout</code>的回调函数内的<code>this</code>是指向<code>window</code>，如果不传参数则<code>argument</code>对象为空，所以我们得修复<code>this</code>的指向，并将<code>argument</code>对象也传给回调函数</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ delay 延迟时间 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            arg = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, arg);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们新增一个立即执行的需求，就是第一次触发后就立即执行，然后再等待n秒后再执行，n秒内如果有触发则重新计时。我们新增一个参数immediate，true表示立即执行，false表示非立即执行</p><h3 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ delay 延迟时间 </span><br><span class="line">* @ immediate 是否立即执行 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay, immediate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            arg = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                fn.apply(context, arg);</span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fn.apply(context, arg);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="underscore-实现版本："><a href="#underscore-实现版本：" class="headerlink" title="underscore 实现版本："></a>underscore 实现版本：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line">        <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, wait - last);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">                result = func.apply(context, args);</span><br><span class="line">                <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        timestamp = _.now();</span><br><span class="line">        <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><p>函数节流是指每隔n秒钟就执行一次事件，不管你在n秒内触发了多少次事件，都是每隔n秒才执行一次。</p><p>可以用定时器和时间戳两种方式实现</p><h3 id="时间戳版本"><a href="#时间戳版本" class="headerlink" title="时间戳版本"></a>时间戳版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ wait 间隔时间 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">let</span> remain = now - pre;</span><br><span class="line">        <span class="keyword">if</span>(remain &gt;= wait || remain &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间戳版本，第一次会立即触发并执行回调函数，但是最后一次触发如果是在最后一个n秒内发生的，则最后一次触发并不会执行回调函数</p><h3 id="定时器版本"><a href="#定时器版本" class="headerlink" title="定时器版本"></a>定时器版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ wait 间隔时间 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            arg = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fn.apply(context, arg);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器版本第一次触发后会在n秒后再执行回调函数，最后一次触发如果是在最后一个n秒内发生，则最后一次触发也会执行回调函数</p><p>我们可以结合两个版本的优点实现一个首次会立即执行，最后一次也会执行的版本</p><h3 id="时间戳定时器混合版本"><a href="#时间戳定时器混合版本" class="headerlink" title="时间戳定时器混合版本"></a>时间戳定时器混合版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ fn 回调函数 </span><br><span class="line">* @ wait 间隔时间 </span><br><span class="line">*／</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>，</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            arg = <span class="built_in">arguments</span>,</span><br><span class="line">            now = +<span class="keyword">new</span> Data(),</span><br><span class="line">            remaining = wait - (now - pre);</span><br><span class="line">        <span class="keyword">if</span>((remaining &lt; <span class="number">0</span> || remaining &gt;= wait))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">                pre = now;</span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                pre = now;</span><br><span class="line">                fn.apply(context, arg);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                pre = now;</span><br><span class="line">                fn.apply(context, arg);</span><br><span class="line">            &#125;, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="underscore实现版本"><a href="#underscore实现版本" class="headerlink" title="underscore实现版本"></a>underscore实现版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">／**</span><br><span class="line">* @ func 回调函数 </span><br><span class="line">* @ wait 间隔时间 </span><br><span class="line">* @ options options.leading = <span class="literal">true</span> 表示首次立即执行 options.leading = <span class="literal">false</span> 表示首次不立即执行 ；</span><br><span class="line">* @     options.trailing = <span class="literal">true</span> 表示最后一次执行 options.trailing = <span class="literal">false</span> 表示最后一次不执行 </span><br><span class="line">*／</span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = _.now();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>underscore 的版本有一个很好的地方就是当事件频繁触发时不用一直设置定时器和清除定时器。但是这个版本有两个问题，第一个就是当设置<code>options.leading = false</code> 和 <code>options.trailing = false</code> 首次调用时 <code>remaining = wait</code> if 和 else if 分支都不会进去，这是一个bug；第二个问题就是当设置<code>options.leading = true</code> 和 <code>options.trailing = true</code> 首次调用时 <code>previous = 0</code> now 等于一个很大的正数，<code>remaining = wait - (now - 0) &lt; 0</code> 数一个很大的负数，<code>timeout = null; !timeout = true</code> 进入 else if 分支的时候，执行<code>timeout = setTimeout(later, remaining);</code>的时候，给定时器设延迟执行，这应该</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数防抖（debounce&quot;&gt;&lt;a href=&quot;#函数防抖（debounce&quot; class=&quot;headerlink&quot; title=&quot;函数防抖（debounce)&quot;&gt;&lt;/a&gt;函数防抖（debounce)&lt;/h2&gt;&lt;p&gt;函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。&lt;/p&gt;
&lt;p&gt;根据描述，我们可以用&lt;code&gt;setTimeout&lt;/code&gt;来实现一个简单版的防抖函数&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="Debounce" scheme="http://www.goyth.com/tags/Debounce/"/>
    
      <category term="Throttle" scheme="http://www.goyth.com/tags/Throttle/"/>
    
  </entry>
  
  <entry>
    <title>基于 Docker 构建前端持续集成开发环境</title>
    <link href="http://www.goyth.com/2018/05/08/dockerDeploy/"/>
    <id>http://www.goyth.com/2018/05/08/dockerDeploy/</id>
    <published>2018-05-08T09:24:13.000Z</published>
    <updated>2018-05-08T09:35:54.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。</p><h4 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h4><ol><li><p>CI（持续集成）：<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" title="CI 介绍" target="_blank" rel="noopener">阮一峰老师的关于 CI 的介绍</a></p></li><li><p>Docker： <a href="http://guide.daocloud.io/dcs/docker-9152673.html" target="_blank" rel="noopener">Docker 快速入门</a></p></li></ol><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><ol><li><p>代码无需在本地构建</p></li><li><p>只需将代码推上 Github ，自动构建 -&gt; 部署</p></li><li><p>版本易管理，可轻松回退版本</p></li></ol><a id="more"></a><h2 id="现在开始进入主题"><a href="#现在开始进入主题" class="headerlink" title="现在开始进入主题"></a>现在开始进入主题</h2><h3 id="第一步：-初始化-Vue-项目（使用vue官方脚手架-vue-cli"><a href="#第一步：-初始化-Vue-项目（使用vue官方脚手架-vue-cli" class="headerlink" title="第一步： 初始化 Vue 项目（使用vue官方脚手架 vue-cli)"></a>第一步： 初始化 Vue 项目（使用vue官方脚手架 <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a>)</h3><ol><li><p>初始化 vue 项目：vue init webpack vue-docker-demo</p></li><li><p>在项目根目录下编 Dockerfile<br><img src="/2018/05/08/dockerDeploy/vue-docker.png" alt="" title="vue-docker"></p></li></ol><p>Dockerfile 内容如下（如果是构建其他项目，比如 angular4，只需安装 angular-cli，将构建参数改成 ng build 即可，大同小异）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 使用 node 6.10.3 的精简版作为基础镜像</span><br><span class="line">FROM node:6.10.3-slim</span><br><span class="line"></span><br><span class="line"># 安装nginx</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y nginx</span><br><span class="line"></span><br><span class="line"># 指定工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将当前目录下的所有文件拷贝到工作目录下</span><br><span class="line">COPY . /app/</span><br><span class="line"></span><br><span class="line"># 声明运行时容器提供服务端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 1. 安装依赖</span><br><span class="line"># 2. 运行 npm run buil</span><br><span class="line"># 3. 将 dist 目录的所有文件拷贝到 nginx 的目录下</span><br><span class="line"># 4. 删除工作目录的文件，尤其是 node_modules 以减小镜像体积</span><br><span class="line"># 由于镜像构建的每一步都会产生新层</span><br><span class="line"># 为了减小镜像体积，尽可能将一些同类操作，集成到一个步骤中，如下</span><br><span class="line">RUN npm install \</span><br><span class="line">    &amp;&amp; npm run build \</span><br><span class="line">    &amp;&amp; cp -r dist/* /var/www/html \</span><br><span class="line">    &amp;&amp; rm -rf /app</span><br><span class="line"></span><br><span class="line"># 以前台方式启动 nginx </span><br><span class="line">CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><ol><li>初始化 git， 连接并将代码推送到 Github 仓库<br><img src="/2018/05/08/dockerDeploy/github.png" alt="" title="vue-docker-dome"></li></ol><h3 id="第二步：使用-DaoCloud-搭建-Devops-流程"><a href="#第二步：使用-DaoCloud-搭建-Devops-流程" class="headerlink" title="第二步：使用 DaoCloud 搭建 Devops 流程"></a>第二步：使用 <a href="https://dashboard.daocloud.io/" target="_blank" rel="noopener">DaoCloud</a> 搭建 Devops 流程</h3><p>（也可以使用其他公有云服务，差别不大，本文将以简单易操作并且对个人开发者免费的 DaoCloud 为例）1. 注册一个 DaoCloud 账号2. 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库</p><ol><li><p>注册一个 DaoCloud 账号</p></li><li><p>用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库<br><img src="/2018/05/08/dockerDeploy/daocloud1.png" alt="" title="vue-docker-dome"></p></li><li><p>在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目，点击“开始创建”<br><img src="/2018/05/08/dockerDeploy/daocloud2.png" alt="" title="vue-docker-dome"></p></li><li><p>先手动构建一个镜像版本，便于下面用这个镜像版本创建一个应用<br><img src="/2018/05/08/dockerDeploy/daocloud3.png" alt="" title="vue-docker-dome"></p></li></ol><p><img src="/2018/05/08/dockerDeploy/daocloud4.png" alt="" title="vue-docker-dome"></p><ol><li>连接自有主机（没有自有主机的，也可以使用云端测试环境）</li></ol><p>tips：可以去购买 vultr 等主机，按照指示流程完成主机接入，大概很简单的三四步操作，注意在完成主机连接后，需要手动在主机上启动 docker（service docker start）</p><p><img src="/2018/05/08/dockerDeploy/daocloud5.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud6.png" alt="" title="vue-docker-dome"></p><p>太酷了，我们已经将我们的主机接入了 DaoCloud，接下来就来完成最有意思的一步。</p><ol><li>创建一个应用</li></ol><p>进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境</p><p><img src="/2018/05/08/dockerDeploy/daocloud7.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud8.png" alt="" title="vue-docker-dome"></p><p>稍等片刻，便可以点击“立即部署”</p><p><img src="/2018/05/08/dockerDeploy/daocloud9.png" alt="" title="vue-docker-dome"></p><p>等待完成镜像拉取，待容器列表中的容器起来后，通过地址查看我们部署的 vue 应用</p><p><img src="/2018/05/08/dockerDeploy/daocloud10.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud11.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud12.png" alt="" title="vue-docker-dome"></p><p>我们已经可以访问到我们刚才部署的 vue 应用了，也表示我们已经将我们的镜像部署到我们的自有主机上去了，此时进入主机查看容器运行情况，可以看到有一个正在运行中的容器，正是我们刚刚部署的，一切都是完美的。</p><p><img src="/2018/05/08/dockerDeploy/daocloud13.png" alt="" title="vue-docker-dome"></p><p>完成到这里，我们可以说已经完成了 99% 的工作，但是还非常重要的最后 1%，那就是真正的自定义持续集成流程，让一切都自动化起来，现在让我们回到刚才 Devops 项目的【流程定义】中去</p><ol><li>定义自动构建，自动发布任务回到 Devops 项目里对自动化流程进行定义</li></ol><p><img src="/2018/05/08/dockerDeploy/daocloud14.png" alt="" title="vue-docker-dome"></p><p>首先我们来定义一下自动构建任务，我们设定规则是只有在有新 tag 时才执行构建任务，构建时查找根目录下的 Dockerfile，并以此构建镜像</p><p><img src="/2018/05/08/dockerDeploy/daocloud31.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud16.png" alt="" title="vue-docker-dome"></p><p>其次，我们再来定义自动发布任务，当构建任务完成时自动触发自动发布任务，并发布到自有主机的应用上去</p><p><img src="/2018/05/08/dockerDeploy/daocloud17.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud18.png" alt="" title="vue-docker-dome"></p><p><img src="/2018/05/08/dockerDeploy/daocloud19.png" alt="" title="vue-docker-dome"></p><p>至此，我们已经完成了，所有流程控制工作，去测试一下整个流程是否能走通？</p><h3 id="第三步：-测试整个流程"><a href="#第三步：-测试整个流程" class="headerlink" title="第三步： 测试整个流程"></a>第三步： 测试整个流程</h3><p>回到我们本地，修改一下文本内容，提交，并推送到远端，并且打下我们的第一个版本tag 1.1.1，并将 tag 推送到远端</p><p><img src="/2018/05/08/dockerDeploy/daocloud20.png" alt="" title="vue-docker-dome"></p><p>可以看到，与此同时，我们打 tag 的操作触发了我们定义的 CI 流程</p><p><img src="/2018/05/08/dockerDeploy/daocloud32.png" alt="" title="vue-docker-dome"><br><img src="/2018/05/08/dockerDeploy/daocloud33.png" alt="" title="vue-docker-dome"></p><p>稍等片刻，可以看到我们的应用更新了，对应的版本就是我们刚刚推上去的 1.1.1</p><p><img src="/2018/05/08/dockerDeploy/daoloud23.png" alt="" title="vue-docker-dome"></p><p>我们还可以对应用的版本进行切换，回退等操作</p><p><img src="/2018/05/08/dockerDeploy/daocloud34.png" alt="" title="vue-docker-dome"></p><p>至此，我们在只编写了一个 Dockerfile 配置文件，没有编写脚本的情况下，成功地搭建了一套前端的持续集成开发环境，之后我们只需要专心编写我们的业务代码就好了，打一个 Tag 便可以轻松地完成自动部署上线。</p><p>参考链接：<a href="https://juejin.im/post/5a142d7b6fb9a0451170c2c7" target="_blank" rel="noopener">https://juejin.im/post/5a142d7b6fb9a0451170c2c7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。&lt;/p&gt;
&lt;h4 id=&quot;前置知识：&quot;&gt;&lt;a href=&quot;#前置知识：&quot; class=&quot;headerlink&quot; title=&quot;前置知识：&quot;&gt;&lt;/a&gt;前置知识：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CI（持续集成）：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&quot; title=&quot;CI 介绍&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰老师的关于 CI 的介绍&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Docker： &lt;a href=&quot;http://guide.daocloud.io/dcs/docker-9152673.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker 快速入门&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;目标：&quot;&gt;&lt;a href=&quot;#目标：&quot; class=&quot;headerlink&quot; title=&quot;目标：&quot;&gt;&lt;/a&gt;目标：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码无需在本地构建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只需将代码推上 Github ，自动构建 -&amp;gt; 部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;版本易管理，可轻松回退版本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.goyth.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://www.goyth.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 原型链与继承</title>
    <link href="http://www.goyth.com/2018/04/23/prototypeAndExtend/"/>
    <id>http://www.goyth.com/2018/04/23/prototypeAndExtend/</id>
    <published>2018-04-23T04:23:43.000Z</published>
    <updated>2018-05-28T06:30:48.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性指向 <code>prototype</code> 属性所在的函数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/04/23/prototypeAndExtend/Person.png" alt=""></p><p>当我们用构造函数创建一个实例时，也会为这个实例创建一个 <code>__proto__</code> 属性，这个<code>__proto__</code> 属性是一个指针指向构造函数的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person = new Person();</span><br><span class="line">person.__proto__ === Person.prototype    // true</span><br><span class="line">let person1 = new Person();</span><br><span class="line">person1.__proto__ === Person.prototype    // true</span><br></pre></td></tr></table></figure><p>由于同一个构造函数创建的所有实例对象的<code>__proto__</code> 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Luke&quot;;</span><br><span class="line">Person.prototype.age = 18;</span><br><span class="line">let person1 = new Person();</span><br><span class="line">let person2 = new Person();</span><br><span class="line">alert(person1.name)    // &quot;Luke&quot;</span><br><span class="line">alert(person2.name)    // &quot;Luke&quot;</span><br><span class="line">Person.prototype.name = &quot;Jack&quot;;</span><br><span class="line">alert(person1.name)    // &quot;Jack&quot;</span><br><span class="line">alert(person2.name)    // &quot;Jack&quot;</span><br></pre></td></tr></table></figure><h3 id="重写原型对象"><a href="#重写原型对象" class="headerlink" title="重写原型对象"></a>重写原型对象</h3><p>我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Luke&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将 <code>Person.prototype</code> 设置为一个新对象，而这个对象中没有<code>constructor</code>属性，这导致 <code>constructor</code> 属性不再指向 <code>Person</code>，而是指向 <code>Object</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let friend = new Person();</span><br><span class="line">alert(friend.constructor  === Person);    //false </span><br><span class="line">alert(friend.constructor  === Object);    //true</span><br></pre></td></tr></table></figure><p>如果 <code>constructor</code> 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    name : &quot;Luke&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链及原型链继承"><a href="#原型链及原型链继承" class="headerlink" title="原型链及原型链继承"></a>原型链及原型链继承</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();    //继承了 Super </span><br><span class="line"></span><br><span class="line">Sub.prototype.getSubValue = function ()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = new Sub();</span><br><span class="line">console.log(instance.getSuperValue());    //true</span><br><span class="line"></span><br><span class="line">console.log(instance.__proto__ === Sub.prototype);    //true</span><br><span class="line">console.log(Sub.prototype.__proto__ === Super.prototype);    //true</span><br></pre></td></tr></table></figure><p>上面的代码中<code>Sub.prototype = new Super();</code>通过创建Super的实例，并将该实例赋值给<code>Sub.prototype</code>来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的<code>__proto__</code>属性指向Sub的原型对象<code>Sub.prototype</code>，Sub原型对象的<code>__proto__</code>属性又指向Super的原型对象<code>Super.prototype</code>。</p><h4 id="原型链搜索机制"><a href="#原型链搜索机制" class="headerlink" title="原型链搜索机制"></a>原型链搜索机制</h4><p>当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链<code>Object.prototype</code>中，任然没有找到则返回<code>undefined</code>。就拿上面的例子来说，调用<code>instance.getSuperValue()</code>会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。</p><h4 id="原型链问题"><a href="#原型链问题" class="headerlink" title="原型链问题"></a>原型链问题</h4><p>原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Sub()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = new Super();    // 继承了Super</span><br><span class="line"></span><br><span class="line">let instance1 = new Sub();</span><br><span class="line"></span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new Sub();</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green, black&quot;</span><br></pre></td></tr></table></figure><p>上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。<br>原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。</p><h3 id="构造函数继承（经典继承）"><a href="#构造函数继承（经典继承）" class="headerlink" title="构造函数继承（经典继承）"></a>构造函数继承（经典继承）</h3><p>即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Super()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Sub()&#123;</span><br><span class="line">    Super.call(this);    //继承了Super </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new Sub();</span><br><span class="line"></span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new Sub();</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br></pre></td></tr></table></figure><p>上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。</p><h4 id="构造函数继承问题"><a href="#构造函数继承问题" class="headerlink" title="构造函数继承问题"></a>构造函数继承问题</h4><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.sayName = function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this);    //继承了Super 属性 (第二次调用Sup构造函数)</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = new Super();    // 继承了Super 原型链上的方法 (第一次调用Sup构造函数)</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.sayAge = function ()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;Luke&quot;, 18);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line">instance1.sayName();    //&quot;Luke&quot;</span><br><span class="line">instance1.sayAge()    //18</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Jack&quot;, 20);</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br><span class="line">instance2.sayName();    //&quot;Jack&quot;</span><br><span class="line">instance2.sayAge()    //20</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。<br>组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。但是美中不足的是，上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。</p><h3 id="优化后的组合继承"><a href="#优化后的组合继承" class="headerlink" title="优化后的组合继承"></a>优化后的组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Super.prototype.sayName = function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Sub(name, age)&#123;</span><br><span class="line">    Super.call(this);    //继承了Super 属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F()&#123;</span><br><span class="line">&#125;</span><br><span class="line">F.prototype = Super.prototype; </span><br><span class="line">Sub.prototype = new F();    // 继承了Super 原型链上的方法</span><br><span class="line"></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.sayAge = function ()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new Sub(&quot;Luke&quot;, 18);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);    //&quot;red, blue, green, black&quot;</span><br><span class="line">instance1.sayName();    //&quot;Luke&quot;</span><br><span class="line">instance1.sayAge()    //18</span><br><span class="line"></span><br><span class="line">var instance2 = new Sub(&quot;Jack&quot;, 20);</span><br><span class="line">alert(instance2.colors);    //&quot;red, blue, green&quot;</span><br><span class="line">instance2.sayName();    //&quot;Jack&quot;</span><br><span class="line">instance2.sayAge()    //20</span><br></pre></td></tr></table></figure><p>上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。这是最理想的继承方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h3&gt;&lt;p&gt;无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 &lt;code&gt;prototype&lt;/code&gt; 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 &lt;code&gt;constructor&lt;/code&gt;（构造函数）属性，这个属性指向 &lt;code&gt;prototype&lt;/code&gt; 属性所在的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="Prototype" scheme="http://www.goyth.com/tags/Prototype/"/>
    
      <category term="Extend" scheme="http://www.goyth.com/tags/Extend/"/>
    
  </entry>
  
  <entry>
    <title>JS 的正则表达式</title>
    <link href="http://www.goyth.com/2018/04/01/JSRegExp/"/>
    <id>http://www.goyth.com/2018/04/01/JSRegExp/</id>
    <published>2018-04-01T08:22:03.000Z</published>
    <updated>2018-05-28T14:14:46.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。<br>核心是 匹配，匹配位置或者匹配字符</p><a id="more"></a><h3 id="先简单的介绍一下语法"><a href="#先简单的介绍一下语法" class="headerlink" title="先简单的介绍一下语法"></a>先简单的介绍一下语法</h3><h4 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h4><ol><li><code>.</code>： 匹配除了换行符之外的任何单个字符</li><li><code>\</code> ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前<code>\</code>的<code>&#39;b&#39;</code>通常匹配小写<code>&#39;b&#39;</code>，无论它们出现在哪里。如果加了<code>&#39;\&#39;</code>,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 <code>/a*/</code> 代表会匹配 0   a。相反，模式 <code>/a\*/</code> 将 ‘ <code>*</code> ‘ 的特殊性移除，从而可以匹配像 <code>&quot;a*&quot;</code> 这样的字符串。</li><li><code>|</code> ： 逻辑或操作符</li><li><code>[ ]</code> ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 <code>.</code> ，<code>\</code>这些字符都表示其本身</li><li><code>[^ ]</code> ：对上面一个集合取非</li><li><code>-</code> ：定义一个区间，例如<code>[A-Z]</code>，其首尾字符在 ASCII 字符集里面<!-- <font style="background:#FFF5F5" color="#FC563C" >-</font>  --></li></ol><h4 id="数量元字符"><a href="#数量元字符" class="headerlink" title="数量元字符"></a>数量元字符</h4><ol><li><code>{m,n}</code> ：匹配前面一个字符至少 m 次至多 n 次重复，还有<code>{m}</code>表示匹配 m 次，<code>{m,}</code>表示至少 m 次</li><li><code>+</code> ： 匹配前面一个表达式一次或者多次，相当于 <code>{1,}</code>，记忆方式追加(+)，起码得有一次</li><li><code>*</code> ： 匹配前面一个表达式零次或者多次，相当于 <code>{0,}</code>，记忆方式乘法(*)，可以一次都没有</li><li><code>?</code> ： 单独使用匹配前面一个表达式零次或者一次，相当于 <code>{0,1}</code>，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词<code>*</code>, <code>+</code>, <code>?</code>, <code>{}</code> 后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 <code>/\d+/</code> 将会返回 “123”，如果使用 <code>/\d+?/</code>,那么就只会匹配到 “1”。</li></ol><h4 id="位置元字符"><a href="#位置元字符" class="headerlink" title="位置元字符"></a>位置元字符</h4><ol><li><code>^</code> ： 单独使用匹配表达式的开始</li><li><code>\$</code> ： 匹配表达式的结束</li><li><code>\b</code> ：匹配单词边界</li><li><code>\B</code> ：匹配非单词边界</li><li><code>(?=p)</code> ：匹配 p 前面的位置</li><li><code>(?!p)</code> ：匹配不是 p 前面的位置</li></ol><h4 id="标志字符"><a href="#标志字符" class="headerlink" title="标志字符"></a>标志字符</h4><ol><li><code>g</code> : 全局搜索 记忆方式global</li><li><code>i</code> ：不区分大小写 记忆方式 ignore</li><li><code>m</code> ：多行搜索</li></ol><h3 id="在-js-中的使用"><a href="#在-js-中的使用" class="headerlink" title="在 js 中的使用"></a>在 js 中的使用</h3><h4 id="支持正则的-String-对象的方法"><a href="#支持正则的-String-对象的方法" class="headerlink" title="支持正则的 String 对象的方法"></a>支持正则的 String 对象的方法</h4><ul><li><code>search</code><br>search 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1</li><li><code>match</code><br>match 接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'For more information, see Chapter 3.4.5.1'</span>;</span><br><span class="line"> <span class="keyword">var</span> re = <span class="regexp">/see (chapter \d+(\.\d)*)/i</span>;</span><br><span class="line"> <span class="keyword">var</span> found = str.match(re);</span><br><span class="line"> <span class="built_in">console</span>.log(found);</span><br><span class="line"> <span class="comment">// (3) ["see Chapter 3.4.5.1", "Chapter 3.4.5.1", ".1", index: 22, input: "For more information, see Chapter 3.4.5.1"]</span></span><br><span class="line"> <span class="comment">// 0:"see Chapter 3.4.5.1"</span></span><br><span class="line"> <span class="comment">// 1:"Chapter 3.4.5.1"</span></span><br><span class="line"> <span class="comment">// 2:".1"</span></span><br><span class="line"> <span class="comment">// index:22</span></span><br><span class="line"> <span class="comment">// input:"For more information, see Chapter 3.4.5.1"</span></span><br><span class="line"> <span class="comment">// length:3</span></span><br><span class="line"> <span class="comment">// __proto__:Array(0)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 'see Chapter 3.4.5.1' 是整个匹配。</span></span><br><span class="line"> <span class="comment">// 'Chapter 3.4.5.1' 被'(chapter \d+(\.\d)*)'捕获。</span></span><br><span class="line"> <span class="comment">// '.1' 是被'(\.\d)'捕获的最后一个值。</span></span><br><span class="line"> <span class="comment">// 'index' 属性(22) 是整个匹配从零开始的索引。</span></span><br><span class="line"> <span class="comment">// 'input' 属性是被解析的原始字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[A-E]/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches_array = str.match(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches_array);</span><br><span class="line"><span class="comment">// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><ul><li><code>replace</code><br>replace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串</li></ul><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:left">代表的值</th></tr></thead><tbody><tr><td style="text-align:center">$$</td><td style="text-align:left">插入一个 “$”。</td></tr><tr><td style="text-align:center">$&amp;</td><td style="text-align:left">插入匹配的子串。</td></tr><tr><td style="text-align:center">$`</td><td style="text-align:left">插入当前匹配的子串左边的内容。</td></tr><tr><td style="text-align:center">$’</td><td style="text-align:left">插入当前匹配的子串右边的内容。</td></tr><tr><td style="text-align:center">$n</td><td style="text-align:left">假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"John Smith"</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(re, <span class="string">"$2, $1"</span>);</span><br><span class="line"><span class="comment">// Smith, John</span></span><br><span class="line"><span class="built_in">console</span>.log(newstr);</span><br></pre></td></tr></table></figure><p>如果是函数的话，函数入参如下，返回替换成的文本</p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的<code>$&amp;</code>。）</td></tr><tr><td>p1,p2,…</td><td>假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的<code>$1</code>，<code>$2</code>等。）</td></tr><tr><td>offset</td><td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span></span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">' - '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newString = <span class="string">'abc12345#$*%'</span>.replace(<span class="regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer);</span><br><span class="line"><span class="comment">// newString   abc - 12345 - #$*%</span></span><br></pre></td></tr></table></figure><ol><li><code>split</code><br>接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">"Hello 1 word. Sentence number 2."</span>;</span><br><span class="line"><span class="keyword">var</span> splits = myString.split(<span class="regexp">/\d/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(splits);</span><br><span class="line"><span class="comment">// [ "Hello ", " word. Sentence number ", "." ]</span></span><br><span class="line"></span><br><span class="line">splits = myString.split(<span class="regexp">/(\d)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splits);</span><br><span class="line"><span class="comment">// [ "Hello ", "1", " word. Sentence number ", "2", "." ]</span></span><br></pre></td></tr></table></figure><h4 id="正则对象的方法"><a href="#正则对象的方法" class="headerlink" title="正则对象的方法"></a>正则对象的方法</h4><ol><li><code>test</code><br>接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false</li><li><code>exec</code><br>同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 <code>null</code>。匹配时，返回值跟 <code>match</code> 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 <code>index</code> 和 <code>input</code>同时它会在正则实例的 <code>lastIndex</code> 属性指定的字符处开始检索字符串 string。当 <code>exec()</code> 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 <code>lastIndex</code> 属性设置为匹配文本的最后一个字符的下一个位置。有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 <code>exec()</code> 方法来遍历字符串中的所有匹配文本。当 <code>exec()</code> 再也找不到匹配的文本时，它将返回 <code>null</code>，并把 <code>lastIndex</code> 属性重置为 0。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</span><br><span class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</span><br><span class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</span><br><span class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</span><br><span class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</span><br><span class="line"><span class="comment">// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]</span></span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="comment">// =&gt; ["06", "06", index: 5, input: "2017.06.27"]</span></span><br><span class="line"><span class="comment">// =&gt; 7</span></span><br><span class="line"><span class="comment">// =&gt; ["27", "27", index: 8, input: "2017.06.27"]</span></span><br><span class="line"><span class="comment">// =&gt; 10</span></span><br><span class="line"><span class="comment">// =&gt; null</span></span><br><span class="line"><span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><pre><code>其中正则实例lastIndex属性，表示下一次匹配开始的位置。</code></pre><p>比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。</p><p>从上述代码看出，在使用exec时，经常需要配合使用while循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"><span class="keyword">while</span> ( result = regex2.exec(string) ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( result, regex2.lastIndex );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"] 4</span></span><br><span class="line"><span class="comment">// =&gt; ["06", "06", index: 5, input: "2017.06.27"] 7</span></span><br><span class="line"><span class="comment">// =&gt; ["27", "27", index: 8, input: "2017.06.27"] 10</span></span><br></pre></td></tr></table></figure><h4 id="正则的匹配"><a href="#正则的匹配" class="headerlink" title="正则的匹配"></a>正则的匹配</h4><h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><p>精确匹配就不说了，比如<code>/hello/</code>，也只能匹配字符串中的<code>&quot;hello&quot;</code>这个子串。<br>正则表达式之所以强大，是因为其能实现模糊匹配。</p><h5 id="匹配多种数量"><a href="#匹配多种数量" class="headerlink" title="匹配多种数量"></a>匹配多种数量</h5><p>用<code>{m,n}</code>来匹配多种数量，其他几种形式<code>(+*?)</code>都可以等价成这种。比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,5&#125;c/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc abbbbbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["abbc", "abbbc", "abbbbc", "abbbbbc"]</span></span><br></pre></td></tr></table></figure><h5 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h5><p>默认贪婪</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["123", "1234", "12345", "12345"]</span></span><br></pre></td></tr></table></figure><p>两次后面加一个 ？ 就可以表示非贪婪，非贪婪时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;?/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["12", "12", "34", "12", "34", "12", "34", "56"]</span></span><br></pre></td></tr></table></figure><h5 id="匹配多种情况"><a href="#匹配多种情况" class="headerlink" title="匹配多种情况"></a>匹配多种情况</h5><p>用字符组<code>[]</code>来匹配多种情况，其他几种形式<code>(\d\D\s\S\w\W)</code>都可以等价成这种。比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/a[123]b/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"a0b a1b a2b a3b a4b"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["a1b", "a2b", "a3b"]</span></span><br></pre></td></tr></table></figure></p><p>如果字符组里面字符特别多的话可以用<code>-</code>来表示范围，比如<code>[123456abcdefGHIJKLM]</code>，可以写成<code>[1-6a-fG-M]</code>，用[<code>^0-9]</code>表示非除了数字以外的字符<br>多种情况还可以是多种分支，用管道符来连接<code>|</code>，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); <span class="comment">// ["good"]</span></span><br></pre></td></tr></table></figure><p>这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。</p><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>掌握这两种方式就可以解决比较简单的正则问题了。</p><ol><li>最多保留2位小数的数字<br><code>/^([1-9]\d*|0)(\.\d{1,2})?$/</code></li><li>电话号码<br><code>/(\+86)?1\d{10}/</code></li><li>身份证<br><code>/^(\d{15}|\d{17}([xX]|\d))$/</code></li></ol><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="什么是位置"><a href="#什么是位置" class="headerlink" title="什么是位置"></a>什么是位置</h5><p>位置是相邻字符之间的，比如，有一个字符串 <code>hello</code> ，这个字符串一共有6个位置 <code>*h*e*l*l*o*</code> ， <code>*</code>代表位置</p><p><img src="/2018/04/01/JSRegExp/regwz" alt="" title="位置"></p><p>上面说到了 6 种位置元字符</p><ol><li><code>^</code>，<code>$</code> 匹配字符的开头和结尾，比如<code>/^hello$/</code> 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 <code>h</code> 然后是 <code>e</code>,<code>l</code>,<code>l</code>,<code>o</code> 最后是字符串结尾的位置位置还可以被替换成字符串，比如<code>&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;)</code> 结果是 <code>#hello#</code></li><li><code>/b</code>，<code>/B</code> 匹配单词边界和非单词边界，单词边界具体指 <code>\w([a-zA-Z0-9_])</code> 和 <code>\W</code> 之间的位置，包括 <code>\w</code> 和 <code>^</code> 以及 <code>$</code> 之间的位置，比如<code>&#39;hello word [js]_reg.exp-01&#39;.replace(/\b/g, &#39;#&#39;)</code> 结果是<code>#hello# #word# [#js#]#_reg#.#exp#-#01#</code></li><li><code>(?=p)</code>，<code>(?!p)</code> 匹配 <code>p</code> 前面的位置和不是 <code>p</code> 前面位置，比如<code>&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;)</code> 结果是 <code>he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;)</code> 结果是 <code>#h#ell#o#</code></li></ol><h5 id="位置的特性"><a href="#位置的特性" class="headerlink" title="位置的特性"></a>位置的特性</h5><p>字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 <code>&#39;&#39;</code>，比如<code>hello</code> 可以是一般的 <code>&#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;</code>，也可以是 <code>&#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;</code>，所以<code>/^h\Be\Bl\Bl\Bo$/.test(&#39;hello&#39;)</code> 结果是 <code>true</code>，<code>/^^^h\B\B\Be\Bl\Bl\Bo$$$/.test(&#39;hello&#39;)</code> 结果也是 <code>true</code></p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>-. 千分位，将 <code>123123123</code> 转换成 <code>123,123,123</code>数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 <code>&#39;,&#39;</code> 就好了，写成正则就是<code>123123213.replace(/(?=(\d{3})+$)/g, &#39;,&#39;)</code> 但是这样的话会在最前面也加一个 <code>&#39;,&#39;</code> 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 <code>/(?!^)(?=(\d{3})+$)/g</code> 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 <code>/\d(?=(\d{3})+$)/g</code>，但是这个正则匹配的结果是 <code>12,12,123</code>，发现这个正则匹配的不是位置而是字符，将数字换成了 <code>&#39;,&#39;</code>  可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>分组主要是括号的使用</p><h5 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h5><p>在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love JavaScript</span><br><span class="line">I love Regular Expression</span><br></pre></td></tr></table></figure><p>可以用正则<code>/^I love (JavaScript|Regular Expression)$/</code> 而不是 <code>/^I love JavaScript|Regular Expression$/</code>表示一个整体还比如 <code>/(abc)+/</code> 一个或者多个 <code>abc</code> 字符串上面这些使用 <code>()</code> 包起来的地方就叫做分组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'I love JavaScript'</span>.match(<span class="regexp">/^I love (JavaScript|Regular Expression)$/</span>)</span><br><span class="line"><span class="comment">// ["I love JavaScript", "JavaScript", index: 0, input: "I love JavaScript"]</span></span><br></pre></td></tr></table></figure><p>输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容</p><h4 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h4><h5 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h5><p>比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则<code>/\d{4}-\d{2}-\d{2}/</code>，这个正则还可以改成分组形式的<code>/(\d{4})-(\d{2})-(\d{2})/</code>这样我们可以分别提取出一个日期的年月日，用 <code>String</code> 的 <code>match</code> 方法或者用正则的 <code>exec</code> 方法都可以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-08-09"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) ); </span><br><span class="line"><span class="comment">// =&gt; ["2017-08-09", "2017", "08", "09", index: 0, input: "2017-08-09"]</span></span><br></pre></td></tr></table></figure></p><p>也可以用正则对象构造函数的全局属性 $1 - $9 来获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-08-09"</span>;</span><br><span class="line"></span><br><span class="line">regex.test(string); <span class="comment">// 正则操作即可，例如</span></span><br><span class="line"><span class="comment">//regex.exec(string);</span></span><br><span class="line"><span class="comment">//string.match(regex);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// "2017"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// "08"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// "09"</span></span><br></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。<br>String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-08-09"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">"$2/$3/$1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "08/09/2017"</span></span><br><span class="line">等价</span><br><span class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "08/09/2017"</span></span><br><span class="line">等价</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-08-09"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params">match, year, month, day</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "08/09/2017"</span></span><br></pre></td></tr></table></figure><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-09</span></span><br><span class="line"></span><br><span class="line"><span class="number">2017</span>/<span class="number">08</span>/<span class="number">09</span></span><br><span class="line"></span><br><span class="line"><span class="number">2017.08</span><span class="number">.09</span></span><br></pre></td></tr></table></figure></p><p>要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下<code>/(\d{4})[-/.](\d{2})[-/.](\d{2})/</code>，把 <code>-</code> 改成 <code>[-/.]</code> 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 <code>2017-08.09</code> 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 <code>/(\d{4})([-/.])(\d{2})\2(\d{2})/</code></p><p><strong><em>那么出现括号嵌套怎么办，比如</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>嵌套的括号以左括号为准</p><h5 id="引用了不存在的分组呢"><a href="#引用了不存在的分组呢" class="headerlink" title="引用了不存在的分组呢"></a>引用了不存在的分组呢</h5><p>如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如<code>\1</code>就匹配<code>\1</code></p><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><p>我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组</p><h6 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h6><ol><li><p>驼峰改短横</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dash</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取链接的 search 值链接：<code>https://www.baidu.com?name=jawil&amp;age=23</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParamName</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> match = <span class="built_in">RegExp</span>(<span class="string">`[?&amp;]<span class="subst">$&#123;attr&#125;</span>=([^&amp;]*)`</span>) <span class="comment">//分组运算符是为了把结果存到exec函数返回的结果里</span></span><br><span class="line"> .exec(<span class="built_in">window</span>.location.search)</span><br><span class="line"><span class="comment">//["?name=jawil", "jawil", index: 0, input: "?name=jawil&amp;age=23"]</span></span><br><span class="line"><span class="keyword">return</span> match &amp;&amp; <span class="built_in">decodeURIComponent</span>(match[<span class="number">1</span>].replace(<span class="regexp">/\+/g</span>, <span class="string">' '</span>)) <span class="comment">// url中+号表示空格,要替换掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getParamName(<span class="string">'name'</span>))  <span class="comment">// "jawil"</span></span><br></pre></td></tr></table></figure></li><li><p>去掉字符串前后的空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个数是否是质数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="regexp">/^1?$|^(11+?)\1+$/</span>.test(<span class="built_in">Array</span>(num+<span class="number">1</span>).join(<span class="string">'1'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1  然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><h5 id="正则是怎么匹配的"><a href="#正则是怎么匹配的" class="headerlink" title="正则是怎么匹配的"></a>正则是怎么匹配的</h5><p>有这么一个字符串 <code>&#39;abbbc&#39;</code> 和这么一个正则 <code>/ab{1,3}bbc//ab{1,3}bbc/.test(&#39;abbbc&#39;)</code> 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢<br><img src="/2018/04/01/JSRegExp/huisu" alt="回溯" title="回溯"></p><h5 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h5><p>例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”<br>贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如<code>/^(test|te)sts$/.test(&#39;tests&#39;)</code>前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 <code>s</code> 的时候还是成功的，匹配到 <code>st</code> 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。</p><h5 id="读正则"><a href="#读正则" class="headerlink" title="读正则"></a>读正则</h5><p>读懂其他人写的正则也是一个很重要的方面。</p><h5 id="结构和操作符"><a href="#结构和操作符" class="headerlink" title="结构和操作符"></a>结构和操作符</h5><p>结构：<code>字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用</code>。</p><p>操作符：</p><ol><li>转义符 <code>\</code></li><li>括号和方括号 <code>(...)</code>、<code>(?:...)</code>、<code>(?=...)</code>、<code>(?!...)</code>、<code>[...]</code></li><li>量词限定符 <code>{m}</code>、<code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>、<code>+</code></li><li>位置和序列 <code>^</code> 、<code>$</code>、 <code>\</code>元字符、 一般字符</li><li>管道符（竖杠） <code>|</code></li></ol><p>操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如<br><code>/ab?(c|de*)+|fg/</code></p><ol><li>因为括号是一个整体，所以<code>/ab?()+|fg/</code>,括号里面具体是什么可以放到后面再分析</li><li>根据量词和管道符的优先级，所以<code>a</code>, <code>b?</code>, ()+和管道符后面的<code>f</code>,<code>g</code></li><li>同理分析括号里面的<code>c|de* =&gt; c</code>和<code>d</code>, <code>e*</code></li><li>综上，这个正则描述的是</li></ol><p><img src="/2018/04/01/JSRegExp/reglc" alt=""></p><p>以这种模式来分析，再复杂的正则都可以看懂。有一个可视化的<a href="https://jex.im/regulex/" target="_blank" rel="noopener">正则分析网站</a></p><p><em>转载自<a href="https://juejin.im/post/59b5e50f51882519777c4815" target="_blank" rel="noopener">网易考拉前端团队</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。&lt;br&gt;核心是 匹配，匹配位置或者匹配字符&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="RegExp" scheme="http://www.goyth.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之堆排序</title>
    <link href="http://www.goyth.com/2018/02/09/heapSort/"/>
    <id>http://www.goyth.com/2018/02/09/heapSort/</id>
    <published>2018-02-09T14:06:52.000Z</published>
    <updated>2018-07-04T06:01:35.051Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/09/heapSort/sort.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="/2018/02/09/heapSort/heapSort1.gif" alt=""></p><h3 id="不得不说说二叉树"><a href="#不得不说说二叉树" class="headerlink" title="不得不说说二叉树"></a>不得不说说二叉树</h3><p>要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。</p><a id="more"></a><p>树和二叉树的三个主要差别：</p><ul><li>树的结点个数至少为 1，而二叉树的结点个数可以为 0</li><li>树中结点的最大度数没有限制，而二叉树结点的最大度数为 2</li><li>树的结点无左、右之分，而二叉树的结点有左、右之分</li></ul><p>二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）</p><p>满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树</p><p><img src="/2018/02/09/heapSort/heapSort2.png" alt="深度为 3 的满二叉树 full binary tree"></p><p>完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树</p><p><img src="/2018/02/09/heapSort/heapSort3.png" alt="深度为 3 的完全二叉树 complete binary tree"></p><h3 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h3><p>堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系</p><p><img src="/2018/02/09/heapSort/heapSort4.png" alt="堆和数组的相互关系"></p><p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = floor(i/2)，i 的父节点下标</li><li>Left(i) = 2i，i 的左子节点下标</li><li>Right(i) = 2i + 1，i 的右子节点下标</li></ul><p><img src="/2018/02/09/heapSort/heapSort5.png" alt="堆和数组"></p><p>二叉堆一般分为两种：最大堆和最小堆。</p><p>最大堆：</p><ul><li>最大堆中的最大元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</li></ul><p><img src="/2018/02/09/heapSort/heapSort6.png" alt="最大堆"></p><p>最小堆：</p><ul><li>最小堆中的最小元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</li></ul><p><img src="/2018/02/09/heapSort/heapSort7.png" alt="最小堆"></p><h3 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h3><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变</p><p><img src="/2018/02/09/heapSort/heapSort8.png" alt="Zero-Based"></p><p>相应的，几个计算公式也要作出相应调整：</p><ul><li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li><li>Left(i) = 2i + 1，i 的左子节点下标</li><li>Right(i) = 2(i + 1)，i 的右子节点下标</li></ul><p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序，作用过程如图所示：</p><p><img src="/2018/02/09/heapSort/heapSort9.png" alt="Max-Heapify"></p><p>由于一次调整后，堆仍然违反堆性质，所以需要递归的测试，使得整个堆都满足堆性质，用 JavaScript 可以表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 index 开始检查并保持最大堆性质</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @index 检查的起始下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @heapSize 堆大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iMax = index,</span><br><span class="line">      iLeft = <span class="number">2</span> * index + <span class="number">1</span>,</span><br><span class="line">      iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</span><br><span class="line">    iMax = iLeft;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">    iMax = iRight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">    swap(array, iMax, index);</span><br><span class="line">    maxHeapify(array, iMax, heapSize); <span class="comment">// 递归调整</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来说，递归主要用在分治法中，而这里并不需要分治。而且递归调用需要压栈/清栈，和迭代相比，性能上有略微的劣势。当然，按照20/80法则，这是可以忽略的。但是如果你觉得用递归会让自己心里过不去的话，也可以用迭代，比如下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 index 开始检查并保持最大堆性质</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @array</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @index 检查的起始下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @heapSize 堆大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iMax, iLeft, iRight;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    iMax = index;</span><br><span class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</span><br><span class="line">      iMax = iLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">      iMax = iRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">      swap(array, iMax, index);</span><br><span class="line">      index = iMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建最大堆（Build-Max-Heap）的作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，Build-Max-Heap 将自下而上的调用 Max-Heapify 来改造数组，建立最大堆。因为 Max-Heapify 能够保证下标 i 的结点之后结点都满足最大堆的性质，所以自下而上的调用 Max-Heapify 能够在改造过程中保持这一性质。如果最大堆的数量元素是 n，那么 Build-Max-Heap 从 Parent(n) 开始，往上依次调用 Max-Heapify。流程如下：</p><p><img src="/2018/02/09/heapSort/heapSort10.png" alt="Build-Max-Heap"></p><p>用 JavaScript 描述如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i,</span><br><span class="line">      iParent = <span class="built_in">Math</span>.floor((heapSize - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    maxHeapify(array, i, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先调用Build-Max-Heap将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用Max-Heapify保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。整个流程如下：</p><p><img src="/2018/02/09/heapSort/heapSort11.png" alt="Heap-Sort"></p><p>用 JavaScript 描述如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array, heapSize</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(array, heapSize);</span><br><span class="line">  <span class="keyword">for</span> (int i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(array, <span class="number">0</span>, i);</span><br><span class="line">    maxHeapify(array, <span class="number">0</span>, i);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-语言实现"><a href="#JavaScript-语言实现" class="headerlink" title="JavaScript 语言实现"></a>JavaScript 语言实现</h3><p>最后，把上面的整理为完整的 javascript 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 交换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 大顶堆调整</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, index, maxSize</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> leftChildIndex, rightChildIndex, maxValueIndex;</span><br><span class="line">      maxValueIndex = index;</span><br><span class="line">      leftChildIndex = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">      rightChildIndex = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(leftChildIndex &lt; maxSize &amp;&amp; arr[leftChildIndex] &gt; arr[index])&#123;</span><br><span class="line">        maxValueIndex = leftChildIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(rightChildIndex &lt; maxSize &amp;&amp; arr[maxValueIndex] &lt; arr[rightChildIndex])&#123;</span><br><span class="line">        maxValueIndex = rightChildIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(maxValueIndex != index)&#123;</span><br><span class="line">        swap(arr, index, maxValueIndex);</span><br><span class="line">        maxHeapify(arr, maxValueIndex, maxSize);</span><br><span class="line">        <span class="comment">// index = maxValueIndex;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 大顶堆构建</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> parentIndex = <span class="built_in">Math</span>.floor((len - <span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(; parentIndex &gt;= <span class="number">0</span>; parentIndex--)&#123;</span><br><span class="line">      maxHeapify(arr, parentIndex, len)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 堆排序</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">      swap(arr, <span class="number">0</span>, i);    <span class="comment">// 将堆顶元素与末尾元素交换</span></span><br><span class="line">      maxHeapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sort(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/09/heapSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/09/heapSort/heapSort1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;不得不说说二叉树&quot;&gt;&lt;a href=&quot;#不得不说说二叉树&quot; class=&quot;headerlink&quot; title=&quot;不得不说说二叉树&quot;&gt;&lt;/a&gt;不得不说说二叉树&lt;/h3&gt;&lt;p&gt;要了解堆首先得了解一下二叉树，在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。&lt;/p&gt;
&lt;p&gt;二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之快速排序</title>
    <link href="http://www.goyth.com/2018/02/09/quickSort/"/>
    <id>http://www.goyth.com/2018/02/09/quickSort/</id>
    <published>2018-02-09T10:47:16.000Z</published>
    <updated>2018-07-04T05:59:04.238Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/09/quickSort/sort.png" alt=""></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/2018/02/09/quickSort/quicksort.gif" alt=""></p><p>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p>利用分治法可将快速排序的分为三步：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><a id="more"></a><h3 id="JavaScript-递归版"><a href="#JavaScript-递归版" class="headerlink" title="JavaScript 递归版"></a>JavaScript 递归版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">  qSort(arr, <span class="number">0</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr, low, high</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> mid = partition(arr, low, high);</span><br><span class="line">  qSort(arr, low, mid<span class="number">-1</span>);</span><br><span class="line">  qSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pivot = arr[low];</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot)&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = arr[high];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= pivot)&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[high] = arr[low];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[low] = pivot;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-迭代版"><a href="#JavaScript-迭代版" class="headerlink" title="JavaScript 迭代版"></a>JavaScript 迭代版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">  qSort(arr, <span class="number">0</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr, low, high</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stack = [];</span><br><span class="line">  <span class="keyword">var</span> top = <span class="number">-1</span>;</span><br><span class="line">  stack[++top] = low;</span><br><span class="line">  stack[++top] = high;</span><br><span class="line">  <span class="keyword">while</span>(top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    high = stack[top--];</span><br><span class="line">    low = stack[top--];</span><br><span class="line">    <span class="keyword">var</span> mid = partition(arr, low, high);</span><br><span class="line">    <span class="keyword">if</span>(low &lt; mid - <span class="number">1</span>)&#123;</span><br><span class="line">      stack[++top] = low;</span><br><span class="line">      stack[++top] = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mid + <span class="number">1</span> &lt; high)&#123;</span><br><span class="line">      stack[++top] = mid + <span class="number">1</span>;</span><br><span class="line">      stack[++top] = high;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pivot = arr[low];</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot)&#123;</span><br><span class="line">      high--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = arr[high];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= pivot)&#123;</span><br><span class="line">      low++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[high] = arr[low];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[low] = pivot;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/09/quickSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/09/quickSort/quicksort.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。&lt;/p&gt;
&lt;p&gt;分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。&lt;/p&gt;
&lt;p&gt;利用分治法可将快速排序的分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在数据集之中，选择一个元素作为”基准”（pivot）。&lt;/li&gt;
&lt;li&gt;所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。&lt;/li&gt;
&lt;li&gt;对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之归并排序</title>
    <link href="http://www.goyth.com/2018/02/09/mergeSort/"/>
    <id>http://www.goyth.com/2018/02/09/mergeSort/</id>
    <published>2018-02-09T08:05:22.000Z</published>
    <updated>2018-07-04T06:01:28.840Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/09/mergeSort/sort.png" alt=""></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="/2018/02/09/mergeSort/mergesort.gif" alt=""><br>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并排序可以使用递归和迭代两种方式进行实现</p><a id="more"></a><h3 id="递归法（Top-down）"><a href="#递归法（Top-down）" class="headerlink" title="递归法（Top-down）"></a>递归法（Top-down）</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h3 id="迭代法（Bottom-up）"><a href="#迭代法（Bottom-up）" class="headerlink" title="迭代法（Bottom-up）"></a>迭代法（Bottom-up）</h3><p>原理如下（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行归并操作，形成 ceil(n/2)个序列，排序后每个序列包含两/一个元素</li><li>若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4)个序列，每个序列包含四/三个元素</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1</li></ol><h3 id="JavaScrpt-递归版"><a href="#JavaScrpt-递归版" class="headerlink" title="JavaScrpt 递归版"></a>JavaScrpt 递归版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> left = arr.slice(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">var</span> right = arr.slice(mid);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">while</span>(left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>])&#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScrpt-迭代版"><a href="#JavaScrpt-迭代版" class="headerlink" title="JavaScrpt 迭代版"></a>JavaScrpt 迭代版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> block=<span class="number">1</span>; block &lt; len; block = <span class="number">2</span> * block)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> start = <span class="number">0</span>; start &lt; len; start = start + <span class="number">2</span> * block)&#123;</span><br><span class="line">      <span class="keyword">var</span> low = start;</span><br><span class="line">      <span class="keyword">var</span> mid = (start + block) &gt; len ? len : (start + block)</span><br><span class="line">      <span class="keyword">var</span> high = (start + <span class="number">2</span> * block) &gt; len ? len : (start + <span class="number">2</span> * block)</span><br><span class="line">      <span class="keyword">var</span> start1 = low, end1 = mid;</span><br><span class="line">      <span class="keyword">var</span> start2 = mid, end2 = high;</span><br><span class="line">      <span class="keyword">while</span>(start1 &lt; end1 &amp;&amp; start2 &lt; end2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[start1] &lt; arr[start2])&#123;</span><br><span class="line">          result[low++] = arr[start1++]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          result[low++] = arr[start2++]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(start1 &lt; end1)&#123;</span><br><span class="line">        result[low++] = arr[start1++]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(start2 &lt; end2)&#123;</span><br><span class="line">        result[low++] = arr[start2++]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = result;</span><br><span class="line">    result = [];    <span class="comment">// 这里一定要将 result 设置为一个新的空数组，否则下一次循环时，修改result的同时也会修改arr</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/09/mergeSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/09/mergeSort/mergesort.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;p&gt;归并排序可以使用递归和迭代两种方式进行实现&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之希尔排序</title>
    <link href="http://www.goyth.com/2018/02/08/shellSort/"/>
    <id>http://www.goyth.com/2018/02/08/shellSort/</id>
    <published>2018-02-08T08:19:32.000Z</published>
    <updated>2018-07-04T06:01:06.278Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/08/shellSort/sort.png" alt=""></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="/2018/02/08/shellSort/shellSort.jpeg" alt=""></p><p>希尔排序(Shell’s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</p><a id="more"></a><h2 id="插入排序算法回顾"><a href="#插入排序算法回顾" class="headerlink" title="插入排序算法回顾"></a>插入排序算法回顾</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i<span class="number">-1</span>] &gt; arr[i])&#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序算法实现"><a href="#希尔排序算法实现" class="headerlink" title="希尔排序算法实现"></a>希尔排序算法实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> gap = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=gap; i&lt;len; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i-gap] &gt; arr[i])&#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)&#123;</span><br><span class="line">          arr[j+gap] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+gap] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arrSorted = shellSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrSorted);</span><br><span class="line"><span class="comment">// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/08/shellSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/08/shellSort/shellSort.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;希尔排序(Shell’s Sort)也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。&lt;br&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；&lt;/li&gt;
&lt;li&gt;但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之直接插入排序</title>
    <link href="http://www.goyth.com/2018/02/08/straightInsertionSort/"/>
    <id>http://www.goyth.com/2018/02/08/straightInsertionSort/</id>
    <published>2018-02-08T07:02:30.000Z</published>
    <updated>2018-05-28T14:16:53.742Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序</p><p>排序算法总览：</p><p><img src="/2018/02/08/straightInsertionSort/sort.png" alt=""></p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><img src="/2018/02/08/straightInsertionSort/insertSort.png" alt=""></p><p>直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p><a id="more"></a><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">straightInsertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arrSorted = straightInsertSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrSorted);</span><br><span class="line"><span class="comment">// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍直接插入排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/08/straightInsertionSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/08/straightInsertionSort/insertSort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之选择排序</title>
    <link href="http://www.goyth.com/2018/02/08/selectionSort/"/>
    <id>http://www.goyth.com/2018/02/08/selectionSort/</id>
    <published>2018-02-08T05:03:59.000Z</published>
    <updated>2018-07-04T06:01:16.748Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/08/selectionSort/sort.png" alt=""></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="/2018/02/08/selectionSort/selectSort.png" alt=""></p><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p><a id="more"></a><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length,</span><br><span class="line">      minIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])&#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arrSorted = selectionSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrSorted);</span><br><span class="line"><span class="comment">// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/08/selectionSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/08/selectionSort/selectSort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之冒泡排序</title>
    <link href="http://www.goyth.com/2018/02/08/bubbleSort/"/>
    <id>http://www.goyth.com/2018/02/08/bubbleSort/</id>
    <published>2018-02-08T02:40:24.000Z</published>
    <updated>2018-07-04T06:02:07.466Z</updated>
    
    <content type="html"><![CDATA[<p>常见的内部排序算法有：<a href="http://www.goyth.com/2018/02/08/bubbleSort/">冒泡排序</a>、<a href="http://www.goyth.com/2018/02/08/selectionSort/">选择排序</a>、<a href="http://www.goyth.com/2018/02/08/straightInsertionSort/">插入排序</a>、<a href="http://www.goyth.com/2018/02/08/shellSort/">希尔排序</a>、<a href="http://www.goyth.com/2018/02/09/mergeSort/">归并排序</a>、<a href="http://www.goyth.com/2018/02/09/quickSort/">快速排序</a>、<a href="http://www.goyth.com/2018/02/09/heapSort/">堆排序</a>等。这里主要介绍快速排序</p><p>排序算法总览：</p><p><img src="/2018/02/08/bubbleSort/sort.png" alt=""></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/2018/02/08/bubbleSort/bubbleSort.png" alt=""></p><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。</p><a id="more"></a><h2 id="算法原理编辑"><a href="#算法原理编辑" class="headerlink" title="算法原理编辑"></a>算法原理编辑</h2><p>冒泡排序算法的运作如下：（从前往后）<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]]    <span class="comment">// 利用es6解构语法进行swap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arrSorted = bubbleSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrSorted);</span><br><span class="line"><span class="comment">// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h2 id="冒泡算法优化"><a href="#冒泡算法优化" class="headerlink" title="冒泡算法优化"></a>冒泡算法优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length<span class="number">-1</span>; flag &amp;&amp; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;    <span class="comment">//只要flag在下一次外循环条件检测的时候值为false，就说明已经排好序，不用继续循环 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;    <span class="comment">//如果有交换，就将标记变量赋true</span></span><br><span class="line">        [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]]    <span class="comment">// 利用es6解构语法进行swap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arrSorted = bubbleSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrSorted);</span><br><span class="line"><span class="comment">// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的内部排序算法有：&lt;a href=&quot;http://www.goyth.com/2018/02/08/bubbleSort/&quot;&gt;冒泡排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/selectionSort/&quot;&gt;选择排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/straightInsertionSort/&quot;&gt;插入排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/08/shellSort/&quot;&gt;希尔排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/mergeSort/&quot;&gt;归并排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/quickSort/&quot;&gt;快速排序&lt;/a&gt;、&lt;a href=&quot;http://www.goyth.com/2018/02/09/heapSort/&quot;&gt;堆排序&lt;/a&gt;等。这里主要介绍快速排序&lt;/p&gt;
&lt;p&gt;排序算法总览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/08/bubbleSort/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/08/bubbleSort/bubbleSort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。&lt;br&gt;它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。&lt;br&gt;这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://www.goyth.com/tags/Sort/"/>
    
  </entry>
  
</feed>
