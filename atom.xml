<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GOYTH</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.goyth.com/"/>
  <updated>2020-02-26T07:37:18.371Z</updated>
  <id>http://www.goyth.com/</id>
  
  <author>
    <name>Luke Hu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 30. 串联所有单词的子串</title>
    <link href="http://www.goyth.com/2020/02/26/SubstringWithConcatenationOfAllWords/"/>
    <id>http://www.goyth.com/2020/02/26/SubstringWithConcatenationOfAllWords/</id>
    <published>2020-02-26T03:57:49.000Z</published>
    <updated>2020-02-26T07:37:18.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></h2><p>难度: <strong>困难</strong></p><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong>中单词串联的顺序。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：</span><br><span class="line">从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Language: <strong>JavaScript</strong></p><h4 id="解法一：暴力求解"><a href="#解法一：暴力求解" class="headerlink" title="解法一：暴力求解"></a>解法一：暴力求解</h4><p><strong>解题思路：</strong></p><ol><li>由于子串不需要考虑 <code>words</code> 中单词出现的顺序，并且<code>words</code>中可能会出现重复单词，所以不能用 <code>set</code> 来存储<code>words</code>，我们可以用<code>map</code>来存储<code>words</code>，把<code>words</code>中的单词作为<code>key</code>，单词出现的次数作为<code>value</code></li><li>循环字符串<code>s</code>，然后每次从字符串<code>s</code>中截取一段长度为 <code>words</code> 单词总长的字符串，然后按照单个<code>words</code>单词的长度，对其进行拆分成单词</li><li>使用拆分后的单词去<code>map</code>中查询，如果存在，则将其 <code>value - 1</code>，否则表明当前字符串不符合要求，直接<code>break</code>跳出当前循环</li><li>内层循环结束后，如果<code>map</code>所有的 <code>value</code> 都为<code>0</code>，则表明当前子字符串符合要求，将其起始索引放入结果集中</li><li>最后返回结果集</li></ol><p><strong>代码：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">​<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; words</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s, words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!words || !words.length) <span class="keyword">return</span>[];</span><br><span class="line">    <span class="keyword">let</span> wordLen = words[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> allWordsLen = wordLen * words.length;</span><br><span class="line">    <span class="keyword">let</span> ans = [], wordMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> words) &#123;</span><br><span class="line">        wordMap[w] ? wordMap[w]++ :wordMap[w] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length - allWordsLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> wm = <span class="built_in">Object</span>.assign(&#123;&#125;, wordMap);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; i + allWordsLen - wordLen + <span class="number">1</span>; j += wordLen) &#123;</span><br><span class="line">            <span class="keyword">let</span> w = s.slice(j, j + wordLen);</span><br><span class="line">            <span class="keyword">if</span> (wm[w]) &#123;</span><br><span class="line">                wm[w]--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.values(wm).every(<span class="function"><span class="params">n</span> =&gt;</span> n === <span class="number">0</span>)) ans.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>时间复杂度</strong>：<code>O(KN)</code><br><code>N</code> 为 <code>s</code> 的长度，<code>K</code> 为 <code>words</code> 一个单词的长度</p><p><strong>空间复杂度</strong>：<code>O(N + M)</code><br><code>N</code> 为 <code>s</code> 的长度，<code>M</code> 为 <code>words</code> 的长度</p><h4 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h4><p><strong>解题思路：</strong></p><ol><li>在暴力求解的基础上进一步优化，我使用两个 <code>map</code>，<code>windows</code> 和 <code>needs</code>，<code>windows</code>存储<code>s</code>的子串，<code>needs</code>存储<code>words</code>，并且使用两个指针 <code>l</code> 和 <code>r</code>,表示一个窗口的左右两边的索引</li><li>外层循环索引 <code>i</code> 从 <code>0</code> 开始，并且 <code>i &lt; oneWordLen</code> 只用循环一个单词的长度</li><li>内层循环从 <code>i</code> 开始，<code>l = r = i</code>，依次进行截取 <code>let w = s.slice(i, i + oneWordLen)</code>，判断截取的单词 <code>w</code> 是否存在于存储 <code>needs</code> 中，如果不存在，则直接<code>continue</code>跳过当前循环</li><li>如果存在则将其添加到 <code>windows</code> 中，如果 <code>windows[w] === needs[w]</code>则将<code>count++</code>，表示一个单词已经准备就绪</li><li>如果 <code>count === Object.key(needs).length</code>，则表示所有的单词都已经准备就绪，由于有可能会出现多个重复的符合要求的单词，所以此时还需要判断 <code>r - l === words所有单词的长度和</code></li><li>如果条件成立则表示当前子字符串符合要求，将子字符串的起始索引<code>l</code>，放入结果集中 <code>ans.push(l)</code></li><li>从窗口的左边截取子字符串 <code>let w2 = s.slice(l, l + oneWordLen)</code>，如果 <code>w2</code> 存在于 <code>needs</code> 中，则<code>windows[w2]--</code>，并且如果 <code>windows[w2] &lt; needs[w2]</code>，则<code>count--</code></li><li>最后返回结果集<code>ans</code></li></ol><p><strong>代码：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; words</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s, words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || !words || !words.length) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> windows = &#123;&#125;, needs = &#123;&#125;, oneWordLen = words[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> words) &#123;</span><br><span class="line">        needs[w] ? needs[w]++ : needs[w] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, count = <span class="number">0</span>, needsKeyLen = <span class="built_in">Object</span>.keys(needs).length, ans = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oneWordLen; i++) &#123;</span><br><span class="line">        windows = &#123;&#125;;</span><br><span class="line">        r = l = i;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= s.length - oneWordLen) &#123;</span><br><span class="line">            <span class="keyword">let</span> w1 = s.slice(r, r + oneWordLen);</span><br><span class="line">            r += oneWordLen;</span><br><span class="line">            <span class="keyword">if</span> (!needs[w1]) &#123;</span><br><span class="line">                windows = &#123;&#125;;</span><br><span class="line">                l = r;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            windows[w1] ? windows[w1]++ : windows[w1] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (windows[w1] === needs[w1]) count++;</span><br><span class="line">            <span class="keyword">while</span> (count === needsKeyLen) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l === oneWordLen * words.length) ans.push(l);</span><br><span class="line">                <span class="keyword">let</span> w2 = s.slice(l, l + oneWordLen);</span><br><span class="line">                l += oneWordLen;</span><br><span class="line">                <span class="keyword">if</span> (needs[w2]) &#123;</span><br><span class="line">                    windows[w2]--;</span><br><span class="line">                    <span class="keyword">if</span> (windows[w2] &lt; needs[w2]) count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>时间复杂度</strong>：<code>O(N)</code><br>外层循环时间复杂度为<code>O(K)</code>，<code>K</code> 为 <code>words</code> 一个单词的长度<br>内层循环时间复杂度为 <code>O(2 * N / K)</code>，即 <code>l</code>和<code>r</code>从字符串起始索引遍历到结束索引，每次递加<code>K</code><br>所以，时间复杂度为 <code>O(K * 2 * N / K) = O(2N) =&gt; O(N)</code></p><p><strong>空间复杂度</strong>：<code>O(N + M)</code><br><code>N</code> 为 <code>s</code> 的长度，<code>M</code> 为 <code>words</code> 的长度</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;30-串联所有单词的子串&quot;&gt;&lt;a href=&quot;#30-串联所有单词的子串&quot; class=&quot;headerlink&quot; title=&quot;30. 串联所有单词的子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;30. 串联所有单词的子串&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;难度: &lt;strong&gt;困难&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一些长度相同的单词 &lt;strong&gt;words&lt;/strong&gt;找出 &lt;strong&gt;s&lt;/strong&gt; 中恰好可以由 &lt;strong&gt;words&lt;/strong&gt; 中所有单词串联形成的子串的起始位置。&lt;/p&gt;
&lt;p&gt;注意子串要与 &lt;strong&gt;words&lt;/strong&gt; 中的单词完全匹配，中间不能有其他字符，但不需要考虑 &lt;strong&gt;words&lt;/strong&gt;中单词串联的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.goyth.com/categories/Algorithm/"/>
    
    
      <category term="字符串 LeetCode" scheme="http://www.goyth.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Express路由与中间件原理（中间件篇）</title>
    <link href="http://www.goyth.com/2019/07/20/expressMiddleware/"/>
    <id>http://www.goyth.com/2019/07/20/expressMiddleware/</id>
    <published>2019-07-20T10:31:14.000Z</published>
    <updated>2019-07-21T08:57:21.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><p><code>Express</code> 路由与中间件具体用法参考<a href="https://expressjs.com/zh-cn/4x/api.html" target="_blank" rel="noopener">官网 API</a></p><p><code>Express</code> 路由原理见 <a href="http://www.goyth.com/2019/07/20/expressRouter/">Express路由与中间件原理（路由篇）</a></p><p><code>Express</code> 中间件通常用来一些公用的逻辑，并可以将处理的结果挂载在 <code>req</code>、<code>res</code> 上，以供后面的中间件函数，或路由函数使用。因此通常情况下中间件函数会放在路由的前面</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// let express = require('./express')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>Express</code> 中，注册一个中间件与注册一个路由一样，也是放在 <code>app.routes</code> 中，只是中间件的 <code>method</code> 为 middle。</p><p>但是在中间件函数中，有可能要执行异步逻辑，中间件函数中是通过调用 <code>next</code> 回调函数，来执行下一个中间件函数或路由，因此我们不能再通过循环来遍历 <code>app.routes</code> ，而是应该通过回调函数来进行调用</p><h3 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">application</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">let</span> method = req.method.toLowerCase();</span><br><span class="line">    <span class="comment">// 获取请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      pathname</span><br><span class="line">    &#125; = url.parse(req.url)</span><br><span class="line">    <span class="comment">// 使用 next 回调函数来遍历 app.routes</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= app.routes.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.end(<span class="string">`cannot <span class="subst">$&#123;method&#125;</span>  <span class="subst">$&#123;pathname&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> layer = app.routes[index];</span><br><span class="line">      <span class="comment">// 中间件</span></span><br><span class="line">      <span class="keyword">if</span> (layer.method === <span class="string">'middle'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;</span><br><span class="line">          path,</span><br><span class="line">          callback</span><br><span class="line">        &#125; = layer;</span><br><span class="line">        <span class="keyword">if</span> (path === <span class="string">'/'</span> || pathname.startsWith(path + <span class="string">'/'</span>) || pathname === path) &#123;</span><br><span class="line">          callback(req, res, () =&gt; &#123;</span><br><span class="line">            next(index + <span class="number">1</span>)</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不匹配则取下一个中间件或路由</span></span><br><span class="line">          next(index + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//  路由</span></span><br><span class="line">        <span class="keyword">let</span> layerPath = layer.path</span><br><span class="line">        <span class="keyword">let</span> layerMethod = layer.method</span><br><span class="line">        <span class="keyword">if</span> (layerPath.params &amp;&amp; (layerMethod === method || <span class="string">"all"</span> === layerMethod) &amp;&amp; layerPath.test(pathname)) &#123;</span><br><span class="line">          <span class="comment">// 过滤掉第一项</span></span><br><span class="line">          <span class="keyword">let</span> [, ...args] = pathname.match(layer.path)</span><br><span class="line">          req.params = layerPath.params.reduce(<span class="function">(<span class="params">memo, current, index</span>) =&gt;</span> (memo[current] = args[index], memo), &#123;&#125;);</span><br><span class="line">          <span class="keyword">return</span> layer.callback(req, res);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((layerMethod === method || <span class="string">"all"</span> === layerMethod) &amp;&amp; (layerPath === pathname || (<span class="string">"*"</span> === layerPath))) &#123;</span><br><span class="line">          <span class="keyword">return</span> layer.callback(req, res)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不匹配则取下一个中间件或路由</span></span><br><span class="line">          next(index + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    res.end(<span class="string">`cannot <span class="subst">$&#123;method&#125;</span>  <span class="subst">$&#123;pathname&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存放中间件或路由的 layer 数组</span></span><br><span class="line">  app.routes = [];</span><br><span class="line">  <span class="comment">// 中间件注册方法</span></span><br><span class="line">  app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!callback) &#123;</span><br><span class="line">      callback = path;</span><br><span class="line">      path = <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'middle'</span>,</span><br><span class="line">      path,</span><br><span class="line">      callback</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ;[<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'all'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    app[method] = <span class="function">(<span class="params">path, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// /user/:id/:name -&gt; /user/:([^\/]+)/:([^\/]+)</span></span><br><span class="line">      <span class="keyword">if</span> (path.includes(<span class="string">':'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> params = []</span><br><span class="line">        path = path.replace(<span class="regexp">/:([^\/]+)/g</span>, (...args) =&gt; &#123;</span><br><span class="line">          params.push(args[<span class="number">1</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'([^\/]+)'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        path = <span class="keyword">new</span> <span class="built_in">RegExp</span>(path);</span><br><span class="line">        path.params = params</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        path,</span><br><span class="line">        callback</span><br><span class="line">      &#125;</span><br><span class="line">      app.routes.push(layer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.listen = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(app)</span><br><span class="line">    server.listen(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = application;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第三版实现了与<code>Express</code>相同的路由与中间件功能，但是与源码相比还是有一些区别的，这里只是提供了一个简化版的思路。<code>Express</code>源码考虑的东西很多，但是大体思想是类似的。总结一下这一版路由与中间件的实现思想就是维护一个队列，通过 <code>app.get</code> 、<code>app.post</code>、 <code>app.all</code>、<code>app.use</code> 来构建一个 <code>layer</code> 对象，这个 <code>layer</code> 对象中包含了，<code>method</code>、<code>path</code>、<code>callback</code> 函数，然后将 <code>layer</code> 对象存放在队列中。<br>当请求到来时，通过<code>next</code> 回调函数来遍历队列中的每一项，如果 <code>method</code> 与 <code>path</code> 都匹配的话，则执行该 <code>callback</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Express-中间件&quot;&gt;&lt;a href=&quot;#Express-中间件&quot; class=&quot;headerlink&quot; title=&quot;Express 中间件&quot;&gt;&lt;/a&gt;Express 中间件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 路由与中间件具体用法参考&lt;a href=&quot;https://expressjs.com/zh-cn/4x/api.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网 API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 路由原理见 &lt;a href=&quot;http://www.goyth.com/2019/07/20/expressRouter/&quot;&gt;Express路由与中间件原理（路由篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 中间件通常用来一些公用的逻辑，并可以将处理的结果挂载在 &lt;code&gt;req&lt;/code&gt;、&lt;code&gt;res&lt;/code&gt; 上，以供后面的中间件函数，或路由函数使用。因此通常情况下中间件函数会放在路由的前面&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://www.goyth.com/categories/Nodejs/"/>
    
    
      <category term="Express" scheme="http://www.goyth.com/tags/Express/"/>
    
      <category term="Nodejs" scheme="http://www.goyth.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Express路由与中间件原理（路由篇）</title>
    <link href="http://www.goyth.com/2019/07/20/expressRouter/"/>
    <id>http://www.goyth.com/2019/07/20/expressRouter/</id>
    <published>2019-07-20T07:51:12.000Z</published>
    <updated>2019-07-21T08:46:16.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-路由与中间件介绍"><a href="#Express-路由与中间件介绍" class="headerlink" title="Express 路由与中间件介绍"></a>Express 路由与中间件介绍</h2><p><code>Express</code> 路由与中间件具体用法参考<a href="https://expressjs.com/zh-cn/4x/api.html" target="_blank" rel="noopener">官网 API</a></p><h3 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a>Express 路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'get home'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">"post hemo"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/all'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">"all"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">"all *"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sever run port 3000"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>导入 <code>express</code> 后会得到一个 <code>express</code> 函数，执行这个函数后返回一个 <code>app</code> <code>函数，app</code> 上有一个 <code>listen</code> 函数，执行这个 <code>listen</code> 函数就会启一个 <code>http</code> 服务，通过 <code>app.get</code>、<code>app.post</code>、<code>app.all</code>等函数来注册监听函数，如果 <code>http server</code> 监听到有请求到来，就会调用在 <code>app</code> 上注册的相应的回调函数。</p><a id="more"></a><p>在 express 内部有一个 routes 数组， <code>app.get</code>、<code>app.post</code>、<code>app.all</code>等函数会产生一个 <code>layer</code> 对象，并将 <code>layer</code> 对象存放在 <code>routes</code> 数组中，这个 <code>layer</code> 对象中包含了 <code>method</code>、<code>path</code>、<code>callback</code>，当请求到来时就会去遍历 <code>routes</code> 数组，如果该请求的 <code>method</code>、<code>path</code>与 <code>routes</code>数组中 <code>layer</code> 对象的<code>method</code>、<code>path</code>一致，则执行该 <code>layer</code> 中的 <code>callback</code> 方法</p><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">application</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">let</span> method = req.method.toLowerCase();</span><br><span class="line">    <span class="comment">// 获取请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      pathname</span><br><span class="line">    &#125; = url.parse(req.url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line">      <span class="keyword">if</span> ((layer.method === method || <span class="string">"all"</span> === layer.method) &amp;&amp; (layer.path === pathname || (<span class="string">"*"</span> === layer.path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.callback(req, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">`cannot <span class="subst">$&#123;method&#125;</span>  <span class="subst">$&#123;pathname&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.routes = []</span><br><span class="line"></span><br><span class="line">  app.get = <span class="function">(<span class="params">path, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'get'</span>,</span><br><span class="line">      path,</span><br><span class="line">      callback</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.post = <span class="function">(<span class="params">path, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'post'</span>,</span><br><span class="line">      path,</span><br><span class="line">      callback</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.all = <span class="function">(<span class="params">path, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> layer = &#123;</span><br><span class="line">      method: <span class="string">'all'</span>,</span><br><span class="line">      path,</span><br><span class="line">      callback</span><br><span class="line">    &#125;</span><br><span class="line">    app.routes.push(layer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.listen = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(app)</span><br><span class="line">    server.listen(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = application;</span><br></pre></td></tr></table></figure><h3 id="支持匹配路径参数"><a href="#支持匹配路径参数" class="headerlink" title="支持匹配路径参数"></a>支持匹配路径参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// let express = require('./express')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id/:name'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params.id)</span><br><span class="line">  <span class="built_in">console</span>.log(req.params.name)</span><br><span class="line">  res.end(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"sever run port 3000"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果路径中<code>/</code>后面以<code>:</code>开头，则表示为一个路径参数<br>以<code>/user/:id/:name</code>为例：<br>如果请求路径为<code>/user/123/luke</code>，那么 express 会取出<code>[id, name]</code>和<code>[123, luke]</code>组成一个<code>{id: 123, name: luke}</code>的对象，并将这个对象挂载在 <code>req.params</code>上</p><p>这里可以使用<a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a><br>具体的做法是先通过正则表达式将<code>/user/:id/:name</code>中的 id 和 name 取出放在一个数组中，然后将 <code>/user/:id/:name</code> 替换成 <code>/user/:([^\/]+)/:([^\/]+)</code>，让 <code>path = new RegEpx(&#39;/user/:([^\/]+)/:([^\/]+)&#39;)</code>，然后在匹配请求时，通过该正则表达式来进行匹配，并将组成的对象挂载在 <code>req.params</code> 上。</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">application</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> app = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">let</span> method = req.method.toLowerCase();</span><br><span class="line">    <span class="comment">// 获取请求路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; app.routes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> layer = app.routes[i];</span><br><span class="line">      <span class="keyword">let</span> layerPath = layer.path</span><br><span class="line">      <span class="keyword">let</span> layerMethod = layer.method</span><br><span class="line">      <span class="keyword">if</span> (layerPath.params) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(layerPath.params)</span><br><span class="line">        <span class="keyword">if</span> ((layerMethod === method || <span class="string">"all"</span> === layerMethod) &amp;&amp; layerPath.test(pathname)) &#123;</span><br><span class="line">          <span class="comment">// 过滤掉第一项</span></span><br><span class="line">          <span class="keyword">let</span> [, ...args] = pathname.match(layer.path)</span><br><span class="line">          <span class="built_in">console</span>.log(args)</span><br><span class="line">          req.params = layerPath.params.reduce(<span class="function">(<span class="params">memo, current, index</span>) =&gt;</span> (memo[current] = args[index], memo), &#123;&#125;);</span><br><span class="line">          <span class="built_in">console</span>.log(req.params)</span><br><span class="line">          <span class="keyword">return</span> layer.callback(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((layerMethod === method || <span class="string">"all"</span> === layerMethod) &amp;&amp; (layerPath === pathname || (<span class="string">"*"</span> === layerPath))) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.callback(req, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">`cannot <span class="subst">$&#123;method&#125;</span>  <span class="subst">$&#123;pathname&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.routes = [];</span><br><span class="line"></span><br><span class="line">  [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'all'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    app[method] = <span class="function">(<span class="params">path, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.includes(<span class="string">':'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> params = []</span><br><span class="line">        <span class="comment">// /user/:id/:name -&gt; /user/:([^\/]+)/:([^\/]+)</span></span><br><span class="line">        path = path.replace(<span class="regexp">/:([^\/]+)/g</span>, (...args) =&gt; &#123;</span><br><span class="line">          params.push(args[<span class="number">1</span>])</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'([^\/]+)'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        path = <span class="keyword">new</span> <span class="built_in">RegExp</span>(path);</span><br><span class="line">        path.params = params</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> layer = &#123;</span><br><span class="line">        method,</span><br><span class="line">        path,</span><br><span class="line">        callback</span><br><span class="line">      &#125;</span><br><span class="line">      app.routes.push(layer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.listen = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> server = http.createServer(app)</span><br><span class="line">    server.listen(...args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = application;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一版实现了 <code>epress</code> 路由的功能，但是跟 <code>express</code> 的源码区别还是很大的，这里只是提供了一种简化的思路。并且没有涉及<code>express</code> 的中间件，下一篇<a href="http://www.goyth.com/2019/07/20/expressMiddleware/">《Express路由与中间件原理（中间件篇）》</a>会添加 中间件的实现，并对这一版做出改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Express-路由与中间件介绍&quot;&gt;&lt;a href=&quot;#Express-路由与中间件介绍&quot; class=&quot;headerlink&quot; title=&quot;Express 路由与中间件介绍&quot;&gt;&lt;/a&gt;Express 路由与中间件介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Express&lt;/code&gt; 路由与中间件具体用法参考&lt;a href=&quot;https://expressjs.com/zh-cn/4x/api.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网 API&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Express-路由&quot;&gt;&lt;a href=&quot;#Express-路由&quot; class=&quot;headerlink&quot; title=&quot;Express 路由&quot;&gt;&lt;/a&gt;Express 路由&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; express = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;express&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; app = express();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.get(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;, (req, res) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&#39;get home&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.post(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;, (req, res) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&quot;post hemo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.all(&lt;span class=&quot;string&quot;&gt;&#39;/all&#39;&lt;/span&gt;, (req, res) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&quot;all&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.all(&lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;, (req, res) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&quot;all *&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.listen(&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;sever run port 3000&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;导入 &lt;code&gt;express&lt;/code&gt; 后会得到一个 &lt;code&gt;express&lt;/code&gt; 函数，执行这个函数后返回一个 &lt;code&gt;app&lt;/code&gt; &lt;code&gt;函数，app&lt;/code&gt; 上有一个 &lt;code&gt;listen&lt;/code&gt; 函数，执行这个 &lt;code&gt;listen&lt;/code&gt; 函数就会启一个 &lt;code&gt;http&lt;/code&gt; 服务，通过 &lt;code&gt;app.get&lt;/code&gt;、&lt;code&gt;app.post&lt;/code&gt;、&lt;code&gt;app.all&lt;/code&gt;等函数来注册监听函数，如果 &lt;code&gt;http server&lt;/code&gt; 监听到有请求到来，就会调用在 &lt;code&gt;app&lt;/code&gt; 上注册的相应的回调函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://www.goyth.com/categories/Nodejs/"/>
    
    
      <category term="Express" scheme="http://www.goyth.com/tags/Express/"/>
    
      <category term="Nodejs" scheme="http://www.goyth.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>golang 学习笔记（一）——语法篇</title>
    <link href="http://www.goyth.com/2019/06/08/golangLearning01/"/>
    <id>http://www.goyth.com/2019/06/08/golangLearning01/</id>
    <published>2019-06-08T10:36:18.000Z</published>
    <updated>2019-06-23T01:45:28.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang-应⽤程序⼊⼝"><a href="#golang-应⽤程序⼊⼝" class="headerlink" title="golang 应⽤程序⼊⼝"></a>golang 应⽤程序⼊⼝</h2><ol><li>必须是 main 包：package main</li><li>必须是 main ⽅法：func main()</li><li>⽂件名不⼀定是 main.go</li></ol><h2 id="退出返回值"><a href="#退出返回值" class="headerlink" title="退出返回值"></a>退出返回值</h2><p>与其他主要编程语⾔的差异</p><ul><li>Go 中 main 函数不⽀持任何返回值</li><li>通过 os.Exit 来返回状态</li></ul><h2 id="获取命令⾏参数"><a href="#获取命令⾏参数" class="headerlink" title="获取命令⾏参数"></a>获取命令⾏参数</h2><p>与其他主要编程语⾔的差异</p><ul><li>main 函数不⽀持传⼊参数<br>func main(<del>arg []string</del>)</li><li>在程序中直接通过 os.Args 获取命令⾏参数</li></ul><a id="more"></a><h2 id="变量量赋值"><a href="#变量量赋值" class="headerlink" title="变量量赋值"></a>变量量赋值</h2><p><strong>与其他主要编程语⾔言的差异</strong></p><ol><li>赋值可以进⾏行行⾃自动类型推断</li><li>在⼀一个赋值语句句中可以对多个变量量进⾏行行同时赋值</li></ol><h3 id="常量量定义"><a href="#常量量定义" class="headerlink" title="常量量定义"></a>常量量定义</h3><p><strong>与其他主要编程语⾔言的差异</strong></p><ul><li>快速设置连续值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Monday = <span class="literal">iota</span> + <span class="number">1</span><span class="comment">//Monday =  0 + 1</span></span><br><span class="line">  Tuesday<span class="comment">//Tuesday =  iota + 1 =  1 + 1</span></span><br><span class="line">  Wednesday<span class="comment">//Wednesday =  iota + 1 =  2 + 1</span></span><br><span class="line">  Thursday<span class="comment">//Thursday =  iota + 1 =  3 + 1</span></span><br><span class="line">  Friday<span class="comment">//Friday =  iota + 1 =  4 + 1</span></span><br><span class="line">  Saturday<span class="comment">//Saturday =  iota + 1 =  5 + 1</span></span><br><span class="line">  Sunday<span class="comment">//Sunday =  iota + 1 =  6 + 1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Open = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  Close</span><br><span class="line">  Pending</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p><code>iota</code>是<code>golang</code>语言的常量计数器,只能在常量的表达式中使用。<br><code>iota</code>在<code>const</code>关键字出现时将被重置为<code>0</code>(<code>const</code>内部的第一行之前)，<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(<code>iota</code>可理解为const语句块中的行索引)。<br>使用<code>iota</code>能简化定义，在定义枚举时很有用。</p><ul><li>每次 const 出现时，都会让 iota 初始化为0</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a=0 </span></span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">  b = <span class="literal">iota</span>     <span class="comment">//b=0 </span></span><br><span class="line">  c            <span class="comment">//c=1 </span></span><br><span class="line">)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 可跳过的值</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="comment">//如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。</span></span><br><span class="line"><span class="keyword">type</span> AudioOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">    OutMute AudioOutput = <span class="literal">iota</span> <span class="comment">// 0 </span></span><br><span class="line">    OutMono                    <span class="comment">// 1 </span></span><br><span class="line">    OutStereo                  <span class="comment">// 2 </span></span><br><span class="line">    _ </span><br><span class="line">    _ </span><br><span class="line">    OutSurround                <span class="comment">// 5 </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>定义在一行的情况</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span></span><br><span class="line">    Cherimoya, Durian   <span class="comment">// = iota + 1, iota + 2 </span></span><br><span class="line">    Elderberry, Fig     <span class="comment">//= iota + 1, iota + 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 在下一行增长，而不是立即取得它的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apple: 1 </span></span><br><span class="line"><span class="comment">// Banana: 2 </span></span><br><span class="line"><span class="comment">// Cherimoya: 2 </span></span><br><span class="line"><span class="comment">// Durian: 3 </span></span><br><span class="line"><span class="comment">// Elderberry: 3 </span></span><br><span class="line"><span class="comment">// Fig: 4</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32,represents a Unicode code point</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><p><strong>与其他主要编程语⾔言的差异</strong></p><ol><li>Go 语⾔言不不允许隐式类型转换</li><li>别名和原有类型也不不能进⾏行行隐式类型转换</li></ol><h3 id="类型的预定义值"><a href="#类型的预定义值" class="headerlink" title="类型的预定义值"></a>类型的预定义值</h3><ol><li>math.MaxInt64</li><li>math.MaxFloat64</li><li>math.MaxUint32</li></ol><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><strong>与其他主要编程语⾔言的差异</strong></p><ol><li>不不⽀支持指针运算</li><li>string 是值类型，其默认的初始化值为空字符串串，⽽而不不是 nil</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h2><p>在 golang 中 == 运算符在比较数组时，不同于其他其他语言是比较引用，只要数组的维数和个数是相等的话，可以使用 == 运算符来进行比较，只要每一位的数值相同，则相等。</p><h2 id="按位清零-amp"><a href="#按位清零-amp" class="headerlink" title="按位清零(&amp;^)"></a>按位清零(&amp;^)</h2><p>go 独有的位运算符——按位清零（&amp;^）只要右边二进制位位 1，无论左边对应二进制位是 1 还是 0，结果都是 0，如果右边二进制位为 0，那么左边二进制位是什么，结果就取什么。</p><p>1 &amp;^ 0 – 1<br>1 &amp;^ 1 – 0<br>0 &amp;^ 1 – 0<br>0 &amp;^ 0 – 0</p><p>0b1100 &amp;^ 0b0110 = 0b1000</p><h2 id="switch-条件"><a href="#switch-条件" class="headerlink" title="switch 条件"></a>switch 条件</h2><ol><li>条件表达式不限制为常量或者整数；</li><li>单个 case 中，可以出现多个结果选项, 使⽤逗号分隔；</li><li>与 C 语⾔等规则相反，Go 语⾔不需要⽤ break 来明确退出⼀个 case；</li><li>可以不设定 switch 之后的条件表达式，在此种情况下，整个 switch 结<br>构与多个 if…else… 的逻辑作⽤等同</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSwitch</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>, <span class="number">2</span>:</span><br><span class="line">t.Log(<span class="string">"Even"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>:</span><br><span class="line">t.Log(<span class="string">"Odd"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">t.Log(<span class="string">"not 0-3"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSwitchCondition</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">switch</span>  &#123;</span><br><span class="line"><span class="keyword">case</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">t.Log(<span class="string">"Even"</span>)</span><br><span class="line"><span class="keyword">case</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">t.Log(<span class="string">"Odd"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">t.Log(<span class="string">"unknow"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组的声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span> <span class="comment">//声明并初始化为默认零值</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">b := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">//声明同时初始化</span></span><br><span class="line">c := [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125; <span class="comment">//多维数组初始化</span></span><br></pre></td></tr></table></figure><ul><li>数组元素遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTravelArray</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//不指定元素个数</span></span><br><span class="line">    <span class="keyword">for</span> idx<span class="comment">/*索引*/</span>, elem<span class="comment">/*元素\*/</span> := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(idx, elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组截取<br>a[开始索引(包含), 结束索引(不包含)]</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">a[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">//2</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//2,3</span></span><br><span class="line">a[<span class="number">1</span>:<span class="built_in">len</span>(a)] <span class="comment">//2,3,4,5</span></span><br><span class="line">a[<span class="number">1</span>:] <span class="comment">//2,3,4,5</span></span><br><span class="line">a[:<span class="number">3</span>] <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h3><p><img src="/2019/06/08/golangLearning01/slice_struct.jpg" alt=""></p><p>切片的数据结构包含三个部分：</p><ul><li>第一个是一个指针，指向一片连续的存储空间，也就是指向一个数组</li><li>第二个是 <code>len</code> 属性，记录的是 <code>slice</code> 中元素的个数，也是我们可以访问到的元素的个数</li><li>第三个是 <code>cap</code> 属性，记录的是内部数组的容量</li></ul><p>切片是可变长的，当往切片中添加的元素超过 <code>cap</code> 属性的容量时，会重新生成一个 <code>2 * cap</code> 容量的切片，并将原有切片里的值拷贝过来。</p><h3 id="切⽚片声明"><a href="#切⽚片声明" class="headerlink" title="切⽚片声明"></a>切⽚片声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> s0 []<span class="keyword">int</span></span><br><span class="line">   s0 = <span class="built_in">append</span>(s0, <span class="number">1</span>)</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">   s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">   s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">/*[]type, len, cap 其中len个元素会被初始化为默认零值，未初始化元素不不可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="切片共享存储结构"><a href="#切片共享存储结构" class="headerlink" title="切片共享存储结构"></a>切片共享存储结构</h3><p><img src="/2019/06/08/golangLearning01/slice_share_struct.jpg" alt=""></p><p>当多个切片都指向一片相同的存储空间时，其中一个 slice 对元素做出修改后，其他的切片都会受到影响。</p><h3 id="切片和数组的区别"><a href="#切片和数组的区别" class="headerlink" title="切片和数组的区别"></a>切片和数组的区别</h3><ul><li>数组是定长的而切片是不定长的</li><li>数组与数组之间可以用 <code>==</code> 来进行比较，切片只能与 <code>nil</code> 进行比较</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-声明"><a href="#Map-声明" class="headerlink" title="Map 声明"></a>Map 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m1[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span> <span class="comment">/*Initial Capacity*/</span>) <span class="comment">//为什什么不不初始化len? </span></span><br><span class="line"><span class="comment">//len 所指的单元格初始化时都会被赋值默认零值，而 Map 是不能赋值默认零值的，所以 Map 不能初始化 len 属性</span></span><br></pre></td></tr></table></figure><p>Map 元素的访问 与其他主要编程语⾔言的差异</p><p>在访问的 <code>Key</code> 不存在时，并不会抛出异常，而是仍会返回零值，所以不能通过返回 <code>nil</code> 来判断元素是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := m[<span class="string">"four"</span>]; ok &#123;</span><br><span class="line">  t.Log(<span class="string">"four"</span>, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  t.Log(<span class="string">"Not existing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-遍历"><a href="#Map-遍历" class="headerlink" title="Map 遍历"></a>Map 遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">  t.Log(k, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数：一等公⺠"><a href="#函数：一等公⺠" class="headerlink" title="函数：一等公⺠"></a>函数：一等公⺠</h2><p><strong>与其他主要编程语⾔言的差异</strong></p><ol><li>可以有多个返回值</li><li>所有参数都是值传递:slice，map，channel 会有传引⽤用的错觉</li><li>函数可以作为变量量的值</li><li>函数可以作为参数和返回值</li></ol><h3 id="函数-可变参数及-defer"><a href="#函数-可变参数及-defer" class="headerlink" title="函数:可变参数及 defer"></a>函数:可变参数及 defer</h3><p><strong>可变参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(ops ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  s := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">s += op</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer 函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDefer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"Clear resources"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">t.Log(<span class="string">"Started"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Fatal error”) //defer仍会执⾏行行</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;golang-应⽤程序⼊⼝&quot;&gt;&lt;a href=&quot;#golang-应⽤程序⼊⼝&quot; class=&quot;headerlink&quot; title=&quot;golang 应⽤程序⼊⼝&quot;&gt;&lt;/a&gt;golang 应⽤程序⼊⼝&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;必须是 main 包：package main&lt;/li&gt;
&lt;li&gt;必须是 main ⽅法：func main()&lt;/li&gt;
&lt;li&gt;⽂件名不⼀定是 main.go&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;退出返回值&quot;&gt;&lt;a href=&quot;#退出返回值&quot; class=&quot;headerlink&quot; title=&quot;退出返回值&quot;&gt;&lt;/a&gt;退出返回值&lt;/h2&gt;&lt;p&gt;与其他主要编程语⾔的差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 中 main 函数不⽀持任何返回值&lt;/li&gt;
&lt;li&gt;通过 os.Exit 来返回状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;获取命令⾏参数&quot;&gt;&lt;a href=&quot;#获取命令⾏参数&quot; class=&quot;headerlink&quot; title=&quot;获取命令⾏参数&quot;&gt;&lt;/a&gt;获取命令⾏参数&lt;/h2&gt;&lt;p&gt;与其他主要编程语⾔的差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main 函数不⽀持传⼊参数&lt;br&gt;func main(&lt;del&gt;arg []string&lt;/del&gt;)&lt;/li&gt;
&lt;li&gt;在程序中直接通过 os.Args 获取命令⾏参数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://www.goyth.com/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://www.goyth.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>单页面（SPA）路由实现原理</title>
    <link href="http://www.goyth.com/2019/05/25/SPARouter/"/>
    <id>http://www.goyth.com/2019/05/25/SPARouter/</id>
    <published>2019-05-25T02:47:56.000Z</published>
    <updated>2019-05-25T11:17:20.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单页面应用"><a href="#什么是单页面应用" class="headerlink" title="什么是单页面应用 ?"></a>什么是单页面应用 ?</h2><p>单页面应用（SPA）即single page application，目前在前后端分离的项目中，一般都是采用 SPA 的模式，整个应用只有一个 html 页面。后端接口只负责提供数据，而页面路由则需要前端自己完成。</p><h2 id="单页面应用的优势"><a href="#单页面应用的优势" class="headerlink" title="单页面应用的优势"></a>单页面应用的优势</h2><h3 id="1-减少-http-请求数，降低服务器压力"><a href="#1-减少-http-请求数，降低服务器压力" class="headerlink" title="1. 减少 http 请求数，降低服务器压力"></a>1. 减少 http 请求数，降低服务器压力</h3><p>单页面应用在切换页面时，路由由前端路由系统完成，不需要向服务器发送请求，服务器也不用再返回一个 html 页面。</p><h3 id="2-有利于前后端分离"><a href="#2-有利于前后端分离" class="headerlink" title="2. 有利于前后端分离"></a>2. 有利于前后端分离</h3><p>使用单页面应用后，后端不需要再配置路由接口，只用提供访问数据的接口，这样使得前后端工作解耦，开发效率更高。</p><h3 id="3-页面流畅度更高，用户体验更加友好"><a href="#3-页面流畅度更高，用户体验更加友好" class="headerlink" title="3. 页面流畅度更高，用户体验更加友好"></a>3. 页面流畅度更高，用户体验更加友好</h3><p>单页面路由切换时，页面通过本地 js 计算生成，页面切换更快更流畅。</p><a id="more"></a><h2 id="单页面应用的缺点"><a href="#单页面应用的缺点" class="headerlink" title="单页面应用的缺点"></a>单页面应用的缺点</h2><p>由于单页面应用的内容都是由 js 计算生成，所以不利于 SEO，不过这可以通过 prerender、服务端渲染等技术解决。</p><h2 id="如何实现单页面路由"><a href="#如何实现单页面路由" class="headerlink" title="如何实现单页面路由"></a>如何实现单页面路由</h2><p>单页面路由在切换页面或者说 URL 改变时，并没有刷新页面，而是通过 js 计算，将对应 URL路径需要展示的组件显示在页面上。所以要实现单页面路由，需要做到以下两点：</p><ol><li>如何在改变 URL 时，不引起页面的刷新</li><li>URL 改变时，如何监听 URL 的变化，并对页面进行改变</li></ol><p>目前实现单页面路由有两种方法，分别是通过 url hash 和 h5 history api，下面介绍下如何通过这两种方法实现单页面路由。</p><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>当 URL 中的 hash 发生改变时，页面不会刷新，我们可以用 hashchange 来监听 hash 的改变。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/a"</span>&gt;</span>跳转到/a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/b"</span>&gt;</span>跳转到/b<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span> <span class="attr">style</span>=<span class="string">"border:3px solid red;height:200px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>,(event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//console.log(event);</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//container.innerHTML = event.newURL;</span></span></span><br><span class="line"><span class="javascript">  container.innerHTML = <span class="string">`当前的路径是 <span class="subst">$&#123;<span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">&#125;);  </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HistoryRouter"><a href="#HistoryRouter" class="headerlink" title="HistoryRouter"></a>HistoryRouter</h3><p>HTML5 中引入了 history.pushState() 和 history.replaceState()方法，这个两个方法分别可以添加和修改 URL 栈中当前的记录，可以修改当前 URL 中的 path 部分，并且不会引起页面的刷新。<br>通过 window.onpopstate 函数可以监听 URL 栈中的回退事件，当通过点击事件进行跳转时，可以统一使用 history.pushstate 来进行跳转，这样通过重写 history.pushstate 就可以监听到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span> <span class="attr">style</span>=<span class="string">"border:3px solid red;height:200px"</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"push('/a')"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"push('/b')"</span>&gt;</span>/b<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"push('/c')"</span>&gt;</span>/c<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//监听弹出状态的事件</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//console.log(event);</span></span></span><br><span class="line"><span class="undefined">  container.innerHTML= event.state.to;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onpushstate = <span class="function"><span class="keyword">function</span>(<span class="params">state,title,url</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//console.log(event);</span></span></span><br><span class="line"><span class="undefined">  container.innerHTML= state.to||url;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> oldPush = <span class="built_in">window</span>.history.pushState;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.history.pushState = <span class="function"><span class="keyword">function</span>(<span class="params">state,title,url</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    oldPush.call(<span class="built_in">window</span>.history,state,title,url);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onpushstate(state,title,url);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">to</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'pushstate!'</span>)</span></span><br><span class="line"><span class="javascript">   <span class="comment">//pushState 三个参数 新的状态对象 标题(已经废弃) to 跳转到的路径</span></span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.history.pushState(&#123;to&#125;,<span class="literal">null</span>,to);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单页面应用&quot;&gt;&lt;a href=&quot;#什么是单页面应用&quot; class=&quot;headerlink&quot; title=&quot;什么是单页面应用 ?&quot;&gt;&lt;/a&gt;什么是单页面应用 ?&lt;/h2&gt;&lt;p&gt;单页面应用（SPA）即single page application，目前在前后端分离的项目中，一般都是采用 SPA 的模式，整个应用只有一个 html 页面。后端接口只负责提供数据，而页面路由则需要前端自己完成。&lt;/p&gt;
&lt;h2 id=&quot;单页面应用的优势&quot;&gt;&lt;a href=&quot;#单页面应用的优势&quot; class=&quot;headerlink&quot; title=&quot;单页面应用的优势&quot;&gt;&lt;/a&gt;单页面应用的优势&lt;/h2&gt;&lt;h3 id=&quot;1-减少-http-请求数，降低服务器压力&quot;&gt;&lt;a href=&quot;#1-减少-http-请求数，降低服务器压力&quot; class=&quot;headerlink&quot; title=&quot;1. 减少 http 请求数，降低服务器压力&quot;&gt;&lt;/a&gt;1. 减少 http 请求数，降低服务器压力&lt;/h3&gt;&lt;p&gt;单页面应用在切换页面时，路由由前端路由系统完成，不需要向服务器发送请求，服务器也不用再返回一个 html 页面。&lt;/p&gt;
&lt;h3 id=&quot;2-有利于前后端分离&quot;&gt;&lt;a href=&quot;#2-有利于前后端分离&quot; class=&quot;headerlink&quot; title=&quot;2. 有利于前后端分离&quot;&gt;&lt;/a&gt;2. 有利于前后端分离&lt;/h3&gt;&lt;p&gt;使用单页面应用后，后端不需要再配置路由接口，只用提供访问数据的接口，这样使得前后端工作解耦，开发效率更高。&lt;/p&gt;
&lt;h3 id=&quot;3-页面流畅度更高，用户体验更加友好&quot;&gt;&lt;a href=&quot;#3-页面流畅度更高，用户体验更加友好&quot; class=&quot;headerlink&quot; title=&quot;3. 页面流畅度更高，用户体验更加友好&quot;&gt;&lt;/a&gt;3. 页面流畅度更高，用户体验更加友好&lt;/h3&gt;&lt;p&gt;单页面路由切换时，页面通过本地 js 计算生成，页面切换更快更流畅。&lt;/p&gt;
    
    </summary>
    
      <category term="Router" scheme="http://www.goyth.com/categories/Router/"/>
    
    
      <category term="SPA" scheme="http://www.goyth.com/tags/SPA/"/>
    
      <category term="Router" scheme="http://www.goyth.com/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>编写一个 webpack Loader</title>
    <link href="http://www.goyth.com/2019/01/12/webpackLoader/"/>
    <id>http://www.goyth.com/2019/01/12/webpackLoader/</id>
    <published>2019-01-12T04:08:23.000Z</published>
    <updated>2019-01-19T05:42:26.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-webpack-Loader"><a href="#什么是-webpack-Loader" class="headerlink" title="什么是 webpack Loader"></a>什么是 webpack Loader</h2><p>webpack Loader 是一个符合 <code>commonjs</code> 规范的模块，这个模块导出一个函数，它的主要作用是对源码进行转换，webpack 在调用 Loader时，会将源代码作为参数传递给这个Loader，然后该loader会对源码进行转换，并且返回转换后的内容。</p><a id="more"></a><p>一个最简单的 Loader 的源码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">  <span class="comment">// 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="loader-执行顺序"><a href="#loader-执行顺序" class="headerlink" title="loader 执行顺序"></a>loader 执行顺序</h3><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'a-loader'</span>,</span><br><span class="line">          <span class="string">'b-loader'</span>,</span><br><span class="line">          <span class="string">'c-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>loader 的执行顺序是从后往前的，例如顺序配置<code>&#39;a-loader&#39;</code>,<code>&#39;b-loader&#39;</code>,<code>&#39;c-loader&#39;</code>，则它们的执行顺序是<code>&#39;c-loader&#39;</code> –&gt; <code>&#39;b-loader&#39;</code> –&gt; <code>&#39;a-loader&#39;</code>，<code>&#39;c-loader&#39;</code>接受 webpack 传递进来的原始数据，进行相应的转换，<code>&#39;b-loader&#39;</code> 接受 ‘c-loader’ 转换都的结果进行进一步转换，<code>&#39;a-loader&#39;</code> 接受 <code>&#39;b-loader&#39;</code> 转换的结果，进行进一步的转换，产生最终转换都的源码</p><h3 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h3><p>在默认的情况下，Webpack 传给 Loader 的原内容都是 <code>UTF-8</code> 格式编码的字符串。<br>但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 <code>file-loader</code>，就需要 Webpack 给 Loader 传入二进制格式的数据。<br>为此，你需要这样编写 Loader：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的</span></span><br><span class="line">    source <span class="keyword">instanceof</span> Buffer === <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Loader 返回的类型也可以是 Buffer 类型的</span></span><br><span class="line">    <span class="comment">// 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果</span></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 </span></span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>以上代码中最关键的代码是最后一行 <code>module.exports.raw = true;</code>，没有该行 Loader 只能拿到字符串。</p><h2 id="webpack-loader-API-介绍"><a href="#webpack-loader-API-介绍" class="headerlink" title="webpack loader API 介绍"></a>webpack loader API 介绍</h2><p>webpack在 loader 的 <code>this</code> 上挂在了很多有用的属性或方法，后面会有详细介绍。</p><h3 id="this-callback"><a href="#this-callback" class="headerlink" title="this.callback()"></a>this.callback()</h3><p>在 loader 中如果是采用 <code>return</code> 的方式，那么默认只会返回一个值，如果你需要返回多个值可以采用<code>this.callback</code></p><p>例如以用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码。<br>为了把 Source Map 也一起随着 ES5 代码返回给 Webpack，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 this.callback 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, sourceMaps);</span><br><span class="line">  <span class="comment">// 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，</span></span><br><span class="line">  <span class="comment">// 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 </span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的 <code>this.callback</code> 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。<br><code>this.callback</code> 的详细使用方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">    <span class="comment">// 当无法转换原内容时，给 Webpack 返回一个 Error</span></span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 原内容转换后的内容</span></span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    <span class="comment">// 用于把转换后的内容得出原内容的 Source Map，方便调试</span></span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    <span class="comment">// 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，</span></span><br><span class="line">    <span class="comment">// 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能</span></span><br><span class="line">    abstractSyntaxTree?: AST</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。<br>为此 Webpack 为 Loader 提供了 this.sourceMap API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。<br>如果你编写的 Loader 会生成 Source Map，请考虑到这点。</p><h3 id="this-async"><a href="#this-async" class="headerlink" title="this.async()"></a>this.async()</h3><p>Loader 有同步和异步之分，上面介绍的 Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。<br>但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢。</p><p>在转换步骤是异步时，你可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果</span></span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    someAsyncOperation(source, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, sourceMaps, ast</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 callback 返回异步执行后的结果</span></span><br><span class="line">        callback(err, result, sourceMaps, ast);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="this-cacheable"><a href="#this-cacheable" class="headerlink" title="this.cacheable()"></a>this.cacheable()</h3><p>在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。<br>为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，<br>是不会重新调用对应的 Loader 去执行转换操作的。</p><p>如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关闭该 Loader 的缓存功能</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="this-context"><a href="#this-context" class="headerlink" title="this.context"></a>this.context</h3><p>当前处理文件的所在目录，假如当前 Loader 处理的文件是 <code>/src/main.js</code>，则 <code>this.context</code> 就等于 <code>/src</code>。</p><h3 id="this-resource"><a href="#this-resource" class="headerlink" title="this.resource"></a>this.resource</h3><p>当前处理文件的完整请求路径，包括 querystring，例如 <code>/src/main.js?name=1</code>。</p><h3 id="this-resourcePath"><a href="#this-resourcePath" class="headerlink" title="this.resourcePath"></a>this.resourcePath</h3><p>当前处理文件的路径，例如 <code>/src/main.js</code>。</p><h3 id="this-resourceQuery"><a href="#this-resourceQuery" class="headerlink" title="this.resourceQuery"></a>this.resourceQuery</h3><p>当前处理文件的 querystring。</p><h3 id="this-target"><a href="#this-target" class="headerlink" title="this.target"></a>this.target</h3><p>等于 Webpack 配置中的 Target</p><h3 id="this-loadModule"><a href="#this-loadModule" class="headerlink" title="this.loadModule"></a>this.loadModule</h3><p>但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时，就可以通过 <code>this.loadModule(request: string, callback: function(err, source, sourceMap, module))</code> 去获得 request 对应文件的处理结果。</p><h3 id="this-resolve"><a href="#this-resolve" class="headerlink" title="this.resolve"></a>this.resolve</h3><p>像 require 语句一样获得指定文件的完整路径，使用方法为 <code>resolve(context: string, request: string, callback: function(err, result: string))</code>。</p><h3 id="this-addDependency"><a href="#this-addDependency" class="headerlink" title="this.addDependency"></a>this.addDependency</h3><p>给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 <code>addDependency(file: string)</code>。</p><h3 id="this-addContextDependency"><a href="#this-addContextDependency" class="headerlink" title="this.addContextDependency"></a>this.addContextDependency</h3><p>和 <code>addDependency</code> 类似，但 <code>addContextDependency</code> 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 <code>addContextDependency(directory: string)</code>。</p><h3 id="this-clearDependencies"><a href="#this-clearDependencies" class="headerlink" title="this.clearDependencies"></a>this.clearDependencies</h3><p>清除当前正在处理文件的所有依赖，使用方法为 <code>clearDependencies()</code>。</p><h3 id="this-emitFile"><a href="#this-emitFile" class="headerlink" title="this.emitFile"></a>this.emitFile</h3><p>输出一个文件，使用方法为 <code>emitFile(name: string, content: Buffer|string, sourceMap: {...})</code>。</p><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><h3 id="loader-编写准则"><a href="#loader-编写准则" class="headerlink" title="loader 编写准则"></a>loader 编写准则</h3><ol><li>loader 应该遵循单一职责原则，一个loader只完成一个功能，如果需要多步转换，则应该编写多个loader进行链式调用。</li><li>不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。<code>loader-utils</code> 中的 <code>stringifyRequest</code> 方法，可以将绝对路径转化为相对路径。</li><li>如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。</li></ol><h3 id="loader-工具库"><a href="#loader-工具库" class="headerlink" title="loader 工具库"></a>loader 工具库</h3><h4 id="loader-utils"><a href="#loader-utils" class="headerlink" title="loader-utils"></a>loader-utils</h4><p><a href="https://github.com/webpack/loader-utils" target="_blank" rel="noopener">loader-utils</a> 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项</p><h4 id="schema-utils"><a href="#schema-utils" class="headerlink" title="schema-utils"></a>schema-utils</h4><p><a href="https://github.com/webpack-contrib/schema-utils" target="_blank" rel="noopener">schema-utils</a> 包配合 loader-utils，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验</p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel=<span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=<span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        presets: [<span class="string">'env'</span>],</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">        filename:<span class="keyword">this</span>.request.split(<span class="string">'/'</span>).pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result=babel.transform(source,options);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.callback(<span class="literal">null</span>,result.code,result.map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BannerLoader"><a href="#BannerLoader" class="headerlink" title="BannerLoader"></a>BannerLoader</h3><p>给所有的文件添加同一的版权注释，可以接受一个文本，或者一个文件。</p><p><strong>banner-loader.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//把loader改为异步,任务完成后需要手工执行callback</span></span><br><span class="line">    <span class="keyword">let</span> cb = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="comment">//启用loader缓存</span></span><br><span class="line">    <span class="keyword">this</span>.cacheable &amp;&amp; <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="comment">//用来验证options的合法性</span></span><br><span class="line">    <span class="keyword">let</span> schema = &#123; </span><br><span class="line">        type: <span class="string">'object'</span>,</span><br><span class="line">        properties: &#123;</span><br><span class="line">            filename: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            text: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过工具方法获取options</span></span><br><span class="line">    <span class="keyword">let</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//用来验证options的合法性</span></span><br><span class="line">    validateOptions(schema, options, <span class="string">'Banner-Loader'</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; text, filename &#125; = options;</span><br><span class="line">    <span class="keyword">if</span> (text) &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, text + source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">        fs.readFile(filename, <span class="string">'utf8'</span>, (err, text) =&gt; &#123;</span><br><span class="line">            cb(err, text + source);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader;</span><br></pre></td></tr></table></figure><p><strong>banner.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* © 2019 GOYTH All Rights Reserved.  */</span></span><br></pre></td></tr></table></figure></p><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">"babel-loader"</span>: resolve(<span class="string">'./build/banner-loader.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/.+\.js$/</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">            options:&#123;<span class="attr">filename</span>:<span class="string">"./src/loaders/banner.js"</span>&#125;</span><br><span class="line"><span class="comment">//          options: &#123;text: "© 2019 GOYTH All Rights Reserved. "&#125;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><em>参考链接</em><br><em><a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">https://webpack.js.org/api/loaders/</a></em><br><em><a href="https://github.com/webpack/loader-utils" target="_blank" rel="noopener">https://github.com/webpack/loader-utils</a></em><br><em><a href="https://github.com/webpack-contrib/schema-utils" target="_blank" rel="noopener">https://github.com/webpack-contrib/schema-utils</a></em><br><em><a href="https://segmentfault.com/a/1190000012718374" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012718374</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-webpack-Loader&quot;&gt;&lt;a href=&quot;#什么是-webpack-Loader&quot; class=&quot;headerlink&quot; title=&quot;什么是 webpack Loader&quot;&gt;&lt;/a&gt;什么是 webpack Loader&lt;/h2&gt;&lt;p&gt;webpack Loader 是一个符合 &lt;code&gt;commonjs&lt;/code&gt; 规范的模块，这个模块导出一个函数，它的主要作用是对源码进行转换，webpack 在调用 Loader时，会将源代码作为参数传递给这个Loader，然后该loader会对源码进行转换，并且返回转换后的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://www.goyth.com/categories/webpack/"/>
    
    
      <category term="webpack Loader" scheme="http://www.goyth.com/tags/webpack-Loader/"/>
    
  </entry>
  
  <entry>
    <title>编写一个 Babel 插件</title>
    <link href="http://www.goyth.com/2019/01/06/babelPlugin/"/>
    <id>http://www.goyth.com/2019/01/06/babelPlugin/</id>
    <published>2019-01-06T14:35:55.000Z</published>
    <updated>2019-01-12T02:35:46.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Babel转译流程"><a href="#Babel转译流程" class="headerlink" title="Babel转译流程"></a>Babel转译流程</h2><p>Babel 对源码进行转译时，主要有三个步骤<br><img src="/2019/01/06/babelPlugin/babel" alt=""></p><ol><li>首先通过<code>Babylon</code> 将源码转化成 AST </li><li>然后再通过<code>babel-traverse</code>遍历 AST，找到需要更改的 AST 节点，对其进行修改</li><li>根据修改后的 AST，通过<code>babel-generator</code>将修改后的 AST重新生成源码<br>Babel插件主要是处理第二步。<a id="more"></a><h3 id="Babylon"><a href="#Babylon" class="headerlink" title="Babylon"></a>Babylon</h3>Babylon 是 Babel 的解析器，主要负责将源码转化成 AST。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line">babylon.parse(code);</span><br><span class="line"><span class="comment">// Node &#123;</span></span><br><span class="line"><span class="comment">//   type: "File",</span></span><br><span class="line"><span class="comment">//   start: 0,</span></span><br><span class="line"><span class="comment">//   end: 38,</span></span><br><span class="line"><span class="comment">//   loc: SourceLocation &#123;...&#125;,</span></span><br><span class="line"><span class="comment">//   program: Node &#123;...&#125;,</span></span><br><span class="line"><span class="comment">//   comments: [],</span></span><br><span class="line"><span class="comment">//   tokens: [...]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>我们还能像下面这样传递选项给 parse()方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">babylon.parse(code, &#123;</span><br><span class="line">  sourceType: <span class="string">"module"</span>, <span class="comment">// default: "script"</span></span><br><span class="line">  plugins: [<span class="string">"jsx"</span>] <span class="comment">// default: []</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>sourceType 可以是 “module” 或者 “script”，它表示 Babylon 应该用哪种模式来解析。 “module” 将会在严格模式下解析并且允许模块定义，”script” 则不会。</p><p><em>注意： sourceType 的默认值是 “script” 并且在发现 import 或 export 时产生错误。 使用 scourceType: “module” 来避免这些错误。</em></p><h3 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="babel-traverse"></a>babel-traverse</h3><p>Babel Traverse（遍历）模块维护了整棵AST树的状态，并且负责替换、移除和添加AST节点。</p><p>我们可以和 Babylon 一起使用来遍历和更新节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code);</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      path.node.type === <span class="string">"Identifier"</span> &amp;&amp;</span><br><span class="line">      path.node.name === <span class="string">"n"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      path.node.name = <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="babel-types"><a href="#babel-types" class="headerlink" title="babel-types"></a>babel-types</h3><p>Babel Types模块是一个针对于 AST 节点的工具库，它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。</p><p>可以运行以下命令来安装它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">"babel-types"</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">"n"</span> &#125;)) &#123;</span><br><span class="line">      path.node.name = <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="babel-generator"><a href="#babel-generator" class="headerlink" title="babel-generator"></a>babel-generator</h3><p>Babel Generator模块是 Babel 的代码生成器，它读取AST并将其转换为代码和源码映射（sourcemaps）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code);</span><br><span class="line"></span><br><span class="line">generate(ast, &#123;&#125;, code);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   code: "...",</span></span><br><span class="line"><span class="comment">//   map: "..."</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p><p>你也可以给 generate() 方法传递选项。.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">generate(ast, &#123;</span><br><span class="line">  retainLines: <span class="literal">false</span>,</span><br><span class="line">  compact: <span class="string">"auto"</span>,</span><br><span class="line">  concise: <span class="literal">false</span>,</span><br><span class="line">  quotes: <span class="string">"double"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, code);</span><br></pre></td></tr></table></figure></p><h2 id="Babel-插件编写"><a href="#Babel-插件编写" class="headerlink" title="Babel 插件编写"></a>Babel 插件编写</h2><p>Babel 插件是一个接收了当前babel对象作为参数的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// plugin contents</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以直接取解构出 babel.types<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// plugin contents</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着返回一个对象，其 visitor 属性是这个插件的主要访问者。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      <span class="comment">// visitor contents</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Visitor 中的每个函数接收2个参数：path 和 state<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path, state) &#123;&#125;,</span><br><span class="line">      ASTNodeTypeHere(path, state) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Babel-插件编写思路"><a href="#Babel-插件编写思路" class="headerlink" title="Babel 插件编写思路"></a>Babel 插件编写思路</h3><ol><li>Babel 插件主要是对 AST 进行转换</li><li>通过<a href="https://astexplorer.net/" target="_blank" rel="noopener">astexplorer.net</a>来比较转换前和转换后的 AST 的差异。</li><li>通过插件visitor模式遍历需要修改的 AST 节点</li><li>通过<a href="https://babeljs.io/docs/en/next/babel-types.html" target="_blank" rel="noopener">babel-types</a>来判断AST节点类型或者修改、构建新的AST节点</li><li>通过path.replaceWith()或者path.replaceWithMultiple()替换掉原来的节点</li></ol><h3 id="箭头函数插件"><a href="#箭头函数插件" class="headerlink" title="箭头函数插件"></a>箭头函数插件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure><p>我们写一个插件将上面的箭头函数转化成下面的普通函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Babel 插件主要是对 AST 进行转换<br>首先我们可以通过<a href="https://astexplorer.net/" target="_blank" rel="noopener">astexplorer.net</a>来观察一下，转换前和转换后的 AST 的差异。<br>转换前：<br><img src="/2019/01/06/babelPlugin/ast01.png" alt=""></p><p>转换后：<br><img src="/2019/01/06/babelPlugin/ast02.png" alt=""></p><p>比较两个AST 后，我们知道要将ArrowFunctionExpression替换成FunctionExpression，BinaryExpression替换成BlockStatement，那我们就要构建一个FunctionExpression节点，如何构建FunctionExpression节点呢，我们可以在<a href="https://babeljs.io/docs/en/next/babel-types.html" target="_blank" rel="noopener">babel-types</a>查找构建方法</p><p><img src="/2019/01/06/babelPlugin/fe.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transformArrayFunctions = &#123;</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    ArrowFunctionExpression: <span class="function">(<span class="params">path, state</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> node = path.node;</span><br><span class="line">      <span class="keyword">let</span> id = path.parent.id;</span><br><span class="line">      <span class="keyword">let</span> params = node.params;</span><br><span class="line">      <span class="keyword">let</span> body = t.blockStatement([t.returnStatement(node.body)])</span><br><span class="line">      <span class="keyword">let</span> functionExpression = t.functionExpression(id,params,body,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">      path.replaceWith(functionExpression);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [transformArrowFunctions]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br></pre></td></tr></table></figure><p><em>参考链接：</em><br><em><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md</a></em><br><em><a href="https://babeljs.io/docs/en/next/babel-types.html" target="_blank" rel="noopener">https://babeljs.io/docs/en/next/babel-types.html</a></em><br><em><a href="https://www.npmjs.com/package/babel-plugin-transform-es2015-arrow-functions" target="_blank" rel="noopener">https://www.npmjs.com/package/babel-plugin-transform-es2015-arrow-functions</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Babel转译流程&quot;&gt;&lt;a href=&quot;#Babel转译流程&quot; class=&quot;headerlink&quot; title=&quot;Babel转译流程&quot;&gt;&lt;/a&gt;Babel转译流程&lt;/h2&gt;&lt;p&gt;Babel 对源码进行转译时，主要有三个步骤&lt;br&gt;&lt;img src=&quot;/2019/01/06/babelPlugin/babel&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先通过&lt;code&gt;Babylon&lt;/code&gt; 将源码转化成 AST &lt;/li&gt;
&lt;li&gt;然后再通过&lt;code&gt;babel-traverse&lt;/code&gt;遍历 AST，找到需要更改的 AST 节点，对其进行修改&lt;/li&gt;
&lt;li&gt;根据修改后的 AST，通过&lt;code&gt;babel-generator&lt;/code&gt;将修改后的 AST重新生成源码&lt;br&gt;Babel插件主要是处理第二步。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Babel" scheme="http://www.goyth.com/categories/Babel/"/>
    
    
      <category term="Babel" scheme="http://www.goyth.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel 核心模块介绍</title>
    <link href="http://www.goyth.com/2019/01/05/babel/"/>
    <id>http://www.goyth.com/2019/01/05/babel/</id>
    <published>2019-01-05T14:35:55.000Z</published>
    <updated>2019-01-05T14:38:12.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Babel-介绍"><a href="#Babel-介绍" class="headerlink" title="Babel 介绍"></a>Babel 介绍</h2><p>Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。<br>Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。</p><a id="more"></a><p>例如，Babel 能够将新的 ES2015 箭头函数语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure></p><p>转译为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Babel核心模块介绍"><a href="#Babel核心模块介绍" class="headerlink" title="Babel核心模块介绍"></a>Babel核心模块介绍</h2><h3 id="Babel-core"><a href="#Babel-core" class="headerlink" title="Babel-core"></a>Babel-core</h3><p>可以看做 babel 的编译器。babel 的核心 api 都在这里面。它可以把 js 代码，抽象成 AST，然后修改 AST ，再根据AST生成新的js代码，这就是Babel 转译的过程。但是如何转译、转译哪些内容，着需要我们事先设置好的 plugin，plugin 就是如何转译的规则。</p><h3 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h3><p>它在底层改写了node的require方法，引入babel-register之后所有require并以.es6, .es, .jsx 和 .js为后缀的模块都会经过babel的转译。</p><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>它同样是引用了 <code>core-js</code> 和 <code>regenerator</code>，垫片支持是一样的。<code>babel-polyfill</code> 是为了模拟一个完整的ES2015 +环境，旨在用于应用程序而不是库/工具。<br>它会让我们程序的执行环境，模拟成完美支持 es6+ 的环境，毕竟无论是浏览器环境还是 node 环境对 <code>es6+</code> 的支持都不一样。它是以重载全局变量 （E.g: <code>Promise</code>）,还有原型和类上的静态方法（E.g：<code>Array.prototype.reduce/Array.form</code>），从而达到对 <code>es6+</code> 的支持。不同于 <code>babel-runtime</code> 的是，<code>babel-polyfill</code> 是一次性引入你的项目中的，就像是 React 包一样，同项目代码一起编译到生产环境。</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>要说 plugins 就不得不提 babel 编译的过程。babel 编译分为三步：</p><ol><li>parser：通过 babylon 解析成 AST。</li><li>transform[s]：All the plugins/presets ，进一步的做语法等自定义的转译，仍然是 AST。</li><li>generator： 最后通过 babel-generator 生成  output string。</li></ol><p>所以 plugins 是在第二步加强转译的，所以假如我们自己写个 plugin，应该就是对 ast 结构做一个遍历，操作。</p><h3 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h3><p>这个包引用了 <code>core-js</code> 和 <code>regenerator</code>，那么什么是 core-js 和 regenerator 呢。<br>首先我们要知道上面提到的 babel-core 是对语法进行 transform 的，但是它不支持 build-ints（Eg: <code>promise</code>，<code>Set</code>，<code>Map</code>），prototype function（Eg: <code>array.reduce</code>,<code>string.trim</code>），<code>class</code> <code>static function</code> （Eg：<code>Array.form</code>，<code>Object.assgin</code>），regenerator （Eg：<code>generator</code>，<code>async</code>）等等拓展的编译。所以才要用到 core-js 和 regenerator。</p><h4 id="core-js"><a href="#core-js" class="headerlink" title="core-js"></a>core-js</h4><p>core-js 是用于 JavaScript 的组合式标准化库，它包含 es5 （e.g: object.freeze）, es6的 promise，symbols, collections, iterators, typed arrays， es7+提案等等的 polyfills 实现。也就是说，它几乎包含了所有 JavaScript 最新标准的垫片。但是不包含 generator。 </p><h4 id="regenerator"><a href="#regenerator" class="headerlink" title="regenerator"></a>regenerator</h4><p>regenerator 实现了 generator/yeild， async/await。</p><h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="babel-plugin-transform-runtime"></a>babel-plugin-transform-runtime</h3><p>transform-runtime 是为了方便使用 babel-runtime 的，它会分析我们的 AST 中，是否有引用 babel-rumtime 中的垫片（通过映射关系），如果有，就会在当前模块顶部插入我们需要的垫片。</p><h2 id="transform-runtime-对比-babel-polyfill"><a href="#transform-runtime-对比-babel-polyfill" class="headerlink" title="transform-runtime 对比 babel-polyfill"></a>transform-runtime 对比 babel-polyfill</h2><p>其实通过上面的介绍我们已经了解他们是干什么的了，这里再稍微总结区分一下吧。我在这里把 babel-runtime 和 babel-plugin-transform-runtime 统称为 transform-runtime，因为一起用才比较好。</p><p>babel-polyfill 是当前环境注入这些 es6+ 标准的垫片，好处是引用一次，不再担心兼容，而且它就是全局下的包，代码的任何地方都可以使用。缺点也很明显，它可能会污染原生的一些方法而把原生的方法重写。如果当前项目已经有一个 polyfill 的包了，那你只能保留其一。而且一次性引入这么一个包，会大大增加体积。如果你只是用几个特性，就没必要了，如果你是开发较大的应用，而且会频繁使用新特性并考虑兼容，那就直接引入吧。<br>transform-runtime 是利用 plugin 自动识别并替换代码中的新特性，你不需要再引入，只需要装好 babel-runtime 和 配好 plugin 就可以了。好处是按需替换，检测到你需要哪个，就引入哪个 polyfill，如果只用了一部分，打包完的文件体积对比 babel-polyfill 会小很多。而且 transform-runtime 不会污染原生的对象，方法，也不会对其他 polyfill 产生影响。所以 transform-runtime 的方式更适合开发工具包，库，一方面是体积够小，另一方面是用户（开发者）不会因为引用了我们的工具，包而污染了全局的原生方法，产生副作用，还是应该留给用户自己去选择。缺点是随着应用的增大，相同的 polyfill 每个模块都要做重复的工作（检测，替换），虽然 polyfill 只是引用，编译效率不够高效。</p><h2 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h2><p>显然这样一个一个配置插件会非常的麻烦，为了方便，babel为我们提供了一个配置项叫做persets（预设）。</p><p>预设就是一系列插件的集合，</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h3><p>它能根据当前的运行环境，自动确定你需要的 plugins 和 polyfills。通过各个 es标准 feature 在不同浏览器以及 node 版本的支持情况，再去维护一个 feature 跟 plugins 之间的映射关系，最终确定需要的 plugins。</p><h4 id="preset-env-配置"><a href="#preset-env-配置" class="headerlink" title="preset-env 配置"></a>preset-env 配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"targets"</span>: &#123; <span class="comment">// 配支持的环境</span></span><br><span class="line">          <span class="string">"browsers"</span>: [ <span class="comment">// 浏览器</span></span><br><span class="line">            <span class="string">"last 2 versions"</span>,</span><br><span class="line">            <span class="string">"safari &gt;= 7"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="string">"node"</span>: <span class="string">"current"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"modules"</span>: <span class="literal">true</span>,  <span class="comment">//设置ES6 模块转译的模块格式 默认是 commonjs</span></span><br><span class="line">        <span class="string">"debug"</span>: <span class="literal">true</span>, <span class="comment">// debug，编译的时候 console</span></span><br><span class="line">        <span class="string">"useBuiltIns"</span>: <span class="literal">false</span>, <span class="comment">// 是否开启自动支持 polyfill</span></span><br><span class="line">        <span class="string">"include"</span>: [], <span class="comment">// 总是启用哪些 plugins</span></span><br><span class="line">        <span class="string">"exclude"</span>: []  <span class="comment">// 强制不启用哪些 plugins，用来防止某些插件被启用</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">"transform-react-jsx"</span> <span class="comment">//如果是需要支持 jsx 这个东西要单独装一下。</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>参考链接：</em><br><em><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md</a></em><br><em><a href="https://juejin.im/post/59ec657ef265da431b6c5b03#heading-4" target="_blank" rel="noopener">https://juejin.im/post/59ec657ef265da431b6c5b03#heading-4</a></em><br><em><a href="https://juejin.im/post/59b9ffa8f265da06710d8e89#heading-9" target="_blank" rel="noopener">https://juejin.im/post/59b9ffa8f265da06710d8e89#heading-9</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Babel-介绍&quot;&gt;&lt;a href=&quot;#Babel-介绍&quot; class=&quot;headerlink&quot; title=&quot;Babel 介绍&quot;&gt;&lt;/a&gt;Babel 介绍&lt;/h2&gt;&lt;p&gt;Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。&lt;br&gt;Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。&lt;/p&gt;
    
    </summary>
    
      <category term="Babel" scheme="http://www.goyth.com/categories/Babel/"/>
    
    
      <category term="Babel" scheme="http://www.goyth.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>抽象语法树AST介绍</title>
    <link href="http://www.goyth.com/2018/12/23/AST/"/>
    <id>http://www.goyth.com/2018/12/23/AST/</id>
    <published>2018-12-23T13:36:13.000Z</published>
    <updated>2019-07-20T07:58:54.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要了解AST"><a href="#为什么要了解AST" class="headerlink" title="为什么要了解AST"></a>为什么要了解AST</h2><p>如果你想了解 js 编译执行的原理，那么你就得了解 AST，目前前端常用的一些插件或者工具，比如说javascript转译、代码压缩、css预处理器、elint、pretiier等功能的实现，都是建立在 AST 的基础之上。</p><h2 id="JavaScript-编译执行流程"><a href="#JavaScript-编译执行流程" class="headerlink" title="JavaScript 编译执行流程"></a>JavaScript 编译执行流程</h2><p>js执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成token，之后再通过语法分析生成 AST（Abstract Syntax Tree），最后生成机器码执行。</p><a id="more"></a><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元，例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。词法分析器里，每个关键字是一个 Token ，每个标识符是一个 Token，每个操作符是一个 Token，每个标点符号也都是一个 Token。除此之外，还会过滤掉源程序中的注释和空白字符（换行符、空格、制表符等）。<br>最终，整个代码将被分割进一个tokens列表（或者说一维数组）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">n * n;</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>,  <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"*"</span>,  <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>,  <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每一个 type 有一组属性来描述该令牌：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#123;</span><br><span class="line">    label: <span class="string">'name'</span>,</span><br><span class="line">    keyword: <span class="literal">undefined</span>,</span><br><span class="line">    beforeExpr: <span class="literal">false</span>,</span><br><span class="line">    startsExpr: <span class="literal">true</span>,</span><br><span class="line">    rightAssociative: <span class="literal">false</span>,</span><br><span class="line">    isLoop: <span class="literal">false</span>,</span><br><span class="line">    isAssign: <span class="literal">false</span>,</span><br><span class="line">    prefix: <span class="literal">false</span>,</span><br><span class="line">    postfix: <span class="literal">false</span>,</span><br><span class="line">    binop: <span class="literal">null</span>,</span><br><span class="line">    updateContext: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析会将词法分析出来的 Token 转化成有语法含义的抽象语法树结构。同时，验证语法，语法如果有错的话，抛出语法错误。</p><h3 id="什么是AST（抽象语法树）"><a href="#什么是AST（抽象语法树）" class="headerlink" title="什么是AST（抽象语法树）"></a>什么是AST（抽象语法树）</h3><p>抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序可以被表示成如下的一棵树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- FunctionDeclaration:</span><br><span class="line">  - id:</span><br><span class="line">    - Identifier:</span><br><span class="line">      - name: square</span><br><span class="line">  - params [<span class="number">1</span>]</span><br><span class="line">    - Identifier</span><br><span class="line">      - name: n</span><br><span class="line">  - body:</span><br><span class="line">    - BlockStatement</span><br><span class="line">      - body [<span class="number">1</span>]</span><br><span class="line">        - ReturnStatement</span><br><span class="line">          - argument</span><br><span class="line">            - BinaryExpression</span><br><span class="line">              - operator: *</span><br><span class="line">              - left</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br><span class="line">              - right</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br></pre></td></tr></table></figure><p>或是如下所示的 JavaScript Object（对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"square"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  params: [&#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"n"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  body: &#123;</span><br><span class="line">    type: <span class="string">"BlockStatement"</span>,</span><br><span class="line">    body: [&#123;</span><br><span class="line">      type: <span class="string">"ReturnStatement"</span>,</span><br><span class="line">      argument: &#123;</span><br><span class="line">        type: <span class="string">"BinaryExpression"</span>,</span><br><span class="line">        operator: <span class="string">"*"</span>,</span><br><span class="line">        left: &#123;</span><br><span class="line">          type: <span class="string">"Identifier"</span>,</span><br><span class="line">          name: <span class="string">"n"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        right: &#123;</span><br><span class="line">          type: <span class="string">"Identifier"</span>,</span><br><span class="line">          name: <span class="string">"n"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会留意到 AST 的每一层都拥有相同的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">  id: &#123;...&#125;,</span><br><span class="line">  params: [...],</span><br><span class="line">  body: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"Identifier"</span>,</span><br><span class="line">  name: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"BinaryExpression"</span>,</span><br><span class="line">  operator: ...,</span><br><span class="line">  left: &#123;...&#125;,</span><br><span class="line">  right: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的每一层结构也被叫做 <strong>节点（Node）</strong>。 一个 AST 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。</p><p>每一个节点都有如下所示的接口（Interface）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Node &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字符串形式的 <code>type</code> 字段表示节点的类型（如： “<code>FunctionDeclaration</code>“，”<code>Identifier</code>“，或 “<code>BinaryExpression</code>“）。 每一种类型的节点定义了一些附加属性用来进一步描述该节点类型。</p><h3 id="AST-节点介绍"><a href="#AST-节点介绍" class="headerlink" title="AST 节点介绍"></a>AST 节点介绍</h3><h4 id="Identifier"><a href="#Identifier" class="headerlink" title="Identifier"></a>Identifier</h4><p>标识符，就是我们写 JS 时自定义的名称，如变量名，函数名，属性名，都归为标识符。相应的接口是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Identifier &lt;: Expression, Pattern &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个标识符可能是一个表达式，或者是解构的模式（ES6 中的解构语法）。我们等会会看到 <code>Expression</code> 和 <code>Pattern</code> 相关的内容的。</p><h4 id="Literal"><a href="#Literal" class="headerlink" title="Literal"></a>Literal</h4><p>字面量，这里不是指 <code>[]</code> 或者 <code>{}</code> 这些，而是本身语义就代表了一个值的字面量，如 <code>1</code>，<code>“hello”</code>, <code>true</code> 这些，还有正则表达式（有一个扩展的 Node 来表示正则表达式），如 <code>/\d?/</code>。我们看一下文档的定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Literal &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"Literal"</span>;</span><br><span class="line">    value: string | boolean | <span class="literal">null</span> | number | <span class="built_in">RegExp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里即对应了字面量的值，我们可以看出字面量值的类型，字符串，布尔，数值，null 和正则。</p><h4 id="RegExpLiteral"><a href="#RegExpLiteral" class="headerlink" title="RegExpLiteral"></a>RegExpLiteral</h4><p>这个针对正则字面量的，为了更好地来解析正则表达式的内容，添加多一个 <code>regex</code> 字段，里边会包括正则本身，以及正则的 <code>flags</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface RegExpLiteral &lt;: Literal &#123;</span><br><span class="line">  regex: &#123;</span><br><span class="line">    pattern: string;</span><br><span class="line">    flags: string;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h4><p>一般这个是作为跟节点的，即代表了一棵完整的程序代码树。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Program &lt;: Node &#123;</span><br><span class="line">    type: <span class="string">"Program"</span>;</span><br><span class="line">    body: [ Statement ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>body</code> 属性是一个数组，包含了多个 <code>Statement</code>（即语句）节点。</p><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>函数声明或者函数表达式节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="built_in">Function</span> &lt;: Node &#123;</span><br><span class="line">    id: Identifier | <span class="literal">null</span>;</span><br><span class="line">    params: [ Pattern ];</span><br><span class="line">    body: BlockStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>id</code> 是函数名，<code>params</code> 属性是一个数组，表示函数的参数。<code>body</code> 是一个块语句。<br>有一个值得留意的点是，你在测试过程中，是不会找到 <code>type: &quot;Function&quot;</code> 的节点的，但是你可以找到 <code>type: &quot;FunctionDeclaration&quot;</code> 和 <code>type: &quot;FunctionExpression&quot;</code>，因为函数要么以声明语句出现，要么以函数表达式出现，都是节点类型的组合类型，后边会再提及 <code>FunctionDeclaration</code> 和 <code>FunctionExpression</code> 的相关内容。<br>这让人感觉这个文档规划得蛮细致的，函数名，参数和函数块是属于函数部分的内容，而声明或者表达式则有它自己需要的东西。</p><h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>语句节点没什么特别的，它只是一个节点，一种区分，但是语句有很多种，下边会详述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Statement &lt;: Node &#123; &#125;ExpressionStatement</span><br></pre></td></tr></table></figure></p><h4 id="ExpressionStatement"><a href="#ExpressionStatement" class="headerlink" title="ExpressionStatement"></a>ExpressionStatement</h4><p>表达式语句节点，<code>a = a + 1</code> 或者 <code>a++</code> 里边会有一个 <code>expression</code> 属性指向一个表达式节点对象（后边会提及表达式）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ExpressionStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ExpressionStatement"</span>;</span><br><span class="line">    expression: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="BlockStatement"><a href="#BlockStatement" class="headerlink" title="BlockStatement"></a>BlockStatement</h4><p>块语句节点，举个例子：<code>if (...) { // 这里是块语句的内容 }</code>，块里边可以包含多个其他的语句，所以有一个 <code>body</code> 属性，是一个数组，表示了块里边的多个语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface BlockStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"BlockStatement"</span>;</span><br><span class="line">    body: [ Statement ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="EmptyStatement"><a href="#EmptyStatement" class="headerlink" title="EmptyStatement"></a>EmptyStatement</h4><p>一个空的语句节点，没有执行任何有用的代码，例如一个单独的分号 ;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface EmptyStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"EmptyStatement"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="DebuggerStatement"><a href="#DebuggerStatement" class="headerlink" title="DebuggerStatement"></a>DebuggerStatement</h4><p><code>debugger</code>，就是表示这个，没有其他了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface DebuggerStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"DebuggerStatement"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="WithStatement"><a href="#WithStatement" class="headerlink" title="WithStatement"></a>WithStatement</h4><p><code>with</code> 语句节点，里边有两个特别的属性，<code>object</code> 表示 <code>with</code> 要使用的那个对象（可以是一个表达式），<code>body</code> 则是对应 <code>with</code> 后边要执行的语句，一般会是一个块语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface WithStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"WithStatement"</span>;</span><br><span class="line">    object: Expression;</span><br><span class="line">    body: Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是控制流的语句：</p><h4 id="ReturnStatement"><a href="#ReturnStatement" class="headerlink" title="ReturnStatement"></a>ReturnStatement</h4><p>返回语句节点，<code>argument</code> 属性是一个表达式，代表返回的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ReturnStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ReturnStatement"</span>;</span><br><span class="line">    argument: Expression | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="LabeledStatement"><a href="#LabeledStatement" class="headerlink" title="LabeledStatement"></a>LabeledStatement</h4><p><code>label</code> 语句，平时可能会比较少接触到，举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop: <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; min; j++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 <code>loop</code> 就是一个 <code>label</code> 了，我们可以在循环嵌套中使用 <code>break loop</code> 来指定跳出哪个循环。所以这里的 <code>label</code> 语句指的就是 <code>loop: ...</code> 这个。<br>一个 <code>label</code> 语句节点会有两个属性，一个 <code>label</code> 属性表示 <code>label</code> 的名称，另外一个 <code>body</code> 属性指向对应的语句，通常是一个循环语句或者 <code>switch</code> 语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface LabeledStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"LabeledStatement"</span>;</span><br><span class="line">    label: Identifier;</span><br><span class="line">    body: Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="BreakStatement"><a href="#BreakStatement" class="headerlink" title="BreakStatement"></a>BreakStatement</h4><p><code>break</code> 语句节点，会有一个 <code>label</code> 属性表示需要的 <code>label</code> 名称，当不需要 <code>label</code> 的时候（通常都不需要），便是 <code>null</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface BreakStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"BreakStatement"</span>;</span><br><span class="line">    label: Identifier | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ContinueStatement"><a href="#ContinueStatement" class="headerlink" title="ContinueStatement"></a>ContinueStatement</h4><p><code>continue</code> 语句节点，和 <code>break</code> 类似。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ContinueStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ContinueStatement"</span>;</span><br><span class="line">    label: Identifier | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是条件语句：</p><h4 id="IfStatement"><a href="#IfStatement" class="headerlink" title="IfStatement"></a>IfStatement</h4><p><code>if</code> 语句节点，很常见，会带有三个属性，test 属性表示 <code>if (...)</code> 括号中的表达式。<br><code>consequent</code> 属性是表示条件为 <code>true</code> 时的执行语句，通常会是一个块语句。<br><code>alternate</code> 属性则是用来表示 <code>else</code> 后跟随的语句节点，通常也会是块语句，但也可以又是一个 <code>if</code> 语句节点，即类似这样的结构：<code>if (a) { //... } else if (b) { // ... }</code>。<code>alternate</code> 当然也可以为 <code>null</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IfStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"IfStatement"</span>;</span><br><span class="line">    test: Expression;</span><br><span class="line">    consequent: Statement;</span><br><span class="line">    alternate: Statement | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SwitchStatement"><a href="#SwitchStatement" class="headerlink" title="SwitchStatement"></a>SwitchStatement</h4><p><code>switch</code> 语句节点，有两个属性，<code>discriminant</code>属性表示 <code>switch</code> 语句后紧随的表达式，通常会是一个变量，<code>cases</code> 属性是一个 <code>case</code> 节点的数组，用来表示各个 <code>case</code> 语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SwitchStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"SwitchStatement"</span>;</span><br><span class="line">    discriminant: Expression;</span><br><span class="line">    cases: [ SwitchCase ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SwitchCase"><a href="#SwitchCase" class="headerlink" title="SwitchCase"></a>SwitchCase</h4><p><code>switch</code> 的 <code>case</code> 节点。<code>test</code> 属性代表这个 <code>case</code> 的判断表达式，<code>consequent</code> 则是这个 <code>case</code> 的执行语句。<br>当 <code>test</code> 属性是 <code>null</code> 时，则是表示 <code>default</code> 这个 <code>case</code> 节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SwitchCase &lt;: Node &#123;</span><br><span class="line">    type: <span class="string">"SwitchCase"</span>;</span><br><span class="line">    test: Expression | <span class="literal">null</span>;</span><br><span class="line">    consequent: [ Statement ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是异常相关的语句：</p><h4 id="ThrowStatement"><a href="#ThrowStatement" class="headerlink" title="ThrowStatement"></a>ThrowStatement</h4><p><code>throw</code> 语句节点，<code>argument</code> 属性用以表示 <code>throw</code> 后边紧跟的表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ThrowStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ThrowStatement"</span>;</span><br><span class="line">    argument: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TryStatement"><a href="#TryStatement" class="headerlink" title="TryStatement"></a>TryStatement</h4><p><code>try</code> 语句节点，<code>block</code> 属性表示 <code>try</code> 的执行语句，通常是一个块语句。<br><code>hanlder</code> 属性是指 <code>catch</code> 节点，<code>finalizer</code> 是指 <code>finally</code> 语句节点，当 <code>hanlder</code> 为 <code>null</code> 时，<code>finalizer</code> 必须是一个块语句节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface TryStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"TryStatement"</span>;</span><br><span class="line">    block: BlockStatement;</span><br><span class="line">    handler: CatchClause | <span class="literal">null</span>;</span><br><span class="line">    finalizer: BlockStatement | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="CatchClause"><a href="#CatchClause" class="headerlink" title="CatchClause"></a>CatchClause</h4><p><code>catch</code> 节点，<code>param</code> 用以表示 <code>catch</code> 后的参数，<code>body</code> 则表示 <code>catch</code> 后的执行语句，通常是一个块语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface CatchClause &lt;: Node &#123;</span><br><span class="line">    type: <span class="string">"CatchClause"</span>;</span><br><span class="line">    param: Pattern;</span><br><span class="line">    body: BlockStatement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是循环语句：</p><h4 id="WhileStatement"><a href="#WhileStatement" class="headerlink" title="WhileStatement"></a>WhileStatement</h4><p><code>while</code> 语句节点，<code>test</code> 表示括号中的表达式，<code>body</code> 是表示要循环执行的语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface WhileStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"WhileStatement"</span>;</span><br><span class="line">    test: Expression;</span><br><span class="line">    body: Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="DoWhileStatement"><a href="#DoWhileStatement" class="headerlink" title="DoWhileStatement"></a>DoWhileStatement</h4><p><code>do/while</code> 语句节点，和 <code>while</code> 语句类似。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface DoWhileStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"DoWhileStatement"</span>;</span><br><span class="line">    body: Statement;</span><br><span class="line">    test: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ForStatement"><a href="#ForStatement" class="headerlink" title="ForStatement"></a>ForStatement</h4><p><code>for</code> 循环语句节点，属性 <code>init/test/update</code> 分别表示了 <code>for</code> 语句括号中的三个表达式，初始化值，循环判断条件，每次循环执行的变量更新语句（<code>init</code> 可以是变量声明或者表达式）。这三个属性都可以为 <code>null</code>，即 <code>for(;;){}</code>。<code>body</code> 属性用以表示要循环执行的语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface ForStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ForStatement"</span>;</span><br><span class="line">    init: VariableDeclaration | Expression | <span class="literal">null</span>;</span><br><span class="line">    test: Expression | <span class="literal">null</span>;</span><br><span class="line">    update: Expression | <span class="literal">null</span>;</span><br><span class="line">    body: Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ForInStatement"><a href="#ForInStatement" class="headerlink" title="ForInStatement"></a>ForInStatement</h4><p><code>for/in</code> 语句节点，<code>left</code> 和 <code>right</code> 属性分别表示在 <code>in</code> 关键词左右的语句（左侧可以是一个变量声明或者表达式）。<code>body</code> 依旧是表示要循环执行的语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ForInStatement &lt;: Statement &#123;</span><br><span class="line">    type: <span class="string">"ForInStatement"</span>;</span><br><span class="line">    left: VariableDeclaration |  Pattern;</span><br><span class="line">    right: Expression;</span><br><span class="line">    body: Statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Declarations"><a href="#Declarations" class="headerlink" title="Declarations"></a>Declarations</h4><p>声明语句节点，同样也是语句，只是一个类型的细化。下边会介绍各种声明语句类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Declaration &lt;: Statement &#123; &#125;</span><br></pre></td></tr></table></figure></p><h4 id="FunctionDeclaration"><a href="#FunctionDeclaration" class="headerlink" title="FunctionDeclaration"></a>FunctionDeclaration</h4><p>函数声明，和之前提到的 <code>Function</code> 不同的是，<code>id</code> 不能为 <code>null</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface FunctionDeclaration &lt;: <span class="built_in">Function</span>, Declaration &#123;</span><br><span class="line">    type: <span class="string">"FunctionDeclaration"</span>;</span><br><span class="line">    id: Identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="VariableDeclaration"><a href="#VariableDeclaration" class="headerlink" title="VariableDeclaration"></a>VariableDeclaration</h4><p>变量声明，<code>kind</code> 属性表示是什么类型的声明，因为 ES6 引入了 <code>const/let</code>。<code>declarations</code>表示声明的多个描述，因为我们可以这样：<code>let a = 1, b = 2;</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface VariableDeclaration &lt;: Declaration &#123;</span><br><span class="line">    type: <span class="string">"VariableDeclaration"</span>;</span><br><span class="line">    declarations: [ VariableDeclarator ];</span><br><span class="line">    kind: <span class="string">"var"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="VariableDeclarator"><a href="#VariableDeclarator" class="headerlink" title="VariableDeclarator"></a>VariableDeclarator</h4><p>变量声明的描述，<code>id</code> 表示变量名称节点，<code>init</code> 表示初始值的表达式，可以为 <code>null</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface VariableDeclarator &lt;: Node &#123;</span><br><span class="line">    type: <span class="string">"VariableDeclarator"</span>;</span><br><span class="line">    id: Pattern;</span><br><span class="line">    init: Expression | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h4><p>表达式节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Expression &lt;: Node &#123; &#125;</span><br></pre></td></tr></table></figure></p><h4 id="ThisExpression"><a href="#ThisExpression" class="headerlink" title="ThisExpression"></a>ThisExpression</h4><p>表示 <code>this</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ThisExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"ThisExpression"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ArrayExpression"><a href="#ArrayExpression" class="headerlink" title="ArrayExpression"></a>ArrayExpression</h4><p>数组表达式节点，<code>elements</code> 属性是一个数组，表示数组的多个元素，每一个元素都是一个表达式节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ArrayExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"ArrayExpression"</span>;</span><br><span class="line">    elements: [ Expression | <span class="literal">null</span> ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ObjectExpression"><a href="#ObjectExpression" class="headerlink" title="ObjectExpression"></a>ObjectExpression</h4><p>对象表达式节点，<code>property</code> 属性是一个数组，表示对象的每一个键值对，每一个元素都是一个属性节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ObjectExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"ObjectExpression"</span>;</span><br><span class="line">    properties: [ Property ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p>对象表达式中的属性节点。<code>key</code> 表示键，<code>value</code> 表示值，由于 ES5 语法中有 <code>get/set</code> 的存在，所以有一个 <code>kind</code> 属性，用来表示是普通的初始化，或者是 <code>get/set</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Property &lt;: Node &#123;</span><br><span class="line">    type: <span class="string">"Property"</span>;</span><br><span class="line">    key: Literal | Identifier;</span><br><span class="line">    value: Expression;</span><br><span class="line">    kind: <span class="string">"init"</span> | <span class="string">"get"</span> | <span class="string">"set"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="FunctionExpression"><a href="#FunctionExpression" class="headerlink" title="FunctionExpression"></a>FunctionExpression</h4><p>函数表达式节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface FunctionExpression &lt;: <span class="built_in">Function</span>, Expression &#123;</span><br><span class="line">    type: <span class="string">"FunctionExpression"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是一元运算符相关的表达式部分：</p><h4 id="UnaryExpression"><a href="#UnaryExpression" class="headerlink" title="UnaryExpression"></a>UnaryExpression</h4><p>一元运算表达式节点（<code>++/--</code> 是 <code>update</code> 运算符，不在这个范畴内），<code>operator</code> 表示运算符，<code>prefix</code> 表示是否为前缀运算符。<code>argument</code> 是要执行运算的表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UnaryExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"UnaryExpression"</span>;</span><br><span class="line">    operator: UnaryOperator;</span><br><span class="line">    prefix: boolean;</span><br><span class="line">    argument: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UnaryOperator"><a href="#UnaryOperator" class="headerlink" title="UnaryOperator"></a>UnaryOperator</h4><p>一元运算符，枚举类型，所有值如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum UnaryOperator &#123;</span><br><span class="line">    <span class="string">"-"</span> | <span class="string">"+"</span> | <span class="string">"!"</span> | <span class="string">"~"</span> | <span class="string">"typeof"</span> | <span class="string">"void"</span> | <span class="string">"delete"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UpdateExpression"><a href="#UpdateExpression" class="headerlink" title="UpdateExpression"></a>UpdateExpression</h4><p><code>update</code> 运算表达式节点，即 <code>++/--</code>，和一元运算符类似，只是 <code>operator</code> 指向的节点对象类型不同，这里是 <code>update</code> 运算符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface UpdateExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"UpdateExpression"</span>;</span><br><span class="line">    operator: UpdateOperator;</span><br><span class="line">    argument: Expression;</span><br><span class="line">    prefix: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UpdateOperator"><a href="#UpdateOperator" class="headerlink" title="UpdateOperator"></a>UpdateOperator</h4><p><code>update</code> 运算符，值为 <code>++</code> 或 <code>--</code>，配合 <code>update</code> 表达式节点的 <code>prefix</code> 属性来表示前后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum UpdateOperator &#123;</span><br><span class="line">    <span class="string">"++"</span> | <span class="string">"--"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边是二元运算符相关的表达式部分：</p><h4 id="BinaryExpression"><a href="#BinaryExpression" class="headerlink" title="BinaryExpression"></a>BinaryExpression</h4><p>二元运算表达式节点，<code>left</code> 和 <code>right</code> 表示运算符左右的两个表达式，<code>operator</code> 表示一个二元运算符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface BinaryExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"BinaryExpression"</span>;</span><br><span class="line">    operator: BinaryOperator;</span><br><span class="line">    left: Expression;</span><br><span class="line">    right: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="BinaryOperator"><a href="#BinaryOperator" class="headerlink" title="BinaryOperator"></a>BinaryOperator</h4><p>二元运算符，所有值如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum BinaryOperator &#123;</span><br><span class="line">    <span class="string">"=="</span> | <span class="string">"!="</span> | <span class="string">"==="</span> | <span class="string">"!=="</span></span><br><span class="line">         | <span class="string">"&lt;"</span> | <span class="string">"&lt;="</span> | <span class="string">"&gt;"</span> | <span class="string">"&gt;="</span></span><br><span class="line">         | <span class="string">"&lt;&lt;"</span> | <span class="string">"&gt;&gt;"</span> | <span class="string">"&gt;&gt;&gt;"</span></span><br><span class="line">         | <span class="string">"+"</span> | <span class="string">"-"</span> | <span class="string">"*"</span> | <span class="string">"/"</span> | <span class="string">"%"</span></span><br><span class="line">         | <span class="string">"|"</span> | <span class="string">"^"</span> | <span class="string">"&amp;"</span> | <span class="string">"in"</span></span><br><span class="line">         | <span class="string">"instanceof"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AssignmentExpression"><a href="#AssignmentExpression" class="headerlink" title="AssignmentExpression"></a>AssignmentExpression</h4><p>赋值表达式节点，<code>operator</code> 属性表示一个赋值运算符，<code>left</code> 和 <code>right</code> 是赋值运算符左右的表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface AssignmentExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"AssignmentExpression"</span>;</span><br><span class="line">    operator: AssignmentOperator;</span><br><span class="line">    left: Pattern | Expression;</span><br><span class="line">    right: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AssignmentOperator"><a href="#AssignmentOperator" class="headerlink" title="AssignmentOperator"></a>AssignmentOperator</h4><p>赋值运算符，所有值如下：（常用的并不多）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum AssignmentOperator &#123;</span><br><span class="line">    <span class="string">"="</span> | <span class="string">"+="</span> | <span class="string">"-="</span> | <span class="string">"*="</span> | <span class="string">"/="</span> | <span class="string">"%="</span></span><br><span class="line">        | <span class="string">"&lt;&lt;="</span> | <span class="string">"&gt;&gt;="</span> | <span class="string">"&gt;&gt;&gt;="</span></span><br><span class="line">        | <span class="string">"|="</span> | <span class="string">"^="</span> | <span class="string">"&amp;="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="LogicalExpression"><a href="#LogicalExpression" class="headerlink" title="LogicalExpression"></a>LogicalExpression</h4><p>逻辑运算表达式节点，和赋值或者二元运算类型，只不过 <code>operator</code> 是逻辑运算符类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface LogicalExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"LogicalExpression"</span>;</span><br><span class="line">    operator: LogicalOperator;</span><br><span class="line">    left: Expression;</span><br><span class="line">    right: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="LogicalOperator"><a href="#LogicalOperator" class="headerlink" title="LogicalOperator"></a>LogicalOperator</h4><p>逻辑运算符，两种值，即<code>与</code> <code>或</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum LogicalOperator &#123;</span><br><span class="line">    <span class="string">"||"</span> | <span class="string">"&amp;&amp;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="MemberExpression"><a href="#MemberExpression" class="headerlink" title="MemberExpression"></a>MemberExpression</h4><p>成员表达式节点，即表示引用对象成员的语句，<code>object</code> 是引用对象的表达式节点，<code>property</code> 是表示属性名称，<code>computed</code> 如果为 <code>false</code>，是表示 <code>.</code> 来引用成员，<code>property</code> 应该为一个 <code>Identifier</code> 节点，如果 <code>computed</code> 属性为 <code>true</code>，则是 <code>[]</code> 来进行引用，即 <code>property</code> 是一个 <code>Expression</code> 节点，名称是表达式的结果值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface MemberExpression &lt;: Expression, Pattern &#123;</span><br><span class="line">    type: <span class="string">"MemberExpression"</span>;</span><br><span class="line">    object: Expression;</span><br><span class="line">    property: Expression;</span><br><span class="line">    computed: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下边是其他的一些表达式：</p><h4 id="ConditionalExpression"><a href="#ConditionalExpression" class="headerlink" title="ConditionalExpression"></a>ConditionalExpression</h4><p>条件表达式，通常我们称之为三元运算表达式，即 <code>boolean ? true : false</code>。属性参考条件语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ConditionalExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"ConditionalExpression"</span>;</span><br><span class="line">    test: Expression;</span><br><span class="line">    alternate: Expression;</span><br><span class="line">    consequent: Expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="CallExpression"><a href="#CallExpression" class="headerlink" title="CallExpression"></a>CallExpression</h4><p>函数调用表达式，即表示了 <code>func(1, 2)</code> 这一类型的语句。callee 属性是一个表达式节点，表示函数，arguments 是一个数组，元素是表达式节点，表示函数参数列表。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface CallExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"CallExpression"</span>;</span><br><span class="line">    callee: Expression;</span><br><span class="line">    <span class="built_in">arguments</span>: [ Expression ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NewExpression"><a href="#NewExpression" class="headerlink" title="NewExpression"></a>NewExpression</h4><p><code>new</code> 表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface NewExpression &lt;: CallExpression &#123;</span><br><span class="line">    type: <span class="string">"NewExpression"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SequenceExpression"><a href="#SequenceExpression" class="headerlink" title="SequenceExpression"></a>SequenceExpression</h4><p>这个就是逗号运算符构建的表达式（不知道确切的名称），<code>expressions</code> 属性为一个数组，即表示构成整个表达式，被逗号分割的多个表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SequenceExpression &lt;: Expression &#123;</span><br><span class="line">    type: <span class="string">"SequenceExpression"</span>;</span><br><span class="line">    expressions: [ Expression ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>参考链接：</em><br><em><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md</a></em><br><em><a href="https://github.com/CodeLittlePrince/blog/issues/19" target="_blank" rel="noopener">https://github.com/CodeLittlePrince/blog/issues/19</a></em><br><em><a href="https://juejin.im/post/582425402e958a129926fcb4" target="_blank" rel="noopener">https://juejin.im/post/582425402e958a129926fcb4</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要了解AST&quot;&gt;&lt;a href=&quot;#为什么要了解AST&quot; class=&quot;headerlink&quot; title=&quot;为什么要了解AST&quot;&gt;&lt;/a&gt;为什么要了解AST&lt;/h2&gt;&lt;p&gt;如果你想了解 js 编译执行的原理，那么你就得了解 AST，目前前端常用的一些插件或者工具，比如说javascript转译、代码压缩、css预处理器、elint、pretiier等功能的实现，都是建立在 AST 的基础之上。&lt;/p&gt;
&lt;h2 id=&quot;JavaScript-编译执行流程&quot;&gt;&lt;a href=&quot;#JavaScript-编译执行流程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 编译执行流程&quot;&gt;&lt;/a&gt;JavaScript 编译执行流程&lt;/h2&gt;&lt;p&gt;js执行的第一步是读取 js 文件中的字符流，然后通过词法分析生成token，之后再通过语法分析生成 AST（Abstract Syntax Tree），最后生成机器码执行。&lt;/p&gt;
    
    </summary>
    
      <category term="AST" scheme="http://www.goyth.com/categories/AST/"/>
    
    
      <category term="AST" scheme="http://www.goyth.com/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>webpack 打包构建流程分析整理</title>
    <link href="http://www.goyth.com/2018/12/10/webpackFlow/"/>
    <id>http://www.goyth.com/2018/12/10/webpackFlow/</id>
    <published>2018-12-10T13:22:43.000Z</published>
    <updated>2018-12-23T13:35:44.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何调试-webpack"><a href="#如何调试-webpack" class="headerlink" title="如何调试 webpack"></a>如何调试 webpack</h2><p>require(加载) node_modules/webpack-cli/bin 目录下的cli.js，预先设置debugger（断点），然后开启调试模式。</p><h3 id="debugger-js"><a href="#debugger-js" class="headerlink" title="debugger.js"></a>debugger.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpackPath=<span class="built_in">require</span>(<span class="string">'path'</span>).resolve(__dirname,<span class="string">'node_modules'</span>, <span class="string">'webpack-cli'</span>, <span class="string">'bin'</span>, <span class="string">'cli.js'</span>);</span><br><span class="line"><span class="built_in">require</span>(webpackPath);</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    mode:<span class="string">"development"</span>,</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-主要工作流程"><a href="#webpack-主要工作流程" class="headerlink" title="webpack 主要工作流程"></a>webpack 主要工作流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件</li><li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li><strong>完成模块编译</strong>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><a id="more"></a><h2 id="webpack打包流程图"><a href="#webpack打包流程图" class="headerlink" title="webpack打包流程图"></a>webpack打包流程图</h2><p><img src="/2018/12/10/webpackFlow/webpack2.svg" alt=""></p><h2 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><table><thead><tr><th style="text-align:left">事件名</th><th style="text-align:left">解释</th><th style="text-align:left">代码位置</th></tr></thead><tbody><tr><td style="text-align:left">读取命令行参数&ensp;</td><td style="text-align:left">从命令行中读取用户输入的参数</td><td style="text-align:left">require(“./convert-argv”)(argv)</td></tr><tr><td style="text-align:left">实例化 Compiler</td><td style="text-align:left">1.用上一步得到的参数初始Compiler 实例 <br>2.Compiler 负责文件监听和启动编译 <br>3.Compiler 实例中包含了完整的<br> Webpack 配置，全局只有一个 Compiler 实例。</td><td style="text-align:left">compiler = webpack(options);</td></tr><tr><td style="text-align:left">加载插件</td><td style="text-align:left">1.依次调用插件的 apply 方法，<br>让插件可以监听后续的所有事件节点。<br>同时给插件传入 compiler 实例的引用，<br>以方便插件通过 compiler 调用 <br>Webpack 提供的 API。</td><td style="text-align:left">plugin.apply(compiler)</td></tr><tr><td style="text-align:left">处理入口</td><td style="text-align:left">读取配置的 Entrys，为每个 Entry 实例化<br>一个对应的 EntryPlugin，为后面该 <br>Entry 的递归解析工作做准备</td><td style="text-align:left">new EntryOptionPlugin().apply(compiler) <br>new SingleEntryPlugin(context, item, name) <br>compiler.hooks.make.tapAsync</td></tr></tbody></table><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><table><thead><tr><th style="text-align:left">事件名</th><th style="text-align:left">解释</th><th style="text-align:left">代码位置</th></tr></thead><tbody><tr><td style="text-align:left">run</td><td style="text-align:left">启动一次新的编译</td><td style="text-align:left">this.hooks.run.callAsync</td></tr><tr><td style="text-align:left">compile</td><td style="text-align:left">该事件是为了告诉插件一次新的编译将要启动，同时会给插件传入compiler 对象。</td><td style="text-align:left">compile(callback)</td></tr><tr><td style="text-align:left">compilation</td><td style="text-align:left">当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation 对象也提供了很多事件回调供插件做扩展。</td><td style="text-align:left">newCompilation(params)</td></tr><tr><td style="text-align:left">make</td><td style="text-align:left">一个新的 Compilation 创建完毕主开始编译</td><td style="text-align:left">this.hooks.make.callAsync</td></tr><tr><td style="text-align:left">addEntry</td><td style="text-align:left">即将从 Entry 开始读取文件</td><td style="text-align:left">compilation.addEntry <br> this._addModuleChain</td></tr><tr><td style="text-align:left">moduleFactory</td><td style="text-align:left">创建模块工厂</td><td style="text-align:left">const moduleFactory = this.dependencyFactories.get(Dep)</td></tr><tr><td style="text-align:left">create</td><td style="text-align:left">创建模块</td><td style="text-align:left">moduleFactory.create</td></tr><tr><td style="text-align:left">factory</td><td style="text-align:left">开始创建模块</td><td style="text-align:left">factory(result, (err, module) <br> resolver(result) this.hooks.resolver.tap(“NormalModuleFactory”)</td></tr><tr><td style="text-align:left">resolveRequestArray</td><td style="text-align:left">解析loader路径</td><td style="text-align:left">resolveRequestArray</td></tr><tr><td style="text-align:left">resolve</td><td style="text-align:left">解析资源文件路径</td><td style="text-align:left">resolve</td></tr><tr><td style="text-align:left">userRequest</td><td style="text-align:left">得到包括loader在内的资源文件的绝对路径用!拼起来的字符串</td><td style="text-align:left">userRequest</td></tr><tr><td style="text-align:left">ruleSet.exec</td><td style="text-align:left">它可以根据模块路径名，匹配出模块所需的loader</td><td style="text-align:left">this.ruleSet.exec</td></tr><tr><td style="text-align:left">_run</td><td style="text-align:left">它可以根据模块路径名，匹配出模块所需的loader</td><td style="text-align:left">_run</td></tr><tr><td style="text-align:left">loaders</td><td style="text-align:left">得到所有的loader数组</td><td style="text-align:left">results[0].concat(loaders, results[1], results[2])</td></tr><tr><td style="text-align:left">getParser</td><td style="text-align:left">获取AST解析器</td><td style="text-align:left">this.getParser(type, settings.parser)</td></tr><tr><td style="text-align:left">buildModule</td><td style="text-align:left">开始编译模块</td><td style="text-align:left">this.buildModule(module) <br>buildModule(module, optional, origin,dependencies, thisCallback)</td></tr><tr><td style="text-align:left">build</td><td style="text-align:left">开始真正编译入口模块</td><td style="text-align:left">build(options)</td></tr><tr><td style="text-align:left">doBuild</td><td style="text-align:left">开始真正编译入口模块</td><td style="text-align:left">doBuild</td></tr><tr><td style="text-align:left">执行loader</td><td style="text-align:left">使用loader进行转换</td><td style="text-align:left">runLoaders <br> runLoaders</td></tr><tr><td style="text-align:left">iteratePitchingLoaders</td><td style="text-align:left">开始递归执行pitch loader</td><td style="text-align:left">iteratePitchingLoaders</td></tr><tr><td style="text-align:left">loadLoader</td><td style="text-align:left">加载loader</td><td style="text-align:left">loadLoader</td></tr><tr><td style="text-align:left">runSyncOrAsync</td><td style="text-align:left">执行pitchLoader</td><td style="text-align:left">runSyncOrAsync</td></tr><tr><td style="text-align:left">processResource</td><td style="text-align:left">开始处理资源</td><td style="text-align:left">processResource<br>options.readResource<br>iterateNormalLoaders<br>iterateNormalLoaders</td></tr><tr><td style="text-align:left">createSource</td><td style="text-align:left">创建源代码对象</td><td style="text-align:left">this.createSource</td></tr><tr><td style="text-align:left">parse</td><td style="text-align:left">使用parser转换抽象语法树</td><td style="text-align:left">this.parser.parse</td></tr><tr><td style="text-align:left">parse</td><td style="text-align:left">解析抽象语法树</td><td style="text-align:left">parse(source, initialState)</td></tr><tr><td style="text-align:left">acorn.parse</td><td style="text-align:left">解析语法树</td><td style="text-align:left">acorn.parse(code, parserOptions)</td></tr><tr><td style="text-align:left">ImportDependency</td><td style="text-align:left">遍历并添加添加依赖</td><td style="text-align:left">parser.state.module.addDependency(clearDep)</td></tr><tr><td style="text-align:left">succeedModule</td><td style="text-align:left">生成语法树后就表示一个模块编译完成</td><td style="text-align:left">this.hooks.succeedModule.call(module)</td></tr><tr><td style="text-align:left">processModuleDependencies</td><td style="text-align:left">递归编译依赖的模块</td><td style="text-align:left">this.processModuleDependencies(module)<br>processModuleDependencies(module, callback)<br>this.addModuleDependencies<br>buildModule</td></tr><tr><td style="text-align:left">make后</td><td style="text-align:left">结束make</td><td style="text-align:left">this.hooks.make.callAsync(compilation, err =&gt; {}</td></tr><tr><td style="text-align:left">finish</td><td style="text-align:left">编译完成</td><td style="text-align:left">compilation.finish();</td></tr></tbody></table><h3 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h3><table><thead><tr><th style="text-align:left">事件名</th><th style="text-align:left">解释</th><th style="text-align:left">代码</th></tr></thead><tbody><tr><td style="text-align:left">seal</td><td style="text-align:left">封装</td><td style="text-align:left">compilation.seal <br> seal(callback)</td></tr><tr><td style="text-align:left">addChunk</td><td style="text-align:left">生成资源</td><td style="text-align:left">addChunk(name)</td></tr><tr><td style="text-align:left">createChunkAssets</td><td style="text-align:left">创建资源</td><td style="text-align:left">this.createChunkAssets()</td></tr><tr><td style="text-align:left">getRenderManifest</td><td style="text-align:left">获得要渲染的描述文件</td><td style="text-align:left">getRenderManifest(options)</td></tr><tr><td style="text-align:left">render</td><td style="text-align:left">渲染源码</td><td style="text-align:left">source = fileManifest.render();</td></tr><tr><td style="text-align:left">afterCompile</td><td style="text-align:left">编译结束</td><td style="text-align:left">this.hooks.afterCompile</td></tr><tr><td style="text-align:left">shouldEmit</td><td style="text-align:left">所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td><td style="text-align:left">this.hooks.shouldEmit</td></tr><tr><td style="text-align:left">emit</td><td style="text-align:left">确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td><td style="text-align:left">this.emitAssets(compilation) <br>this.hooks.emit.callAsync <br>const emitFiles = err<br>this.outputFileSystem.writeFile</td></tr><tr><td style="text-align:left">this.emitRecords</td><td style="text-align:left">写入记录</td><td style="text-align:left">this.emitRecords</td></tr><tr><td style="text-align:left">done</td><td style="text-align:left">全部完成</td><td style="text-align:left">this.hooks.done.callAsync</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何调试-webpack&quot;&gt;&lt;a href=&quot;#如何调试-webpack&quot; class=&quot;headerlink&quot; title=&quot;如何调试 webpack&quot;&gt;&lt;/a&gt;如何调试 webpack&lt;/h2&gt;&lt;p&gt;require(加载) node_modules/webpack-cli/bin 目录下的cli.js，预先设置debugger（断点），然后开启调试模式。&lt;/p&gt;
&lt;h3 id=&quot;debugger-js&quot;&gt;&lt;a href=&quot;#debugger-js&quot; class=&quot;headerlink&quot; title=&quot;debugger.js&quot;&gt;&lt;/a&gt;debugger.js&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; webpackPath=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;path&#39;&lt;/span&gt;).resolve(__dirname,&lt;span class=&quot;string&quot;&gt;&#39;node_modules&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;webpack-cli&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;bin&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;cli.js&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(webpackPath);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;webpack-config-js&quot;&gt;&lt;a href=&quot;#webpack-config-js&quot; class=&quot;headerlink&quot; title=&quot;webpack.config.js&quot;&gt;&lt;/a&gt;webpack.config.js&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; path=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;path&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mode:&lt;span class=&quot;string&quot;&gt;&quot;development&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entry: &lt;span class=&quot;string&quot;&gt;&#39;./src/index.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        path: path.resolve(__dirname,&lt;span class=&quot;string&quot;&gt;&#39;dist&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filename:&lt;span class=&quot;string&quot;&gt;&#39;bundle.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;webpack-主要工作流程&quot;&gt;&lt;a href=&quot;#webpack-主要工作流程&quot; class=&quot;headerlink&quot; title=&quot;webpack 主要工作流程&quot;&gt;&lt;/a&gt;webpack 主要工作流程&lt;/h2&gt;&lt;p&gt;Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始化参数&lt;/strong&gt;：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开始编译&lt;/strong&gt;：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译模块&lt;/strong&gt;：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成模块编译&lt;/strong&gt;：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出资源&lt;/strong&gt;：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出完成&lt;/strong&gt;：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。&lt;/p&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://www.goyth.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://www.goyth.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript垃圾回收机制与内存泄漏</title>
    <link href="http://www.goyth.com/2018/12/02/V8GC/"/>
    <id>http://www.goyth.com/2018/12/02/V8GC/</id>
    <published>2018-12-02T05:46:27.000Z</published>
    <updated>2018-12-02T09:11:02.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-垃圾收集"><a href="#JavaScript-垃圾收集" class="headerlink" title="JavaScript 垃圾收集"></a>JavaScript 垃圾收集</h2><ul><li>程序的运行需要分配内存，内存资源是有限的，当程序运行结束后，就应该回收其内存资源。JavaScript使用自动内存管理，也称为垃圾回收机制（garbage collector）</li><li>自动垃圾回收的优点是可以简化开发，不用时刻惦记着回收不再使用的变量，降低内存泄漏的可能性；缺点是无法完全的掌握内存的分配以及回收的具体过程。</li></ul><h2 id="V8引擎垃圾回收机制"><a href="#V8引擎垃圾回收机制" class="headerlink" title="V8引擎垃圾回收机制"></a>V8引擎垃圾回收机制</h2><p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p><a id="more"></a><h2 id="V8的分代内存"><a href="#V8的分代内存" class="headerlink" title="V8的分代内存"></a>V8的分代内存</h2><p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p><p><img src="/2018/12/02/V8GC/v8space.png" alt=""></p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p><h3 id="新生代的垃圾回收算法"><a href="#新生代的垃圾回收算法" class="headerlink" title="新生代的垃圾回收算法"></a>新生代的垃圾回收算法</h3><p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p><p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p><p>具体的执行过程大致是这样：</p><p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了</p><p>举个栗子，如果有类似如下的引用情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          +----- A对象</span><br><span class="line">          |</span><br><span class="line">根对象----+----- B对象 ------ E对象</span><br><span class="line">          |</span><br><span class="line">          +----- C对象 ----+---- F对象 </span><br><span class="line">                           |</span><br><span class="line">                           +---- G对象 ----- H对象</span><br><span class="line"></span><br><span class="line">    D对象</span><br></pre></td></tr></table></figure></p><p>在执行Scavenge之前，From区长这幅模样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+---+---+---+---+---+---+---+---+--------+</span><br><span class="line">| A | B | C | D | E | F | G | H |        |</span><br><span class="line">+---+---+---+---+---+---+---+---+--------+</span><br></pre></td></tr></table></figure></p><p>那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">          allocationPtr</span><br><span class="line">             ↓ </span><br><span class="line">+---+---+---+----------------------------+</span><br><span class="line">| A | B | C |                            |</span><br><span class="line">+---+---+---+----------------------------+</span><br><span class="line"> ↑</span><br><span class="line">scanPtr</span><br></pre></td></tr></table></figure></p><p>接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          allocationPtr</span><br><span class="line">             ↓ </span><br><span class="line">+---+---+---+----------------------------+</span><br><span class="line">| A | B | C |                            |</span><br><span class="line">+---+---+---+----------------------------+</span><br><span class="line">     ↑</span><br><span class="line">  scanPtr</span><br></pre></td></tr></table></figure></p><p>接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            allocationPtr</span><br><span class="line">                 ↓ </span><br><span class="line">+---+---+---+---+------------------------+</span><br><span class="line">| A | B | C | E |                        |</span><br><span class="line">+---+---+---+---+------------------------+</span><br><span class="line">     ↑</span><br><span class="line">  scanPtr</span><br></pre></td></tr></table></figure></p><p>B对象里所有指针都已被复制完，所以移动scanPtr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            allocationPtr</span><br><span class="line">                 ↓ </span><br><span class="line">+---+---+---+---+------------------------+</span><br><span class="line">| A | B | C | E |                        |</span><br><span class="line">+---+---+---+---+------------------------+</span><br><span class="line">         ↑</span><br><span class="line">      scanPtr</span><br></pre></td></tr></table></figure></p><p>接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                allocationPtr</span><br><span class="line">                     ↓ </span><br><span class="line">+---+---+---+---+---+--------------------+</span><br><span class="line">| A | B | C | E | F |                    |</span><br><span class="line">+---+---+---+---+---+--------------------+</span><br><span class="line">         ↑</span><br><span class="line">      scanPtr</span><br></pre></td></tr></table></figure></p><p>然后复制G对象到To区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                    allocationPtr</span><br><span class="line">                         ↓ </span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">| A | B | C | E | F | G |                |</span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">         ↑</span><br><span class="line">      scanPtr</span><br></pre></td></tr></table></figure></p><p>这样C对象内部的指针已经复制完成了，移动scanPtr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                    allocationPtr</span><br><span class="line">                         ↓ </span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">| A | B | C | E | F | G |                |</span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">             ↑</span><br><span class="line">          scanPtr</span><br></pre></td></tr></table></figure></p><p>逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                    allocationPtr</span><br><span class="line">                         ↓ </span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">| A | B | C | E | F | G |                |</span><br><span class="line">+---+---+---+---+---+---+----------------+</span><br><span class="line">                     ↑</span><br><span class="line">                  scanPtr</span><br></pre></td></tr></table></figure></p><p>扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        allocationPtr</span><br><span class="line">                             ↓</span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br><span class="line">| A | B | C | E | F | G | H |            |</span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br><span class="line">                     ↑</span><br><span class="line">                  scanPtr</span><br></pre></td></tr></table></figure></p><p>完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                        allocationPtr</span><br><span class="line">                             ↓ </span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br><span class="line">| A | B | C | E | F | G | H |            |</span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br><span class="line">                             ↑</span><br><span class="line">                           scanPtr</span><br></pre></td></tr></table></figure></p><p>此时scanPtr和allocationPtr重合，说明复制结束</p><p>可以对比一下From区和To区在复制完成后的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//From区</span><br><span class="line">+---+---+---+---+---+---+---+---+--------+</span><br><span class="line">| A | B | C | D | E | F | G | H |        |</span><br><span class="line">+---+---+---+---+---+---+---+---+--------+</span><br><span class="line">//To区</span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br><span class="line">| A | B | C | E | F | G | H |            |</span><br><span class="line">+---+---+---+---+---+---+---+------------+</span><br></pre></td></tr></table></figure></p><p>D对象没有被复制，它将被作为垃圾进行回收</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p><h3 id="对象的晋升"><a href="#对象的晋升" class="headerlink" title="对象的晋升"></a>对象的晋升</h3><p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：</p><ol><li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li><li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li></ol><h2 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h2><h3 id="老生代的特点"><a href="#老生代的特点" class="headerlink" title="老生代的特点"></a>老生代的特点</h3><p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p><h3 id="老生代的垃圾回收算法"><a href="#老生代的垃圾回收算法" class="headerlink" title="老生代的垃圾回收算法"></a>老生代的垃圾回收算法</h3><p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用<code>Scavenge</code>算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长。所以<code>Scavenge</code>算法显然不适合。V8在老生代中的垃圾回收策略采用<code>Mark-Sweep</code>和<code>Mark-Compact</code>相结合</p><h4 id="Mark-Sweep（标记清除）"><a href="#Mark-Sweep（标记清除）" class="headerlink" title="Mark-Sweep（标记清除）"></a>Mark-Sweep（标记清除）</h4><p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段总，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p><p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p><h4 id="Mark-Compact（标记整理）"><a href="#Mark-Compact（标记整理）" class="headerlink" title="Mark-Compact（标记整理）"></a>Mark-Compact（标记整理）</h4><p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p><h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p><p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：</p><ul><li>如果一个对象为白对象，它还没未被垃圾回收器发现</li><li>如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li><li>如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了</li></ul><p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象，将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p><p>清除和紧缩阶段都是以内存页为单位回收内存</p><p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p><p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p><h4 id="结合使用标记清除和标记整理"><a href="#结合使用标记清除和标记整理" class="headerlink" title="结合使用标记清除和标记整理"></a>结合使用标记清除和标记整理</h4><p>V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p><h3 id="V8的优化"><a href="#V8的优化" class="headerlink" title="V8的优化"></a>V8的优化</h3><h4 id="Incremental-Marking（增量标记）"><a href="#Incremental-Marking（增量标记）" class="headerlink" title="Incremental Marking（增量标记）"></a>Incremental Marking（增量标记）</h4><p>由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右</p><h4 id="惰性清理"><a href="#惰性清理" class="headerlink" title="惰性清理"></a>惰性清理</h4><p>由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>V8后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收时就会产生内存泄漏</p><h3 id="四种类型的常见-JavaScript-内存泄漏"><a href="#四种类型的常见-JavaScript-内存泄漏" class="headerlink" title="四种类型的常见 JavaScript 内存泄漏"></a>四种类型的常见 JavaScript 内存泄漏</h3><h4 id="1-意外的全局变量"><a href="#1-意外的全局变量" class="headerlink" title="1. 意外的全局变量"></a>1. 意外的全局变量</h4><p>JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 <code>window</code> 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"this is a hidden global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真相是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.bar = <span class="string">"this is an explicit global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数 <code>foo</code> 内部忘记使用 <code>var</code> ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。</p><p>另一种意外的全局变量可能由 <code>this</code> 创建：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="comment">// 而不是 undefined</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。</p><p><strong>全局变量注意事项</strong></p><p>尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。</p><h4 id="2-被遗忘的计时器或回调函数"><a href="#2-被遗忘的计时器或回调函数" class="headerlink" title="2. 被遗忘的计时器或回调函数"></a>2. 被遗忘的计时器或回调函数</h4><p>在 JavaScript 中使用 <code>setInterval</code> 非常平常。一段常见的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，<code>someResource</code> 如果存储了大量的数据，也是无法被回收的。</p><p>对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。</p><p>观察者代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    element.innerHTML = <span class="string">'text'</span>;</span><br><span class="line">&#125;</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</span><br></pre></td></tr></table></figure></p><p><strong>对象观察者和循环引用注意事项</strong></p><p>老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 <code>removeEventListener</code> 了。</p><h4 id="3-脱离-DOM-的引用"><a href="#3-脱离-DOM-的引用" class="headerlink" title="3. 脱离 DOM 的引用"></a>3. 脱离 DOM 的引用</h4><p>有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">    button.click();</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">    <span class="comment">// 更多逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 按钮是 body 的后代元素</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line">    <span class="comment">// 此时，仍旧存在一个全局的 #button 的引用</span></span><br><span class="line">    <span class="comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code>是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h4><p>闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。</p><p>代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>代码片段做了一件事情：每次调用 <code>replaceThing</code> ，<code>theThing</code> 得到一个包含一个大数组和一个新闭包（<code>someMethod</code>）的新对象。同时，变量 <code>unused</code> 是一个引用 <code>originalThing</code> 的闭包（先前的 <code>replaceThing</code> 又调用了 <code>theThing</code> ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。<code>someMethod</code> 可以通过 <code>theThing</code> 使用，<code>someMethod</code> 与 <code>unused</code> 分享闭包作用域，尽管 <code>unused</code> 从未使用，它引用的 <code>originalThing</code> 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（<code>GC</code>）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。</p><p><em>参考链接：<a href="https://segmentfault.com/a/1190000000440270" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000440270</a></em><br><em><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-垃圾收集&quot;&gt;&lt;a href=&quot;#JavaScript-垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 垃圾收集&quot;&gt;&lt;/a&gt;JavaScript 垃圾收集&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序的运行需要分配内存，内存资源是有限的，当程序运行结束后，就应该回收其内存资源。JavaScript使用自动内存管理，也称为垃圾回收机制（garbage collector）&lt;/li&gt;
&lt;li&gt;自动垃圾回收的优点是可以简化开发，不用时刻惦记着回收不再使用的变量，降低内存泄漏的可能性；缺点是无法完全的掌握内存的分配以及回收的具体过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;V8引擎垃圾回收机制&quot;&gt;&lt;a href=&quot;#V8引擎垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;V8引擎垃圾回收机制&quot;&gt;&lt;/a&gt;V8引擎垃圾回收机制&lt;/h2&gt;&lt;p&gt;自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="垃圾回收" scheme="http://www.goyth.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="内存泄漏" scheme="http://www.goyth.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webpack 配置详解</title>
    <link href="http://www.goyth.com/2018/11/17/webpackConfig/"/>
    <id>http://www.goyth.com/2018/11/17/webpackConfig/</id>
    <published>2018-11-17T09:05:47.000Z</published>
    <updated>2018-11-17T15:23:47.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是WebPack"><a href="#什么是WebPack" class="headerlink" title="什么是WebPack"></a>什么是WebPack</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><a id="more"></a><p>构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。</p><ul><li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li><li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li><li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li><strong>自动发布</strong>：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。</p><h2 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h2><ul><li><strong>Entry</strong>：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</li><li><strong>Module</strong>：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li><strong>Chunk</strong>：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li><strong>Loader</strong>：模块转换器，用于把模块原内容按照需求转换成新内容。</li><li><strong>Plugin</strong>：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li><li><strong>Output</strong>：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</li></ul><h2 id="webpack基本配置"><a href="#webpack基本配置" class="headerlink" title="webpack基本配置"></a>webpack基本配置</h2><h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure><h3 id="创建src目录"><a href="#创建src目录" class="headerlink" title="创建src目录"></a>创建src目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir src</span><br></pre></td></tr></table></figure><h3 id="创建dist目录"><a href="#创建dist目录" class="headerlink" title="创建dist目录"></a>创建dist目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dist</span><br></pre></td></tr></table></figure><h3 id="创建-webpack-config-js-配置文件"><a href="#创建-webpack-config-js-配置文件" class="headerlink" title="创建 webpack.config.js 配置文件"></a>创建 webpack.config.js 配置文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure><h4 id="webpack-config-js基本配置"><a href="#webpack-config-js基本配置" class="headerlink" title="webpack.config.js基本配置"></a>webpack.config.js基本配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    plugins: [],</span><br><span class="line">    devServer: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>entry：配置入口文件的地址</li><li>output：配置出口文件的地址</li><li>module：配置模块,主要用来配置不同文件的加载器</li><li>plugins：配置插件</li><li>devServer：配置开发服务器</li></ul><h3 id="创建index-html文件"><a href="#创建index-html文件" class="headerlink" title="创建index.html文件"></a>创建index.html文件</h3><p>在dist目录下创建index.html文件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="webpack-详细配置"><a href="#webpack-详细配置" class="headerlink" title="webpack 详细配置"></a>webpack 详细配置</h2><h3 id="配置开发服务器"><a href="#配置开发服务器" class="headerlink" title="配置开发服务器"></a>配置开发服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server –D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">       contentBase:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">       host:<span class="string">'localhost'</span>,</span><br><span class="line">       compress:<span class="literal">true</span>,</span><br><span class="line">       port:<span class="number">8080</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line">   <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --mode development "</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>contentBase 配置开发服务运行时的文件根目录</li><li>host：开发服务器监听的主机地址</li><li>compress 开发服务器是否启动gzip等压缩</li><li>port：开发服务器监听的端口</li></ul><h3 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h3><p>通过使用不同的Loader，Webpack可以要把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等</p><ul><li>test：匹配处理文件的扩展名的正则表达式</li><li>use：loader名称，就是你要使用模块的名称</li><li>include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹</li><li>query：为loaders提供额外的设置选项<h4 id="loader三种写法"><a href="#loader三种写法" class="headerlink" title="loader三种写法"></a>loader三种写法</h4></li></ul><p><strong>支持加载css文件</strong><br>加载CSS文件，CSS文件有可能在node_modules里，比如bootstrap和antd<br><strong>1. loader</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css/</span>,</span><br><span class="line">                loader:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>2. use</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css/</span>,</span><br><span class="line">                use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><strong>3. use+loader</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css/</span>,</span><br><span class="line">            include: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">'style-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    insertAt:<span class="string">'top'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务<br>模块代码转换的工作由 loader 来处理<br>除此之外的其他任何工作都可以交由 plugin 来完成</p><h3 id="自动产出html"><a href="#自动产出html" class="headerlink" title="自动产出html"></a>自动产出html</h3><p>我们希望自动能产出HTML文件，并在里面引入产出后的资源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">     minify: &#123;</span><br><span class="line">        removeAttributeQuotes:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    hash: <span class="literal">true</span>,</span><br><span class="line">    template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">    filename:<span class="string">'index.html'</span></span><br><span class="line">&#125;)]</span><br></pre></td></tr></table></figure><ul><li>minify 是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号</li><li>hash 引入产出资源的时候加上查询参数，值为哈希避免缓存</li><li>template 模版路径</li></ul><h3 id="支持图片"><a href="#支持图片" class="headerlink" title="支持图片"></a>支持图片</h3><h4 id="手动添加图片"><a href="#手动添加图片" class="headerlink" title="手动添加图片"></a>手动添加图片</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i file-loader url-loader -D</span><br></pre></td></tr></table></figure><ul><li>file-loader 解决CSS等文件中的引入图片路径问题</li><li>url-loader 当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝<h5 id="JS中引入图片"><a href="#JS中引入图片" class="headerlink" title="JS中引入图片"></a>JS中引入图片</h5><strong>JS</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo=<span class="built_in">require</span>(<span class="string">'./images/logo.png'</span>);</span><br><span class="line"><span class="keyword">let</span> img=<span class="keyword">new</span> Image();</span><br><span class="line">img.src=logo;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.(jpg|png|bmp|gif|svg|ttf|woff|woff2|eot)/</span>,</span><br><span class="line">    use:[</span><br><span class="line">    &#123;</span><br><span class="line">       loader:<span class="string">'url-loader'</span>,</span><br><span class="line">       options:&#123;<span class="attr">limit</span>:<span class="number">4096</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="在CSS中引入图片"><a href="#在CSS中引入图片" class="headerlink" title="在CSS中引入图片"></a>在CSS中引入图片</h4><p>还可以在CSS文件中引入图片</p><p><strong>CSS</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.logo&#123;</span><br><span class="line">    width:<span class="number">355</span>px;</span><br><span class="line">    height:<span class="number">133</span>px;</span><br><span class="line">    background-image: url(./images/logo.png);</span><br><span class="line">    background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HTML</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"logo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><strong>分离CSS</strong><br>因为CSS的下载和JS可以并行,当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载</p><ul><li>mini-css-extract-plugin</li><li>filename 打包入口文件</li><li><p>chunkFilename 用来打包import(‘module’)方法中引入的模块</p><p>安装依赖模块</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>配置webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">       <span class="comment">//参数类似于webpackOptions.output</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'[name].css'</span>,</span><br><span class="line">            chunkFilename:<span class="string">'[id].css'</span></span><br><span class="line">        &#125;)]</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        include: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader</span><br><span class="line">        &#125;,<span class="string">'css-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="压缩JS和CSS"><a href="#压缩JS和CSS" class="headerlink" title="压缩JS和CSS"></a>压缩JS和CSS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">"uglifyjs-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,<span class="comment">//启动缓存</span></span><br><span class="line">                parallel: <span class="literal">true</span>,<span class="comment">//启动并行压缩</span></span><br><span class="line">                <span class="comment">//如果为true的话，可以获得sourcemap</span></span><br><span class="line">                sourceMap: <span class="literal">true</span> <span class="comment">// set to true if you want JS source maps</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="comment">//压缩css资源的</span></span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="css和image存放单独目录"><a href="#css和image存放单独目录" class="headerlink" title="css和image存放单独目录"></a>css和image存放单独目录</h4><ul><li>outputPath 输出路径</li><li>publicPath指定的是构建后在html里的路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath:<span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test:<span class="regexp">/\.(jpg|jpeg|png|bmp|gif|svg|ttf|woff|woff2|eot)/</span>,</span><br><span class="line">      use:[</span><br><span class="line">            &#123;</span><br><span class="line">              loader:<span class="string">'url-loader'</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                  limit: <span class="number">4096</span>,</span><br><span class="line">                  outputPath: <span class="string">'images'</span>,</span><br><span class="line">                  publicPath:<span class="string">'/images'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'css/[name].css'</span>,</span><br><span class="line">            chunkFilename:<span class="string">'css/[id].css'</span></span><br><span class="line">        &#125;)]</span><br></pre></td></tr></table></figure><h3 id="在HTML中使用图片"><a href="#在HTML中使用图片" class="headerlink" title="在HTML中使用图片"></a>在HTML中使用图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-withimg-loader -D</span><br></pre></td></tr></table></figure><p>index.html<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/logo.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(html|htm)$/</span>,</span><br><span class="line">  use: <span class="string">'html-withimg-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="编译less-和-sass"><a href="#编译less-和-sass" class="headerlink" title="编译less 和 sass"></a>编译less 和 sass</h3><h4 id="安装less"><a href="#安装less" class="headerlink" title="安装less"></a>安装less</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i less less-loader -D</span><br><span class="line">npm i node-sass sass-loader -D</span><br></pre></td></tr></table></figure><h4 id="编写样式"><a href="#编写样式" class="headerlink" title="编写样式"></a>编写样式</h4><p>less<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@color:orange;</span><br><span class="line"><span class="selector-class">.less-container</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:@color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sass<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$color:green;</span><br><span class="line"><span class="selector-class">.sass-container</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less/</span>,</span><br><span class="line">    include: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">    &#125;,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">    include: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">    &#125;,<span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="处理CSS3属性前缀"><a href="#处理CSS3属性前缀" class="headerlink" title="处理CSS3属性前缀"></a>处理CSS3属性前缀</h3><p>为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀</p><ul><li>Trident内核：主要代表为IE浏览器, 前缀为-ms</li><li>Gecko内核：主要代表为Firefox, 前缀为-moz</li><li>Presto内核：主要代表为Opera, 前缀为-o</li><li>Webkit内核：产要代表为Chrome和Safari, 前缀为 <strong>-webkit</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure><p><strong>index.css</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postcss.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">   use:[MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>,<span class="string">'postcss-loader'</span>],</span><br><span class="line">   include:path.join(__dirname,<span class="string">'./src'</span>),</span><br><span class="line">   exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="转义ES6-ES7-JSX"><a href="#转义ES6-ES7-JSX" class="headerlink" title="转义ES6/ES7/JSX"></a>转义ES6/ES7/JSX</h3><p><strong>Babel</strong>其实是一个编译JavaScript的平台,可以把ES6/ES7,React的JSX转义为ES5</p><h4 id="babel-plugin-proposal-decorator"><a href="#babel-plugin-proposal-decorator" class="headerlink" title="babel-plugin-proposal-decorator"></a>babel-plugin-proposal-decorator</h4><p><strong>安装依赖包</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env  @babel/preset-react  -D</span><br><span class="line">npm i @babel/plugin-proposal-decorators @babel/plugin-proposal-<span class="class"><span class="keyword">class</span>-<span class="title">properties</span> -<span class="title">D</span></span></span><br></pre></td></tr></table></figure></p><h4 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Option+Shift+A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,key,discriptor</span>) </span>&#123;</span><br><span class="line">    discriptor.writable=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    @readonly PI=<span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line">p1.PI=<span class="number">3.15</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br></pre></td></tr></table></figure><p><strong>jsconfig.json</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">         <span class="string">"plugins"</span>: [</span><br><span class="line">            [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">            [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="string">"loose"</span> : <span class="literal">true</span> &#125;]</span><br><span class="line">         ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    include: path.join(__dirname,<span class="string">'src'</span>),</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel runtime"></a>babel runtime</h4><p><strong>babel</strong> 在每个文件都插入了辅助代码，使代码体积过大<br>babel 对一些公共方法使用了非常小的辅助代码，比如 <strong>_extend</strong><br>默认情况下会被添加到每一个需要它的文件中。你可以引入 <strong>@babel/runtime</strong> 作为一个独立模块，来避免重复引入<br><strong>babel-plugin-transform-runtime</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure></p><p><strong>.babelrc</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">   [</span><br><span class="line">         <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="string">"corejs"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"useESModules"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webpack打包的时候，会自动优化重复引入公共方法的问题</p><h3 id="ESLint校验代码格式规范"><a href="#ESLint校验代码格式规范" class="headerlink" title="ESLint校验代码格式规范"></a>ESLint校验代码格式规范</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint eslint-loader babel-eslint --D</span><br></pre></td></tr></table></figure><p><strong>.eslintrc.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//指定解析器选项</span></span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//指定脚本的运行环境</span></span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 启用的规则及其各自的错误级别</span></span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [<span class="string">"error"</span>, <span class="number">4</span>],<span class="comment">//缩进风格</span></span><br><span class="line">        <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>],<span class="comment">//引号类型 </span></span><br><span class="line">        <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],<span class="comment">//关闭语句强制分号结尾</span></span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"error"</span>,<span class="comment">//禁止使用console</span></span><br><span class="line">        <span class="string">"arrow-parens"</span>: <span class="number">0</span> <span class="comment">//箭头函数用小括号括起来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">//配置加载规则</span></span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">            enforce: <span class="string">"pre"</span>,</span><br><span class="line">            include: [path.resolve(__dirname, <span class="string">'src'</span>)], <span class="comment">// 指定检查的目录</span></span><br><span class="line">            options: &#123; <span class="attr">fix</span>: <span class="literal">true</span> &#125; <span class="comment">// 这里的配置项参数将会被传递到 eslint 的 CLIEngine   </span></span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><h3 id="如何调试打包后的代码"><a href="#如何调试打包后的代码" class="headerlink" title="如何调试打包后的代码"></a>如何调试打包后的代码</h3><p>webpack通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法</p><ul><li><strong>source-map</strong>把映射文件生成到单独的文件，最完整最慢</li><li><strong>cheap-module-source-map</strong> 在一个单独的文件中产生一个不带列映射的Map</li><li><strong>eval-source-map</strong> 使用eval打包源文件模块,在同一个文件中生成完整sourcemap</li><li><strong>cheap-module-eval-source-map</strong> sourcemap和打包后的JS同行显示，没有映射列<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool:<span class="string">'eval-source-map'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="打包第三方类库"><a href="#打包第三方类库" class="headerlink" title="打包第三方类库"></a>打包第三方类库</h3><h4 id="直接引入"><a href="#直接引入" class="headerlink" title="直接引入"></a>直接引入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line">alert(_.join([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],<span class="string">'@'</span>));</span><br></pre></td></tr></table></figure><h4 id="插件引入"><a href="#插件引入" class="headerlink" title="插件引入"></a>插件引入</h4><ul><li>_ 函数会自动添加到当前模块的上下文，无需显示声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">   _:<span class="string">'lodash'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>没有全局的$函数，所以导入依赖全局变量的插件依旧会失败</p><h4 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a>expose-loader</h4><p>不需要任何其他的插件配合，只要将下面的代码添加到所有的loader之前<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"expose-loader?libraryName!./file.js"</span>);</span><br><span class="line">&#123; </span><br><span class="line">    test: <span class="built_in">require</span>.resolve(<span class="string">"jquery"</span>), </span><br><span class="line">    loader: <span class="string">"expose-loader?jQuery"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"expose-loader?$!jquery"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jQuery = <span class="built_in">require</span>(<span class="string">"jquery"</span>);</span><br><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line">externals: &#123;</span><br><span class="line">  jquery: <span class="string">'jQuery'</span><span class="comment">//如果要在浏览器中运行，那么不用添加什么前缀，默认设置就是global</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>当代码发生修改后可以自动重新编译<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: <span class="literal">true</span>,</span><br><span class="line">watchOptions: &#123;</span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>, <span class="comment">//忽略不用监听变更的目录</span></span><br><span class="line">    poll:<span class="number">1000</span>, <span class="comment">//每秒询问的文件变更的次数</span></span><br><span class="line">    aggregateTimeout: <span class="number">500</span>, <span class="comment">//防止重复保存频繁重新编译,500毫秒内重复保存不打包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webpack定时获取文件的更新时间，并跟上次保存的时间进行比对，不一致就表示发生了变化,poll就用来配置每秒问多少次<br>当检测文件不再发生变化，会先缓存起来，等待一段时间后之后再通知监听者，这个等待时间通过aggregateTimeout配置<br>webpack只会监听entry依赖的文件<br>我们需要尽可能减少需要监听的文件数量和检查频率，当然频率的降低会导致灵敏度下降</p><h3 id="添加商标"><a href="#添加商标" class="headerlink" title="添加商标"></a>添加商标</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'Garmin'</span>),</span><br></pre></td></tr></table></figure><h3 id="拷贝静态文件"><a href="#拷贝静态文件" class="headerlink" title="拷贝静态文件"></a>拷贝静态文件</h3><p>有时项目中没有引用的文件也需要打包到目标目录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i copy-webpack-plugin -D</span><br><span class="line"><span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">  <span class="keyword">from</span>: path.resolve(__dirname,<span class="string">'src/assets'</span>),<span class="comment">//静态资源目录源地址</span></span><br><span class="line">  to:path.resolve(__dirname,<span class="string">'dist/assets'</span>) <span class="comment">//目标地址，相对于output的path目录</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></p><h3 id="打包前先清空输出目录"><a href="#打包前先清空输出目录" class="headerlink" title="打包前先清空输出目录"></a>打包前先清空输出目录</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i  clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin([path.resolve(__dirname,<span class="string">'dist'</span>)])</span><br></pre></td></tr></table></figure><h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。</p><h4 id="不修改路径"><a href="#不修改路径" class="headerlink" title="不修改路径"></a>不修改路径</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求到 /api/users 现在会被代理到请求 http://localhost:3000/api/users。</span></span><br><span class="line"></span><br><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">"/api"</span>: <span class="string">'http://localhost:3000'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改路径"><a href="#修改路径" class="headerlink" title="修改路径"></a>修改路径</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">"/api"</span>: &#123;</span><br><span class="line">       target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">       pathRewrite:&#123;<span class="string">"^/api"</span>:<span class="string">""</span>&#125;        </span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="before-after"><a href="#before-after" class="headerlink" title="before after"></a>before after</h4><p>before 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before(app)&#123;</span><br><span class="line">  app.get(<span class="string">'/api/users'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">    res.json([&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'zfpx1'</span>&#125;])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h4><p>webpack-dev-middleware就是在 Express 中提供 webpack-dev-server 静态服务能力的一个中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-middleware --save-dev</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackOptions = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line">webpackOptions.mode = <span class="string">'development'</span>;</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackOptions);</span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>webpack-dev-server 的好处是相对简单，直接安装依赖后执行命令即可<br>而使用webpack-dev-middleware的好处是可以在既有的 Express 代码基础上快速添加 webpack-dev-server 的功能，同时利用 Express 来根据需要添加更多的功能，如 mock 服务、代理 API 请求等</p><h3 id="resolve解析"><a href="#resolve解析" class="headerlink" title="resolve解析"></a>resolve解析</h3><h4 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h4><p>指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">".js"</span>,<span class="string">".jsx"</span>,<span class="string">".json"</span>,<span class="string">".css"</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>配置别名可以加快webpack查找模块的速度</p><p>每当引入bootstrap模块的时候，它会直接引入bootstrap,而不需要从node_modules文件夹中按模块的查找规则查找<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bootstrap = path.resolve(__dirname,<span class="string">'node_modules/_bootstrap@3.3.7@bootstrap/dist/css/bootstrap.css'</span>);</span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias:&#123;</span><br><span class="line">      <span class="string">"bootstrap"</span>:bootstrap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>对于直接声明依赖名的模块（如 react ），webpack 会类似 Node.js 一样进行路径搜索，搜索node_modules目录<br>这个目录就是使用resolve.modules字段进行配置的 默认配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">modules: [<span class="string">'node_modules'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果可以确定项目内所有的第三方依赖模块都是在项目根目录下的 node_modules 中的话<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mainFields"><a href="#mainFields" class="headerlink" title="mainFields"></a>mainFields</h4><p>默认情况下package.json 文件则按照文件中 main 字段的文件名来查找文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">// 配置 target === "web" 或者 target === "webworker" 时 mainFields 默认值是：</span></span><br><span class="line">  mainFields: [<span class="string">'browser'</span>, <span class="string">'module'</span>, <span class="string">'main'</span>],</span><br><span class="line">  <span class="comment">// target 的值为其他时，mainFields 默认值为：</span></span><br><span class="line">  mainFields: [<span class="string">"module"</span>, <span class="string">"main"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mainFiles"><a href="#mainFiles" class="headerlink" title="mainFiles"></a>mainFiles</h4><p>当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件，其实这个也是可以配置的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFiles: [<span class="string">'index'</span>], <span class="comment">// 你可以添加其他默认使用的文件名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="resolveLoader"><a href="#resolveLoader" class="headerlink" title="resolveLoader"></a>resolveLoader</h4><p>resolve.resolveLoader用于配置解析 loader 时的 resolve 配置,默认的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [ <span class="string">'node_modules'</span> ],</span><br><span class="line">    extensions: [ <span class="string">'.js'</span>, <span class="string">'.json'</span> ],</span><br><span class="line">    mainFields: [ <span class="string">'loader'</span>, <span class="string">'main'</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h4><p>module.noParse 字段，可以用于配置哪些模块文件的内容不需要进行解析<br>不需要解析依赖（即无依赖） 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>, <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="comment">// 或者使用函数</span></span><br><span class="line">    noParse(content) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/jquery|lodash/</span>.test(content)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 noParse 进行忽略的模块文件中不能使用 import、require、define 等导入机制</p><h3 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h3><p>DefinePlugin创建一些在编译时可以配置的全局常量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>),</span><br><span class="line">    VERSION: <span class="string">"1"</span>,</span><br><span class="line">    EXPRESSION: <span class="string">"1+2"</span>,</span><br><span class="line">    COPYRIGHT: &#123;</span><br><span class="line">        AUTHOR: <span class="built_in">JSON</span>.stringify(<span class="string">"珠峰培训"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(PRODUCTION);</span><br><span class="line"><span class="built_in">console</span>.log(VERSION);</span><br><span class="line"><span class="built_in">console</span>.log(EXPRESSION);</span><br><span class="line"><span class="built_in">console</span>.log(COPYRIGHT);</span><br></pre></td></tr></table></figure></p><p>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值<br>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 true，最后的结果是 ‘true’<br>如果配置的是一个对象字面量，那么该对象的所有 key 会以同样的方式去定义<br><figure class="highlight plain"><figcaption><span>的结果是 'true'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### IgnorePlugin</span><br><span class="line">IgnorePlugin用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去</span><br><span class="line">```js</span><br><span class="line">import moment from  &apos;moment&apos;;</span><br><span class="line">console.log(moment);</span><br><span class="line">new webpack.IgnorePlugin(/^\.\/locale/,/moment$/)</span><br></pre></td></tr></table></figure></p><ul><li>第一个是匹配引入模块路径的正则表达式</li><li>第二个是匹配模块的对应上下文，即所在目录名<h3 id="区分环境变量"><a href="#区分环境变量" class="headerlink" title="区分环境变量"></a>区分环境变量</h3></li><li>日常的前端开发工作中，一般都会有两套构建环境</li><li>一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件</li><li>一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap</li><li>webpack 4.x 版本引入了 mode 的概念<br>当你指定使用 production mode 时，默认会启用各种性能优化的功能，包括构建结果优化以及 webpack 运行性能优化<br>而如果是 development mode 的话，则会开启 debug 工具，运行时打印详细的错误信息，以及更加快速的增量编译构建<h4 id="环境差异"><a href="#环境差异" class="headerlink" title="环境差异"></a>环境差异</h4></li><li>生产环境<ul><li>可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>需要压缩 HTML/CSS/JS 代码</li><li>需要压缩图片</li></ul></li><li>开发环境<ul><li>需要生成 sourcemap 文件</li><li>需要打印 debug 信息</li><li>需要 live reload 或者 hot reload 的功能…<h4 id="获取mode参数"><a href="#获取mode参数" class="headerlink" title="获取mode参数"></a>获取mode参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/optimize/UglifyJsPlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=<span class="function">(<span class="params">env,argv</span>) =&gt;</span> (&#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: argv.mode == <span class="string">'production'</span>?[            </span><br><span class="line">            <span class="keyword">new</span> UglifyJSplugin(&#123;</span><br><span class="line">                  cache: <span class="literal">true</span>,<span class="comment">//启用缓存</span></span><br><span class="line">                  parallel: <span class="literal">true</span>,<span class="comment">// 使用多进程运行改进编译速度</span></span><br><span class="line">                  sourceMap:<span class="literal">true</span><span class="comment">//生成sourceMap映射文件</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin(&#123;&#125;)</span><br><span class="line">        ]:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="封装log方法"><a href="#封装log方法" class="headerlink" title="封装log方法"></a>封装log方法</h4><p>webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 <code>process.env.NODE_ENV</code> 这个变量获取<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'development'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h3><p>可以把 webpack 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可</p><ul><li>webpack.base.js：基础部分，即多个文件中共享的配置</li><li>webpack.development.js：开发环境使用的配置</li><li>webpack.production.js：生产环境使用的配置</li><li>webpack.test.js：测试环境使用的配置…</li><li>webpack-merge<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; smart &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = smart(base, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h3><p>有时候我们的页面可以不止一个HTML页面，会有多个页面，所以就需要多入口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin=<span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        login: <span class="string">'./src/login.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">            chunks: [<span class="string">'index'</span>],</span><br><span class="line">            filename: <span class="string">'index.html'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            chunks: [<span class="string">'login'</span>],</span><br><span class="line">            template: <span class="string">'./src/login.html'</span>,</span><br><span class="line">            filename: <span class="string">'login.html'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是WebPack&quot;&gt;&lt;a href=&quot;#什么是WebPack&quot; class=&quot;headerlink&quot; title=&quot;什么是WebPack&quot;&gt;&lt;/a&gt;什么是WebPack&lt;/h2&gt;&lt;p&gt;WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。&lt;/p&gt;
    
    </summary>
    
      <category term="webpack" scheme="http://www.goyth.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://www.goyth.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 知识点梳理(二)</title>
    <link href="http://www.goyth.com/2018/10/13/mongodb2/"/>
    <id>http://www.goyth.com/2018/10/13/mongodb2/</id>
    <published>2018-10-13T13:47:00.000Z</published>
    <updated>2018-10-14T04:45:10.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB通过配置项启动数据库"><a href="#MongoDB通过配置项启动数据库" class="headerlink" title="MongoDB通过配置项启动数据库"></a>MongoDB通过配置项启动数据库</h3><h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config mongo.conf</span><br></pre></td></tr></table></figure><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 50000</span><br></pre></td></tr></table></figure><a id="more"></a><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">–dbpath</td><td style="text-align:center">指定数据库文件的目录</td></tr><tr><td style="text-align:center">–port</td><td style="text-align:center">端口 默认是27017 28017</td></tr><tr><td style="text-align:center">–fork</td><td style="text-align:center">以后台守护的方式进行启动</td></tr><tr><td style="text-align:center">–logpath</td><td style="text-align:center">指定日志文件输出路径</td></tr><tr><td style="text-align:center">–config</td><td style="text-align:center">指定一个配置文件</td></tr><tr><td style="text-align:center">–auth</td><td style="text-align:center">以安全方式启动数据库，默认不验证</td></tr></tbody></table><h4 id="mongo-conf"><a href="#mongo-conf" class="headerlink" title="mongo.conf"></a>mongo.conf</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/Users/demon/coding/mongo/data</span><br><span class="line">logpath=/Users/demon/coding/mongo/<span class="built_in">log</span></span><br><span class="line">port=50000</span><br></pre></td></tr></table></figure><h3 id="导入导出数据"><a href="#导入导出数据" class="headerlink" title="导入导出数据"></a>导入导出数据</h3><p>这命令是保存成了文件格式</p><ul><li>mongoimport 导出数据</li><li>mongoexport 导入数据</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-h</td><td style="text-align:center">[ –host ]    连接的数据库</td></tr><tr><td style="text-align:center">–port</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:center">用户名</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">密码</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">导出的数据库</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">导出的数据库</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">指定导出的集合</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">导出的文件存储路径</td></tr><tr><td style="text-align:center">-q</td><td style="text-align:center">进行过滤</td></tr></tbody></table><p><strong>准备数据</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use school;</span><br><span class="line"><span class="keyword">var</span> students = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">    students.push(&#123;<span class="attr">name</span>:<span class="string">'luke'</span>+i,<span class="attr">age</span>:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">db.students.insert(students);</span><br><span class="line">db.students.find();</span><br></pre></td></tr></table></figure></p><p><strong>备份记录</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoexport -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">50000</span>  -d school -c students -o stu.json</span><br></pre></td></tr></table></figure></p><p><strong>删除记录</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.remove(&#123;&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : 10 &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>导入记录</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongoimport --port <span class="number">50000</span> --db school --collection students --file</span><br><span class="line">stu.json</span><br></pre></td></tr></table></figure></p><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h4 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h4><p>在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h dbhost -d dbname -o dbdirectory</span><br></pre></td></tr></table></figure></p><ul><li>-h MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</li><li>-d 需要备份的数据库实例，例如：test</li><li>-o 备份的数据存放位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">50000</span> -d school -o data.dmp</span><br></pre></td></tr></table></figure><h4 id="mongorestore"><a href="#mongorestore" class="headerlink" title="mongorestore"></a>mongorestore</h4><p><strong>mongodb</strong>使用 <strong>mongorestore</strong> 命令来恢复备份的数据。</p><ul><li>–host MongoDB所在服务器地址</li><li>–db -d 需要恢复的数据库实例</li><li>最后的一个参数，设置备份数据所在位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">50000</span> data.dmp</span><br><span class="line">mongorestore -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">50000</span> -d school data.bmp/school</span><br></pre></td></tr></table></figure><blockquote><p>Mongodump可以backup整个数据库，而mongoexport要对每个collection进行操作，最主要的区别也是选择的标准是mongoexport输出的JSON比Mongodump的BSON可读性更高，进而可以直接对JSON文件进行操作然后还原数据（BSON转换JSON存在潜在兼容问题）。</p></blockquote><h3 id="锁定和解锁数据库"><a href="#锁定和解锁数据库" class="headerlink" title="锁定和解锁数据库"></a>锁定和解锁数据库</h3><p>为了数据的完整性和一致性，导出前要先锁定写入，导出后再解锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin;</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.runCommand(&#123;fsync:1,lock:1&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"info"</span> : <span class="string">"now locked against writes, use db.fsyncUnlock() to unlock"</span>,</span><br><span class="line">        <span class="string">"seeAlso"</span> : <span class="string">"http://dochub.mongodb.org/core/fsynccommand"</span>,</span><br><span class="line">        <span class="string">"ok"</span> : 1</span><br><span class="line">&#125;</span><br><span class="line">&gt; db.fsyncUnlock();</span><br><span class="line">&#123; <span class="string">"ok"</span> : 1, <span class="string">"info"</span> : <span class="string">"unlock completed"</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="查看角色"><a href="#查看角色" class="headerlink" title="查看角色"></a>查看角色</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show roles;</span><br></pre></td></tr></table></figure><h4 id="内置角色"><a href="#内置角色" class="headerlink" title="内置角色"></a>内置角色</h4><ul><li>数据库用户角色：read、readWrite；</li><li>数据库管理角色：dbAdmin、dbOwner、userAdmin;</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li><li>超级用户角色：root</li><li>内部角色：__system</li></ul><h4 id="创建用户的方法"><a href="#创建用户的方法" class="headerlink" title="创建用户的方法"></a>创建用户的方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createUser(&#123;user:<span class="string">'luke2'</span>,<span class="built_in">pwd</span>:<span class="string">'123456'</span>,roles:[&#123;role:<span class="string">'read'</span>,db:<span class="string">'school'</span>&#125;]&#125;);</span><br><span class="line">Successfully added user: &#123;</span><br><span class="line">        <span class="string">"user"</span> : <span class="string">"luke2"</span>,</span><br><span class="line">        <span class="string">"roles"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">"role"</span> : <span class="string">"read"</span>,</span><br><span class="line">                        <span class="string">"db"</span> : <span class="string">"school"</span></span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看用户的权限"><a href="#查看用户的权限" class="headerlink" title="查看用户的权限"></a>查看用户的权限</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.runCommand(&#123;<span class="attr">usersInfo</span>:<span class="string">'luke2'</span>,<span class="attr">showPrivileges</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"users"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">"_id"</span> : <span class="string">"admin.luke2"</span>,</span><br><span class="line">                        <span class="string">"user"</span> : <span class="string">"luke2"</span>,</span><br><span class="line">                        <span class="string">"db"</span> : <span class="string">"admin"</span>,</span><br><span class="line">                        <span class="string">"roles"</span> : [</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="string">"role"</span> : <span class="string">"read"</span>,</span><br><span class="line">                                        <span class="string">"db"</span> : <span class="string">"school"</span></span><br><span class="line">                                &#125;</span><br><span class="line">                ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库高级命令"><a href="#数据库高级命令" class="headerlink" title="数据库高级命令"></a>数据库高级命令</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = [</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke1'</span>,<span class="attr">home</span>:<span class="string">'北京'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke2'</span>,<span class="attr">home</span>:<span class="string">'北京'</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke3'</span>,<span class="attr">home</span>:<span class="string">'北京'</span>,<span class="attr">age</span>:<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke4'</span>,<span class="attr">home</span>:<span class="string">'广东'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke5'</span>,<span class="attr">home</span>:<span class="string">'广东'</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">name</span>:<span class="string">'luke6'</span>,<span class="attr">home</span>:<span class="string">'广东'</span>,<span class="attr">age</span>:<span class="number">3</span>&#125;</span><br><span class="line">]</span><br><span class="line">db.students.insert(students);</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>查看记录数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().count();</span><br></pre></td></tr></table></figure></p><h4 id="查找不重复的值-distinct"><a href="#查找不重复的值-distinct" class="headerlink" title="查找不重复的值 distinct"></a>查找不重复的值 distinct</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;<span class="attr">distinct</span>:<span class="string">'students'</span>,<span class="attr">key</span>:<span class="string">'home'</span>&#125;).values;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[ "北京", "广东" ]</span></span><br></pre></td></tr></table></figure><h4 id="group-分组"><a href="#group-分组" class="headerlink" title="group 分组"></a>group 分组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;</span><br><span class="line">        group:&#123;</span><br><span class="line">                ns:集合名称，</span><br><span class="line">                key:分组的键,</span><br><span class="line">                initial:初始值,</span><br><span class="line">                $reduce:分解器</span><br><span class="line">                condition:条件,</span><br><span class="line">                finalize:完成时的处理器</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="按城市分组，求每个城市里符合条件的人的年龄总和"><a href="#按城市分组，求每个城市里符合条件的人的年龄总和" class="headerlink" title="按城市分组，求每个城市里符合条件的人的年龄总和"></a>按城市分组，求每个城市里符合条件的人的年龄总和</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;</span><br><span class="line">        group:&#123;</span><br><span class="line">                ns:<span class="string">'students'</span>,</span><br><span class="line">                key:&#123;<span class="attr">home</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">                initial:&#123;<span class="attr">total</span>:<span class="number">0</span>&#125;,</span><br><span class="line">                $reduce:<span class="function"><span class="keyword">function</span>(<span class="params">doc,result</span>)</span>&#123;</span><br><span class="line">                      result.total += doc.age;   </span><br><span class="line">                &#125;,</span><br><span class="line">                condition:&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">                finalize:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">                    result.desc = <span class="string">'本城市的总年龄为'</span>+result.total;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;<span class="attr">drop</span>:<span class="string">'students'</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="固定集合"><a href="#固定集合" class="headerlink" title="固定集合"></a>固定集合</h3><p>MongoDB 固定集合（Capped Collections）是性能出色且有着固定大小的集合，对于大小固定，我们可以想象其就像一个环形队列，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！ firstinfirstout</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>没有索引</li><li>插入和查询速度速度非常快 不需要重新分配空间</li><li>特别适合存储日志<h4 id="创建固定集合"><a href="#创建固定集合" class="headerlink" title="创建固定集合"></a>创建固定集合</h4></li><li>我们通过createCollection来创建一个固定集合，且capped选项设置为true：</li><li>还可以指定文档个数,加上max:1000属性：</li><li>判断集合是否为固定集合: db.logs.isCapped()</li><li>size 是整个集合空间大小，单位为【KB】</li><li>max 是集合文档个数上线，单位是【个】</li><li>如果空间大小到达上限，则插入下一个文档时，会覆盖第一个文档；如果文档个数到达上限，同样插入下一个文档时，会覆盖第一个文档。两个参数上限判断取的是【与】的逻辑。</li><li>capped 封顶的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(<span class="string">'logs'</span>,&#123;<span class="attr">size</span>:<span class="number">50</span>,<span class="attr">max</span>:<span class="number">5</span>,<span class="attr">capped</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="非固定集合转为固定集合"><a href="#非固定集合转为固定集合" class="headerlink" title="非固定集合转为固定集合"></a>非固定集合转为固定集合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;<span class="attr">convertToCapped</span>:<span class="string">"logs"</span>,<span class="attr">size</span>:<span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</li><li>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</li><li>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</li><li>使用索引，方便范围查询和匹配查询。</li></ul><h4 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h4><p>MongoDB使用 createIndex() 方法来创建索引。</p><blockquote><p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p></blockquote><p><strong>语法</strong><br>createIndex()方法基本语法格式如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createIndex(keys, options)</span><br></pre></td></tr></table></figure></p><p>语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p><p><strong>实例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.createIndex(&#123;<span class="string">"title"</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.createIndex(&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="string">"description"</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="指定使用的索引"><a href="#指定使用的索引" class="headerlink" title="指定使用的索引"></a>指定使用的索引</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">name</span>:<span class="string">'zfpx299999'</span>,<span class="attr">age</span>:<span class="number">299999</span>&#125;).hint(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;).explain(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="创建唯一索引并删除重复记录"><a href="#创建唯一索引并删除重复记录" class="headerlink" title="创建唯一索引并删除重复记录"></a>创建唯一索引并删除重复记录</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.person.ensureIndex(&#123; <span class="string">"name"</span> : <span class="number">-1</span> &#125;,&#123; <span class="string">"name"</span> : <span class="string">"indexname"</span>, <span class="string">"unique"</span> : <span class="literal">true</span>,<span class="attr">dropDups</span>:<span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.students.dropIndex(<span class="string">'namedIndex'</span>);<span class="comment">//删除指定的索引</span></span><br><span class="line">db.students.dropIndex(<span class="string">'*'</span>);</span><br><span class="line">db.runCommand(&#123;<span class="attr">dropIndexes</span>:<span class="string">"students"</span>,<span class="attr">index</span>:<span class="string">"namedIndex"</span>&#125;);<span class="comment">//删除所有的索引</span></span><br></pre></td></tr></table></figure><h4 id="在后台创建索引"><a href="#在后台创建索引" class="headerlink" title="在后台创建索引"></a>在后台创建索引</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.ensureIndex(&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'nameIndex'</span>,<span class="attr">unique</span>:<span class="literal">true</span>,<span class="attr">background</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h4><p>在一定的时间后会过期，过期后相应数据数据被删除,比如 session、日志、缓存和临时文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.stus.insert(&#123;<span class="attr">time</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</span><br><span class="line">db.stus.ensureIndex(&#123;<span class="attr">time</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">expireAfterSeconds</span>:<span class="number">10</span>&#125;);</span><br><span class="line">db.stus.find();</span><br></pre></td></tr></table></figure></p><ol><li>索引字段的值必须Date对象，不能是其它类型比如时间戳</li><li>删除时间不精确，每60秒跑一次。删除也要时间，所以有误差。<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4>大篇幅的文章中搜索关键词,MongoDB为我们提供了全文索引<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.article.insert(&#123;<span class="attr">content</span>:<span class="string">'I am a gir'</span>&#125;);</span><br><span class="line">db.article.insert(&#123;<span class="attr">content</span>:<span class="string">'I am a boy'</span>&#125;);</span><br><span class="line">$text:表示要在全文索引中查东西</span><br><span class="line">$search:后边跟查找的内容, 默认全部匹配</span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">'boy'</span>&#125;&#125;);</span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">'girl'</span>&#125;&#125;);</span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">'boy girl'</span>&#125;&#125;);<span class="comment">//多次查找，多个关键字为或的关系</span></span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">"a b"</span>&#125;&#125;); </span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">"boy -girl"</span>&#125;&#125;); <span class="comment">// -表示取消</span></span><br><span class="line">db.article.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">"a \"coco cola\" b "</span>&#125;&#125;); <span class="comment">//支持转义符的,用\斜杠来转义</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h4><ul><li>1为正序 -1为倒序</li><li>索引虽然可以提升查询性能，但会降低插件性能，对于插入多查询少不要创索引</li><li>数据量不大时不需要使用索引。性能的提升并不明显，反而大大增加了内存和硬盘的消耗。</li><li>查询数据超过表数据量30%时，不要使用索引字段查询</li><li>排序工作的时候可以建立索引以提高排序速度</li><li>数字索引，要比字符串索引快的多</li></ul><h3 id="MongoDB-复制（副本集）"><a href="#MongoDB-复制（副本集）" class="headerlink" title="MongoDB 复制（副本集）"></a>MongoDB 复制（副本集）</h3><p><strong>MongoDB</strong>复制是将数据同步在多个服务器的过程。<br>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。<br>复制还允许您从硬件故障和服务中断中恢复数据。</p><h4 id="MongoDB复制原理"><a href="#MongoDB复制原理" class="headerlink" title="MongoDB复制原理"></a>MongoDB复制原理</h4><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。<br>mongodb各个节点常见的搭配方式为：一主一从、一主多从。<br>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>一台活跃服务器和二个备份服务器</li><li>当活跃服务器出现故障，这时集群根据权重算法推选出出活跃服务器</li><li>当原来的主服务器恢复后又会变成从服务器</li></ol><h4 id="配置副本集"><a href="#配置副本集" class="headerlink" title="配置副本集"></a>配置副本集</h4><p>A服务器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbpath=E:\repl\repl1</span><br><span class="line">port=<span class="number">2001</span></span><br><span class="line">replSet=group</span><br></pre></td></tr></table></figure></p><p>B服务器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbpath=E:\repl\repl2</span><br><span class="line">port=<span class="number">2002</span></span><br><span class="line">replSet=group</span><br></pre></td></tr></table></figure></p><p>C服务器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbpath=E:\repl\repl3</span><br><span class="line">port=<span class="number">2003</span></span><br><span class="line">replSet=group</span><br></pre></td></tr></table></figure></p><h4 id="初始化副本集"><a href="#初始化副本集" class="headerlink" title="初始化副本集"></a>初始化副本集</h4><p>rs.initiate() 启动一个新的副本集<br>rs.conf() 查看副本集的配置<br>rs.status() 命令<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use admin;</span><br><span class="line"><span class="keyword">var</span> conf=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="string">"group"</span>,</span><br><span class="line">    <span class="string">"members"</span> : [</span><br><span class="line">        &#123; <span class="string">"_id"</span> : <span class="number">0</span>,  <span class="string">"host"</span> : <span class="string">"127.0.0.1:2001"</span>  &#125;,</span><br><span class="line">        &#123; <span class="string">"_id"</span> : <span class="number">1</span>,  <span class="string">"host"</span> : <span class="string">"127.0.0.1:2002"</span>  &#125;,</span><br><span class="line">        &#123; <span class="string">"_id"</span> : <span class="number">2</span>,  <span class="string">"host"</span> : <span class="string">"127.0.0.1:2003"</span>  &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">rs.initiate(conf);</span><br><span class="line">rs.status();</span><br></pre></td></tr></table></figure></p><h4 id="高级参数"><a href="#高级参数" class="headerlink" title="高级参数"></a>高级参数</h4><ul><li>standard 常规节点 参与投票有可能成为活跃节点</li><li>passive 副本节点 参与投票，但不能成为活跃节点</li><li>arbiter 仲裁节点 只参与投票，不复制节点，也不能成为活跃节点</li><li>priority 0到1000之间，0代表是副本节点，1到1000是常规节点</li><li>arbiterOnly:true 仲裁节点<h4 id="读写分离操作"><a href="#读写分离操作" class="headerlink" title="读写分离操作"></a>读写分离操作</h4>一般情况下作为副本节点是不能进行数据库操作的，但是在读取密集的系统中读写分离是必要的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Oplog"><a href="#Oplog" class="headerlink" title="Oplog"></a>Oplog</h4><p>它被存储在本地数据库local中，会记录每一个操作。 如果希望在故障恢复的时候尽可能更多，可以把这个size设置的大一点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--oplogSize <span class="number">1024</span></span><br><span class="line">use local;</span><br><span class="line"> db.oplog.rs.find().limit(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p> MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p><h3 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h3><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。</p><p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p><h4 id="为什么使用分片"><a href="#为什么使用分片" class="headerlink" title="为什么使用分片"></a>为什么使用分片</h4><ul><li>复制所有的写入操作到主节点</li><li>延迟的敏感数据会在主节点查询</li><li>单个副本集限制在12个节点</li><li>当请求量巨大时会出现内存不足。</li><li>本地磁盘不足</li><li>垂直扩展价格昂贵</li></ul><p>MongoDB分片<br>下图展示了在MongoDB中使用分片集群结构分布：</p><p><img src="/2018/10/13/mongodb2/sharding.png" alt=""></p><p>上图中主要有如下所述三个主要组件：</p><ul><li><p><strong>Shard</strong>:<br>用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</p></li><li><p><strong>Config Server</strong>:<br>mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。</p></li><li><p><strong>Query Routers</strong>:<br>前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。</p></li></ul><h4 id="分片实例"><a href="#分片实例" class="headerlink" title="分片实例"></a>分片实例</h4><p>分片结构端口分布如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shard Server <span class="number">1</span>：<span class="number">27020</span></span><br><span class="line">Shard Server <span class="number">2</span>：<span class="number">27021</span></span><br><span class="line">Shard Server <span class="number">3</span>：<span class="number">27022</span></span><br><span class="line">Shard Server <span class="number">4</span>：<span class="number">27023</span></span><br><span class="line">Config Server ：<span class="number">27100</span></span><br><span class="line">Route Process：<span class="number">40000</span></span><br></pre></td></tr></table></figure></p><p>步骤一：启动Shard Server<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/s0</span><br><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/s1</span><br><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/s2</span><br><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/s3</span><br><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/log</span><br><span class="line">[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27020 --dbpath=/www/mongoDB/shard/s0 --logpath=/www/mongoDB/shard/log/s0.log --logappend --fork</span><br><span class="line">....</span><br><span class="line">[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27023 --dbpath=/www/mongoDB/shard/s3 --logpath=/www/mongoDB/shard/log/s3.log --logappend --fork</span><br></pre></td></tr></table></figure></p><p>步骤二： 启动Config Server<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@100 /]# mkdir -p /www/mongoDB/shard/config</span><br><span class="line">[root@100 /]# /usr/local/mongoDB/bin/mongod --port 27100 --dbpath=/www/mongoDB/shard/config --logpath=/www/mongoDB/shard/log/config.log --logappend --fork</span><br></pre></td></tr></table></figure></p><p>注意：这里我们完全可以像启动普通mongodb服务一样启动，不需要添加—shardsvr和configsvr参数。因为这两个参数的作用就是改变启动端口的，所以我们自行指定了端口就可以。</p><p>步骤三： 启动Route Process<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mongoDB/bin/mongos --port <span class="number">40000</span> --configdb localhost:<span class="number">27100</span> --fork --logpath=<span class="regexp">/www/m</span>ongoDB/shard/log/route.log --chunkSize <span class="number">500</span></span><br></pre></td></tr></table></figure></p><p>mongos启动参数中，chunkSize这一项是用来指定chunk的大小的，单位是MB，默认大小为200MB.</p><p>步骤四： 配置Sharding</p><p>接下来，我们使用MongoDB Shell登录到mongos，添加Shard节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@100 shard]# /usr/local/mongoDB/bin/mongo admin --port 40000</span><br><span class="line">MongoDB shell version: <span class="number">2.0</span><span class="number">.7</span></span><br><span class="line">connecting to: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">40000</span>/admin</span><br><span class="line">mongos&gt; db.runCommand(&#123; <span class="attr">addshard</span>:<span class="string">"localhost:27020"</span> &#125;)</span><br><span class="line">&#123; <span class="string">"shardAdded"</span> : <span class="string">"shard0000"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">......</span><br><span class="line">mongos&gt; db.runCommand(&#123; <span class="attr">addshard</span>:<span class="string">"localhost:27029"</span> &#125;)</span><br><span class="line">&#123; <span class="string">"shardAdded"</span> : <span class="string">"shard0009"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">mongos&gt; db.runCommand(&#123; enablesharding:"test" &#125;) #设置分片存储的数据库</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">mongos&gt; db.runCommand(&#123; <span class="attr">shardcollection</span>: <span class="string">"test.log"</span>, <span class="attr">key</span>: &#123; <span class="attr">id</span>:<span class="number">1</span>,<span class="attr">time</span>:<span class="number">1</span>&#125;&#125;)</span><br><span class="line">&#123; <span class="string">"collectionsharded"</span> : <span class="string">"test.log"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><p>步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MongoDB通过配置项启动数据库&quot;&gt;&lt;a href=&quot;#MongoDB通过配置项启动数据库&quot; class=&quot;headerlink&quot; title=&quot;MongoDB通过配置项启动数据库&quot;&gt;&lt;/a&gt;MongoDB通过配置项启动数据库&lt;/h3&gt;&lt;h4 id=&quot;启动服务器&quot;&gt;&lt;a href=&quot;#启动服务器&quot; class=&quot;headerlink&quot; title=&quot;启动服务器&quot;&gt;&lt;/a&gt;启动服务器&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mongod --config mongo.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;启动客户端&quot;&gt;&lt;a href=&quot;#启动客户端&quot; class=&quot;headerlink&quot; title=&quot;启动客户端&quot;&gt;&lt;/a&gt;启动客户端&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mongo --port 50000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.goyth.com/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="http://www.goyth.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 知识点梳理（一）</title>
    <link href="http://www.goyth.com/2018/10/12/mongodb/"/>
    <id>http://www.goyth.com/2018/10/12/mongodb/</id>
    <published>2018-10-12T13:12:45.000Z</published>
    <updated>2018-12-02T08:39:29.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h2><p>MongoDB是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><a id="more"></a><h2 id="MongoDB-基本概念"><a href="#MongoDB-基本概念" class="headerlink" title="MongoDB 基本概念"></a>MongoDB 基本概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p><p>“show dbs” 命令可以显示所有数据的列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./mongo</span><br><span class="line">MongoDB shell version: 3.0.6</span><br><span class="line">connecting to: <span class="built_in">test</span></span><br><span class="line">&gt; show dbs</span><br><span class="line">admin  0.000GB</span><br><span class="line"><span class="built_in">local</span>  0.078GB</span><br><span class="line"><span class="built_in">test</span>   0.078GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>执行 “db” 命令可以显示当前数据库对象或集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./mongo</span><br><span class="line">MongoDB shell version: 3.0.6</span><br><span class="line">connecting to: <span class="built_in">test</span></span><br><span class="line">&gt; db</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>运行”use”命令，可以连接到一个指定的数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; use <span class="built_in">local</span></span><br><span class="line">switched to db <span class="built_in">local</span></span><br><span class="line">&gt; db</span><br><span class="line"><span class="built_in">local</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、/、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li><li>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</li></ul><p><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。<br><strong>local</strong>: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合<br>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><h4 id="RDBMS（关系型数据库）与MongoDB对应术语"><a href="#RDBMS（关系型数据库）与MongoDB对应术语" class="headerlink" title="RDBMS（关系型数据库）与MongoDB对应术语"></a>RDBMS（关系型数据库）与MongoDB对应术语</h4><table><thead><tr><th style="text-align:center">RDBMS</th><th style="text-align:center">MongoDB</th></tr></thead><tbody><tr><td style="text-align:center">数据库</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">表格</td><td style="text-align:center">集合</td></tr><tr><td style="text-align:center">行</td><td style="text-align:center">文档</td></tr><tr><td style="text-align:center">列</td><td style="text-align:center">字段</td></tr><tr><td style="text-align:center">表联合</td><td style="text-align:center">嵌入文档</td></tr><tr><td style="text-align:center">主键</td><td style="text-align:center">主键 (MongoDB 提供了 key 为 _id )</td></tr></tbody></table><p>需要注意的是：</p><ul><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚- 至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ul><h4 id="文档键命名规范："><a href="#文档键命名规范：" class="headerlink" title="文档键命名规范："></a>文档键命名规范：</h4><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。<br>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><h3 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h3><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td style="text-align:center">Integer</td><td style="text-align:center">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">布尔值。用于存储布尔值（真/假）。</td></tr><tr><td style="text-align:center">Double</td><td style="text-align:center">双精度浮点值。用于存储浮点值。</td></tr><tr><td style="text-align:center">Min/Max keys</td><td style="text-align:center">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td style="text-align:center">Array</td><td style="text-align:center">用于将数组或列表或多个值存储为一个键。</td></tr><tr><td style="text-align:center">Timestamp</td><td style="text-align:center">时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">用于内嵌文档。</td></tr><tr><td style="text-align:center">Null</td><td style="text-align:center">用于创建空值。</td></tr><tr><td style="text-align:center">Symbol</td><td style="text-align:center">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td style="text-align:center">Object ID</td><td style="text-align:center">对象 ID。用于创建文档的 ID。</td></tr><tr><td style="text-align:center">Binary Data</td><td style="text-align:center">二进制数据。用于存储二进制数据。</td></tr><tr><td style="text-align:center">Code</td><td style="text-align:center">代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td style="text-align:center">Regular expression</td><td style="text-align:center">正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><p>ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes，含义是：</p><p>前 4 个字节表示创建 unix 时间戳,格林尼治时间 UTC 时间，比北京时间晚了 8 个小时<br>接下来的 3 个字节是机器标识码<br>紧接的两个字节由进程 id 组成 PID<br>最后三个字节是随机数</p><p>MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象</p><p>由于 ObjectId 中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ObjectId().getTimestamp()</span><br><span class="line">ISODate(<span class="string">"2018-10-12T14:07:33Z"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use database_name     <span class="comment">// database_name代表数据库的名字</span></span><br></pre></td></tr></table></figure><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><h4 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">db.getName()</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><h4 id="创建一个空集合"><a href="#创建一个空集合" class="headerlink" title="创建一个空集合"></a>创建一个空集合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(collection_Name)</span><br><span class="line"><span class="comment">//collection_Name集合的名称</span></span><br></pre></td></tr></table></figure><h4 id="创建集合并插入一个文档"><a href="#创建集合并插入一个文档" class="headerlink" title="创建集合并插入一个文档"></a>创建集合并插入一个文档</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collection_Name集合的名称</span></span><br><span class="line"><span class="comment">//document要插入的文档</span></span><br><span class="line">db.collection_Name.insert(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.insert(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>collection_name 集合的名字</li><li>document 插入的文档</li></ul><blockquote><p>每当插入一条新文档的时候mongodb会自动为此文档生成一个_id属性,_id一定是唯一的，用来唯一标识一个文档 _id也可以直接指定，但如果数据库中此集合下已经有此_id的话插入会失败<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.insert(&#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br><span class="line">&gt; db.students.insert(&#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.save(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>collection_name 集合的名字</li><li>document 插入的文档<blockquote><p>注：如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p></blockquote></li></ul><p>实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.save(&#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">0</span> &#125;)</span><br><span class="line">&gt; db.students.save(&#123;<span class="attr">_id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">age</span>:<span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;updateObj&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>query 查询条件,指定要更新符合哪些条件的文档</li><li>updateObj 更新后的对象或指定一些更新的操作符<ul><li>$set 直接指定更新后的值</li><li>$inc 在原基础上累加</li><li>$unset 删除指定的键</li><li>$push 向数组中添加元素</li></ul></li><li>upsert 可选，这个参数的意思是，如果不存在符合条件的记录时是否插入updateObj. 默认是false,不插入。</li><li>multi 可选，mongodb 默认只更新找到的第一条记录，如果这个参数为true,就更新所有符合条件的记录。<br>实例 将students集合中数据中name是luke2的值修改为luke22<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.update(&#123;<span class="attr">name</span>:<span class="string">'luke2'</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">300</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></li></ul><p>注：如果有多条name是luke2的数据只更新一条,如果想全部更新需要指定{multi:true}的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.students.update(&#123;<span class="attr">name</span>:<span class="string">'luke2'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">300</span>&#125;&#125;,&#123;<span class="attr">multi</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : <span class="number">2</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="runCommand"><a href="#runCommand" class="headerlink" title="runCommand"></a>runCommand</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> modify = &#123;</span><br><span class="line">    findAndModify:<span class="string">'student'</span>,</span><br><span class="line">    query:&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;,</span><br><span class="line">    update:&#123;<span class="attr">$set</span>:&#123;<span class="attr">age</span>:<span class="number">100</span>&#125;&#125;,</span><br><span class="line">    fields:&#123;<span class="attr">name</span>:<span class="string">'1'</span>&#125;,</span><br><span class="line">    sort:<span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">new</span>:<span class="literal">true</span> <span class="comment">//返回修改后的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = db.runCommand(modify);</span><br><span class="line">printjson(result);</span><br></pre></td></tr></table></figure><h3 id="文档的删除"><a href="#文档的删除" class="headerlink" title="文档的删除"></a>文档的删除</h3><p><strong>remove</strong>方法是用来移除集合中的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: <span class="xml"><span class="tag">&lt;<span class="name">boolean</span>&gt;</span></span></span><br><span class="line"><span class="xml">   &#125;</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure></p><p>参数说明</p><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除匹配到的多个文档中的第一个</li></ul><p>实例 删除worker集合里name是luke2的所有文档数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.remove(&#123;<span class="attr">name</span>:<span class="string">'luke2'</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></p><p>即使匹配多条也只删除一条<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.remove(&#123;<span class="attr">name</span>:<span class="string">"luke2"</span>&#125;,&#123;<span class="attr">justOne</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find()</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>collection_name 集合的名字</li></ul><p>查询students下所有的文档<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find()</span><br></pre></td></tr></table></figure></p><h4 id="查询指定列"><a href="#查询指定列" class="headerlink" title="查询指定列"></a>查询指定列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find(&#123;queryWhere&#125;,&#123;<span class="attr">key</span>:<span class="number">1</span>,<span class="attr">key</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>collection_name 集合的名字</li><li>queryWhere 参阅查询条件操作符</li><li>key 指定要返回的列</li><li>1 表示要显示</li></ul><p>只返回显示age列<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.find(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h4><p>查询匹配结果的第一条数据 语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.findOne()</span><br></pre></td></tr></table></figure></p><p>实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.findOne()</span><br></pre></td></tr></table></figure></p><h4 id="in"><a href="#in" class="headerlink" title="$in"></a>$in</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$in</span>:[<span class="number">30</span>,<span class="number">100</span>]&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="nin"><a href="#nin" class="headerlink" title="$nin"></a>$nin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$nin</span>:[<span class="number">30</span>,<span class="number">100</span>]&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="nin-1"><a href="#nin-1" class="headerlink" title="$nin"></a>$nin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$in</span>:[<span class="number">30</span>,<span class="number">100</span>]&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="not"><a href="#not" class="headerlink" title="$not"></a>$not</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$not</span>:&#123;<span class="attr">$gte</span>:<span class="number">20</span>,<span class="attr">$lte</span>:<span class="number">30</span>&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按所有元素匹配</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:[ <span class="string">"Lufy"</span>, <span class="string">"Nami2"</span>, <span class="string">"Wusopu"</span>, <span class="string">"A"</span> ]&#125;);</span><br><span class="line"><span class="comment">//匹配一条</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:<span class="string">"A"</span>&#125;);</span><br><span class="line"><span class="comment">//$all</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:&#123;<span class="attr">$all</span>:[<span class="string">'A'</span>,<span class="string">"Lufy"</span>]&#125;&#125;);</span><br><span class="line"><span class="comment">//$in</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:&#123;<span class="attr">$in</span>:[<span class="string">'A'</span>,<span class="string">"Lufy"</span>]&#125;&#125;);</span><br><span class="line"><span class="comment">//$size</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:&#123;<span class="attr">$size</span>:<span class="number">4</span>&#125;&#125;);</span><br><span class="line"><span class="comment">//$slice</span></span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:&#123;<span class="attr">$size</span>:<span class="number">5</span>&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">friends</span>:&#123;<span class="attr">$slice</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">let</span> result = db.student.find(&#123;<span class="attr">friends</span>:&#123;<span class="attr">$size</span>:<span class="number">5</span>&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">friends</span>:&#123;<span class="attr">$slice</span>:<span class="number">-1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;<span class="attr">$where</span>:<span class="string">"this.age&gt;30"</span>&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = db.student.find();</span><br><span class="line"></span><br><span class="line"><span class="comment">//while(result.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//    printjson(result.next());</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">result.forEach(<span class="function"><span class="params">element</span>=&gt;</span>printjson(element));</span><br></pre></td></tr></table></figure><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符用于比较两个表达式并从mongoDB集合中获取数据</p><h4 id="大于操作符"><a href="#大于操作符" class="headerlink" title="大于操作符"></a>大于操作符</h4><p>查询age 大于 30的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="大于等于操作符"><a href="#大于等于操作符" class="headerlink" title="大于等于操作符"></a>大于等于操作符</h4><p>查询age 3大于等于30 的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">age</span>: &#123;<span class="attr">$gte</span>: <span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="小于操作符"><a href="#小于操作符" class="headerlink" title="小于操作符"></a>小于操作符</h4><p>查询age 小于30的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">age</span>: &#123;<span class="attr">$lt</span>: <span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="小于等于操作符"><a href="#小于等于操作符" class="headerlink" title="小于等于操作符"></a>小于等于操作符</h4><p>查询age 小于等于30的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">age</span>: &#123;<span class="attr">$lte</span>: <span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="同时使用-gte和-lte"><a href="#同时使用-gte和-lte" class="headerlink" title="同时使用 $gte和$lte"></a>同时使用 <code>$gte</code>和<code>$lte</code></h4><p>实例 查询age 大于等于 30 并且 age 小于等于 50 的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">age</span>: &#123;<span class="attr">$gte</span>: <span class="number">30</span>, <span class="attr">$lte</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="等于"><a href="#等于" class="headerlink" title="等于"></a>等于</h4><p>查询age = 30的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="string">"age"</span>: <span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="使用-id进行查询"><a href="#使用-id进行查询" class="headerlink" title="使用 _id进行查询"></a>使用 _id进行查询</h4><p>实例 查询_id是 562af23062d5a57609133974 数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.students.find(&#123;<span class="attr">_id</span>:ObjectId(<span class="string">"5adb666ecd738e9771638985"</span>)&#125;);</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5adb666ecd738e9771638985"</span>), <span class="string">"name"</span> : <span class="string">"zzzz"</span> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="查询结果集的条数"><a href="#查询结果集的条数" class="headerlink" title="查询结果集的条数"></a>查询结果集的条数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().count()</span><br></pre></td></tr></table></figure><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>实例 查询name里包含luke的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">name</span>:<span class="regexp">/luke/</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>查询某个字段的值当中是否以另一个值开头<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">name</span>:<span class="regexp">/^luke/</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>###与和或</p><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>find方法可以传入多个键(key)，每个键(key)以逗号隔开<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find(&#123;<span class="attr">key1</span>:value1, <span class="attr">key2</span>:value2&#125;)</span><br></pre></td></tr></table></figure></p><p>实例 查询name是luke并且age是1的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">   &#123;<span class="attr">key1</span>: value1&#125;, &#123;<span class="attr">key2</span>:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>实例 查询age = 30 或者 age = 50 的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">$or</span>:[&#123;<span class="attr">age</span>:<span class="number">30</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">50</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="and和or联用"><a href="#and和or联用" class="headerlink" title="and和or联用"></a>and和or联用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection_name.find(</span><br><span class="line">   &#123;</span><br><span class="line">     key1:value1,</span><br><span class="line">     key2:value2,</span><br><span class="line">     $or: [</span><br><span class="line">   &#123;<span class="attr">key1</span>: value1&#125;,</span><br><span class="line">   &#123;<span class="attr">key2</span>:value2&#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实例 查询 name是luke 并且 age是30 或者 age是 50 的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find(&#123;<span class="attr">name</span>:<span class="string">'luke'</span>,<span class="attr">$or</span>:[&#123;<span class="attr">age</span>:<span class="number">30</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">50</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>读取指定数量的数据记录<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collectoin_name.find().limit(number)</span><br></pre></td></tr></table></figure></p><p>参数</p><p>collectoin_name集合<br>number读取的条数<br>实例 查询前3条数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().limit(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数 语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collectoin_name.find().skip(number)</span><br></pre></td></tr></table></figure></p><p>参数</p><p>collectoin_name集合<br>number跳过的条数<br>实例 查询3条以后的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().skip(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h4 id="skip-limit"><a href="#skip-limit" class="headerlink" title="skip+limit"></a>skip+limit</h4><p>通常用这种方式来实现分页功能 语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collectoin_name.find().skip(skipNum).limit(limitNum)</span><br></pre></td></tr></table></figure></p><p>参数</p><p>collectoin_name 集合名称<br>skipNum 跳过的条数<br>limitNum 限制返回的条数<br>实例 查询在4-6之间的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().skip(<span class="number">3</span>).limit(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><h4 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h4><p>sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。 语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collectoin_name.find().sort(&#123;<span class="attr">key</span>:<span class="number">1</span>&#125;)</span><br><span class="line">db.collectoin_name.find().sort(&#123;<span class="attr">key</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>参数</p><p>collectoin_name集合<br>key表示字段<br>实例 查询出并升序排序 {age:1} age表示按那个字段排序 1表示升序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.students.find().sort(&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是MongoDB&quot;&gt;&lt;a href=&quot;#什么是MongoDB&quot; class=&quot;headerlink&quot; title=&quot;什么是MongoDB&quot;&gt;&lt;/a&gt;什么是MongoDB&lt;/h2&gt;&lt;p&gt;MongoDB是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。&lt;br&gt;MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。&lt;br&gt;MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.goyth.com/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="http://www.goyth.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>实现一个符合Promise A+规范的Promise</title>
    <link href="http://www.goyth.com/2018/08/03/promise/"/>
    <id>http://www.goyth.com/2018/08/03/promise/</id>
    <published>2018-08-03T03:43:09.000Z</published>
    <updated>2018-08-03T07:04:18.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>模拟实现一个符合<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+规范</a>的promise，仅供学习其实现原理</p><ul><li><p><a href="https://github.com/jsyt/promise" target="_blank" rel="noopener">源码地址链接</a></p></li><li><p><a href="http://goyth.com/" target="_blank" rel="noopener">我的博客</a></p></li><li><p><a href="https://github.com/jsyt/jsyt.github.io" target="_blank" rel="noopener">github博客主页</a></p></li></ul><p>Promise的详细使用方法可参考<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的文章</a></p><a id="more"></a><h2 id="Promise-A-规范概述"><a href="#Promise-A-规范概述" class="headerlink" title="Promise A+规范概述"></a><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+规范</a>概述</h2><h3 id="promise雏形"><a href="#promise雏形" class="headerlink" title="promise雏形"></a>promise雏形</h3><p>简单点说</p><ol><li><p><code>promise</code> 函数的参数（executor）是一个函数，这个函数有两个参数<code>resolve</code>和<code>reject</code>，这两个参数也都是函数，分别在<code>promise</code>成功和失败时调用。</p></li><li><p>当构建一个<code>promise</code>实例时，会自动调用这个函数（executor）</p></li><li>每个<code>promise</code>对象都有一个<code>onFulfilledCallback</code>队列和一个<code>onRejectedCallback</code>队列，用来分别存储成功和失败时调用的回调函数</li><li>每个<code>promise</code>有三种状态<code>pending</code> 、<code>fulfilled</code>、<code>rejected</code>，同一时刻只能处于其中一种状态，并且只能从<code>pending</code> 、状态转化成<code>fulfilled</code>状态，或者<code>rejected</code>状态，一旦状态发生转化就不能再被改变。</li><li>当调用<code>resolve(value)</code>函数时，<code>promise</code>的状态会从<code>pending</code>转化成<code>fulfilled</code>，并且将<code>resolve</code>参数中的<code>value</code>值赋值给此<code>promise</code>的<code>value</code>变量，promise的<code>value</code>被赋值后，就不能再次改变了；此时还会去取出<code>onFulfilledCallback</code>队列中所有的回调函数，并将此<code>promise</code>的<code>value</code>作为回调函数的参数，依次执行</li><li>当调用<code>rejected(reason)</code>函数时，<code>promise</code>的状态会从<code>pending</code>转化成<code>rejected</code>，并且将<code>rejected(reason)</code>函数中的<code>reason</code>参数赋值给此<code>promise</code>的<code>reason</code>变量，这个<code>reason</code>被赋值后，也是不能再次改变了；此时还会去取出<code>onRejectedCallback</code>队列中所有的回调函数，并将此<code>promise</code>的<code>reason</code>作为回调函数的参数，依次执行</li><li>当executor执行抛异常时捕获这个异常，并将异常的原因作为<code>reject</code>函数的参数，执行<code>reject</code>函数</li></ol><p>根据这些我们先写一个第一版的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.state = <span class="string">'pending'</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  self.onFulfilledCallback = [];</span><br><span class="line">  self.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      self.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.onFulfilledCallback.foreach(<span class="function"><span class="params">fn</span>=&gt;</span>fn(self.value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      self.state = <span class="string">'rejected'</span>;</span><br><span class="line">      self.reason = reason;</span><br><span class="line">      self.onRejectedCallback.foreach(<span class="function"><span class="params">fn</span>=&gt;</span>fn(self.reason))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h3><ol><li>每个<code>promise</code>必须提供一个<code>then</code>方法，并且<code>then</code>方法包含两个参数<code>onFulfilled</code> 和 <code>onRejected</code></li><li>这两个参数如果不是函数的话就直接忽略，并且将成功或失败的值传递给下一个then注册的回调函数及下一个then的<code>onFulfilled</code> 和 <code>onRejected</code></li><li>当执行then函数时，如果promise的状态是<code>pending</code>则将then中注册的成功和失败时对应的回调函数<code>onFulfilled</code> 和 <code>onRejected</code>分别放入onFulfilledCallback队列和一个onRejectedCallback队列中</li><li>如果promise的状态是<code>fulfilled</code>，就直接调用<code>onFulfilled</code>函数，并且将此<code>promise</code>的<code>value</code>作为<code>onFulfilled</code>函数的第一个参数执行</li><li>如果<code>promise</code>的状态为<code>rejected</code>，就直接调用<code>onRejected</code>函数，并且将此<code>promise</code>的<code>reason</code>作为<code>onRejected</code>函数的第一个参数执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">  <span class="keyword">if</span>(self.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">    onFulfilled(self.value);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">    onRejected(self.reason);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">    self.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">    self.onRejectedCallback.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-链式调用"><a href="#promise-链式调用" class="headerlink" title="promise 链式调用"></a>promise 链式调用</h3><ol><li>此时的promise 是不支持链式调用的，所以我们应该在then中返回一个新的promise来支持链式调用<br>为什么是新的promise，而不是直接返回this呢？<br>因为promise的状态一旦发生转变，就不能再次改变了，而链式调用中的then返回的promise是可以选择resolve或者reject的，所以then必须返回一个新的promise</li><li>所有的then中注册的回调函数，都应该是异步执行，标准promise的then中注册的回调函数是属于微观任务，我们这里可以用setTimeout来模拟，但是要注意的是setTimeout属于宏观任务</li><li>所有的then中注册的异步回调函数都应该放在try{}catch中执行，当执行then 中的回调函数抛出异常时，应该捕获这个异常，并将异常对象传递给reject，并调用reject</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">    <span class="keyword">if</span>(self.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          onFulfilled(self.value);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          onRejected(self.reason);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      self.onFulfilledCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            onFulfilled(self.value);</span><br><span class="line">          &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;));</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          onRejected(self.reason);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套promise问题"><a href="#嵌套promise问题" class="headerlink" title="嵌套promise问题"></a>嵌套promise问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="string">'666'</span>)</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = promise1.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//666</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们知道当调用resolve(value)时，如果resolve中的参数value是一个普通值，则会将value传递给then中注册的成功时的回调函数，并调用此回调函数。但是如果value不是一个普通值，而是一个promise的话，则会执行这个promise，如果执行这个promise得到的结果仍然为一个promise，则继续递归执行，直到最终执行结果为一个普通值，并且将这个执行结果作为第一个promise的执行结果，Promise A+ 规范定义了这个解析流程</p><p><img src="/2018/08/03/promise/resolvePromise.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise2 === x) &#123;   <span class="comment">//2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'circular reference'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;  <span class="comment">// 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span></span><br><span class="line">  <span class="keyword">if</span>(x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;    <span class="comment">// 2.3.3  if x is an object or function,</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;    <span class="comment">// 2.3.3.1 Let then be x.then</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;  <span class="comment">// 2.3.3.3 If then is a function, call it with x as self, first argument resolvePromise, and second argument rejectPromise, where:</span></span><br><span class="line">        then.call(x, y=&gt;&#123;</span><br><span class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;   <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject)  <span class="comment">// 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span></span><br><span class="line">        &#125;, reason=&gt;&#123;</span><br><span class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;  <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(reason)  <span class="comment">// 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 2.3.3.4 If then is not a function, fulfill promise with x.</span></span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;  <span class="comment">// 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span></span><br><span class="line">      <span class="keyword">if</span>(called) <span class="keyword">return</span>;  <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e)  <span class="comment">// 2.3.3.3.4.2 Otherwise, reject promise with e as the reason</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x.</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 2.2.1 Both onFulfilled and onRejected are optional arguments:</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === PENDING)&#123;</span><br><span class="line">        self.resolveCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">              resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        self.rejectCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(self.reason)</span><br><span class="line">              resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === FULFILLED)&#123;  <span class="comment">// 2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value)  <span class="comment">// 2.2.2.1 it must be called after promise is fulfilled, with promise’s value as its first argument.</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === REJECTED)&#123;  <span class="comment">// 2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.reason)</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2;  <span class="comment">// 2.2.7 then must return a promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整理一下，最终版本"><a href="#整理一下，最终版本" class="headerlink" title="整理一下，最终版本"></a>整理一下，最终版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.state = <span class="string">'pending'</span>;</span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  self.reason = <span class="literal">null</span>;</span><br><span class="line">  self.onFulfilledCallback = [];</span><br><span class="line">  self.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      self.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.onFulfilledCallback.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      self.state = <span class="string">'rejected'</span>;</span><br><span class="line">      self.reason = reason;</span><br><span class="line">      self.onRejectedCallback.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(promise2 === x) &#123;   <span class="comment">//2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'circular reference'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;  <span class="comment">// 2.3.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span></span><br><span class="line">  <span class="keyword">if</span>(x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;    <span class="comment">// 2.3.3  if x is an object or function,</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;    <span class="comment">// 2.3.3.1 Let then be x.then</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;  <span class="comment">// 2.3.3.3 If then is a function, call it with x as self, first argument resolvePromise, and second argument rejectPromise, where:</span></span><br><span class="line">        then.call(x, y=&gt;&#123;</span><br><span class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;   <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject)  <span class="comment">// 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span></span><br><span class="line">        &#125;, reason=&gt;&#123;</span><br><span class="line">          <span class="keyword">if</span>(called) <span class="keyword">return</span>;  <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(reason)  <span class="comment">// 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 2.3.3.4 If then is not a function, fulfill promise with x.</span></span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;  <span class="comment">// 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span></span><br><span class="line">      <span class="keyword">if</span>(called) <span class="keyword">return</span>;  <span class="comment">// 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span></span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e)  <span class="comment">// 2.3.3.3.4.2 Otherwise, reject promise with e as the reason</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x.</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 2.2.1 Both onFulfilled and onRejected are optional arguments:</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.state === PENDING)&#123;</span><br><span class="line">        self.resolveCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(self.value)</span><br><span class="line">              resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        self.rejectCallback.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(self.reason)</span><br><span class="line">              resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === FULFILLED)&#123;  <span class="comment">// 2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value)  <span class="comment">// 2.2.2.1 it must be called after promise is fulfilled, with promise’s value as its first argument.</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.state === REJECTED)&#123;  <span class="comment">// 2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.reason)</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)  <span class="comment">// 2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)  <span class="comment">// 2.2.7.2 If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2;  <span class="comment">// 2.2.7 then must return a promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="安装promises-aplus-tests"><a href="#安装promises-aplus-tests" class="headerlink" title="安装promises-aplus-tests"></a>安装promises-aplus-tests</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g promises-aplus-tests</span><br></pre></td></tr></table></figure><h4 id="添加测试代码"><a href="#添加测试代码" class="headerlink" title="添加测试代码"></a>添加测试代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = &#123;&#125;;</span><br><span class="line">  defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    defer.resolve = resolve;</span><br><span class="line">    defer.reject = reject;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure><h4 id="测试结果-872-passing"><a href="#测试结果-872-passing" class="headerlink" title="测试结果(872 passing)"></a>测试结果(872 passing)</h4><p><img src="/2018/08/03/promise/promiseTest.png" alt="测试结果"></p><h2 id="Promise-其他常用方法实现"><a href="#Promise-其他常用方法实现" class="headerlink" title="Promise 其他常用方法实现"></a>Promise 其他常用方法实现</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise.catch"></a>promise.catch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">promise, i</span>)=&gt;</span>&#123;</span><br><span class="line">      promise.then(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">        result[i] = val</span><br><span class="line">        <span class="keyword">if</span>(++index === arr.length) &#123;  <span class="comment">// 由于then注册的回调函数是异步执行的，无法确定回调函数什么时候执行完成，所以必须得把判断放到回调函数中，这样才能确保所有的异步任务执行完成后在调用resolve</span></span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">promise, i</span>)=&gt;</span>&#123;</span><br><span class="line">      promise.then(resolve, reject);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;p&gt;模拟实现一个符合&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Promise A+规范&lt;/a&gt;的promise，仅供学习其实现原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jsyt/promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址链接&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://goyth.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jsyt/jsyt.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github博客主页&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Promise的详细使用方法可参考&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰老师的文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="Promise" scheme="http://www.goyth.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>HTTP知识点整理</title>
    <link href="http://www.goyth.com/2018/07/11/http2/"/>
    <id>http://www.goyth.com/2018/07/11/http2/</id>
    <published>2018-07-11T12:25:51.000Z</published>
    <updated>2018-12-02T08:39:10.321Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。于2015年正式发布，HTTP/2解决了HTTP1.1线头阻塞、重复建立TCP连接等问题，充分利用TCP连接的高效传输，使得网络延迟大幅下降，网络传输速度大幅提升。</p><a id="more"></a><h2 id="HTTP-0-9-1991"><a href="#HTTP-0-9-1991" class="headerlink" title="HTTP/0.9 - 1991"></a>HTTP/0.9 - 1991</h2><p>第一版的HTTP文档是1991年提出来的 HTTP/0.9。这是有史以来最简单的协议；它仅有一个GET方法。如果客户端要访问服务器上的一些网页，它会作出如下的简单请求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></p><p>并且来自服务器的响应内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure></p><p>也就是说，服务器会得到这个请求，然后通过HTML格式回复响应内容，且一旦响应内容发送完毕，就会关闭这个连接。归纳一下：</p><ul><li>没有header数据块</li><li>GET方法是唯一允许的方法</li><li>必须以HTML格式响应</li></ul><h2 id="HTTP-1-0-1996"><a href="#HTTP-1-0-1996" class="headerlink" title="HTTP/1.0 - 1996"></a>HTTP/1.0 - 1996</h2><p>1996年，HTTP/1.0 诞生了，它在原版本上做出了极大的改善。不像 HTTP/0.9 仅能以HTML格式响应，HTTP/1.1 现在可以处理其他的响应格式了，例如：图像，视频文件，纯文本或其他任何的内容类型。它增加了更多的方法（即 POST 和 HEAD），请求/响应的格式也发生了改变，请求和响应中均加入了HTTP头信息，响应数据还增加了状态码标识，还介绍了字符集的支持、多部分发送、权限、缓存、内容编码等很多内容。</p><p>如下所示，这是一个通过 HTTP/1.0 请求和响应的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.0</span></span><br><span class="line">Host: kamranahmed.info</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_10_5)</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>正如你所见，客户端除了发送请求以外，它还发送了它的个人信息，要求响应类型等。而在 HTTP/0.9 中因为没有头信息，客户端是不会发送这些信息的。</p><p>上面的例子对应的服务器响应结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: <span class="number">137582</span></span><br><span class="line">Expires: Thu, <span class="number">05</span> Dec <span class="number">1997</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span> GMT</span><br><span class="line">Last-Modified: Wed, <span class="number">5</span> August <span class="number">1996</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">28</span> GMT</span><br><span class="line">Server: Apache <span class="number">0.84</span></span><br><span class="line"></span><br><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure><p>在这个新版本中，请求和响应的头信息仍然采用 ASCII 编码方式，但具体的响应内容可以是任何类型的，例如：图像、视频、HTML、纯文本或任何其他的内容类型。因此，现在的服务器端可以向客户端发送任何内容类型的数据；</p><p>HTTP/1.0的主要缺点之一是，你不能在每个连接中发送多个请求。也就是说，每当客户端要向服务器端请求东西时，它都会打开一个新的TCP连接，并且在这个单独请求完成后，该连接就会被关闭。且对于下个需求时，它必须再创建一个新的连接。为什么会如此糟糕呢？好吧，来让我们做个假设，假设你需要访问一个包含10张图片、5个样式表和5个JS文件的网页，这是一个共20项内容要请求的网页。由于服务器会在每个请求完成后将连接关闭，所以，这将会有一系列的20个独立的连接，每个项目均有一个单独的连接。因为三次握手和其后的缓慢启动机制，若每次请求都创建一个新的TCP连接，这就会带来明显的性能损失，最终的结果就是，这些大量的连接会导致严重的性能下降。</p><h2 id="HTTP-1-1-1999"><a href="#HTTP-1-1-1999" class="headerlink" title="HTTP/1.1 - 1999"></a>HTTP/1.1 - 1999</h2><p>1999年发布了HTTP/1.1，这是目前使用最广泛的一个版本，相对于HTTP/1.0，HTTP/1.1主要改进内容包含：</p><ul><li><p>新增的HTTP方法PUT、PATCH、HEAD、OPTIONS、DELETE</p></li><li><p>主机名标识 在 HTTP/1.0 中，Host头信息不是必须项，但 HTTP/1.1 中要求必须要有Host头信息。</p></li><li><p>持久性连接 正如前面所说，在 HTTP/1.0 中每个连接只有一个请求 ，且在这个请求完成后该连接就会被关闭，从而会导致严重的性能下降及延迟问题。HTTP/1.1 引入了对持久性连接的支持，例如： 默认情况下连接不会被关闭，在多个连续的请求下它会保存连接的打开状态。想要关闭这些连接，需要将 Connection: close 加入到请求的头信息中。客户端通常会在最后一次请求中发送这个头信息用来安全的关闭连接。</p></li><li><p>管道机制 HTTP/1.1也引入了对管道机制的支持，客户端可以向服务器发送多个请求，而无需等待来自同一连接上的服务器响应，并且当收到请求时服务器必须以相同的顺序来响应。但你可能会问：客户端是怎么知道第一个响应下载完成和下一个响应内容开始的？要解决这个问题，必须要有Content-Length头信息，客户端可以用它来确定响应结束，然后开始等待下一个响应。</p></li></ul><p>应该注意的是，为了从持久性连接或管道机制中获益，Content-Length头信息必须在可用的响应中，因为这会让客户端知道当传输完成后，它可以发送下一个请求（用正常顺序发送请求的方式）或者开始等待下一个响应（当启用了管道机制时）。</p><p>但这种方法仍然存在一个问题：如果数据是动态的，且服务器找不到之前的内容长度时怎么办？那么，在这种情况下，你就真的不能从持久性连接中收益了，不是吗？！为了解决这个问题，在 HTTP/1.1 中引入了分块编码的支持。在这种情况下，服务器可能会忽略 Content-Length 并支持分块编码。然而，如果他们没有可用的数据，那么连接必须在请求结束时关闭。</p><ul><li><p>分块传输 在动态内容的情况下，当传输开始时服务器无法找到 Content-Length 头信息的话，它也可以开始以块的方式发送内容（一块一块的发），并且当每个小块发送后，它会给每个块添加一个 Content-Length 头信息。当所有的块发送完成后（即整个传输已经完成），它会发送一个空的块（即 Content-Length 为零的块）以确定客户端的传输已经完成。为了通知客户端采用分块传输的方式，服务器需要在头信息中包含<code>Transfer-Encoding: chunked</code></p></li><li><p>不像HTTP/1.0 只有基本的身份验证，HTTP/1.1 还包含摘要和代理验证</p></li><li>高速缓存</li><li>字节范围</li><li>字符集</li><li>谈判语言</li><li>客户端cookie</li><li>加强对压缩的支持</li><li>新的状态代码</li></ul><p>虽然HTTP/1.1对上一版协议进行了很多改进，但web世界每天都在改变，它开始显现出了它的不足。现在访问的网页与以前相比包含的资源更多。一个简单的网页都会至少打开30个连接。 我们知道 HTTP/1.1 是持久连接，那为什么还需要这么多连接？你会说这是由于HTTP/1.1在任何时刻都只有一个有效连接。 HTTP/1.1尝试通过pipeline来解决这个问题，但是它并没有完全的解决，因为在pipeline中虽然请求可以在应答回来之前一一发送，但是客户端还是必须得按照请求的顺序来接受应答。为了克服HTTP/1.1的这些缺点， 开发人员开始尝试一些解决方案，如：在CSS中使用雪碧图、图像编码 ，合并CSS或Javascript文件, 域名分片（将多个资源分别放入不同的子域名下）等等。</p><h2 id="SPDY-2009"><a href="#SPDY-2009" class="headerlink" title="SPDY - 2009"></a>SPDY - 2009</h2><p>Google走在前面，它开始试验一种可替换的协议来减少网页的延迟，使得网页加载更快、提升web安全性 。 2009年, 他们称这种协议为SPDY。</p><p>SPDY是谷歌的一个商标,不是一个缩写词。</p><p>它们意识到如果继续增加带宽来提升网络性能的过程中，必然在到达某一个点后不会再带来更多提升。在有延迟的情况下如果我们不断减少延迟，那么性能建会是一个常数。这是 SPDY性能提升背后的核心理概念，减少延迟来提升网络性能。</p><p>对于那些不知道这两个概念的人， 延迟即数据从源传输到目标的耗时(以毫秒为单位)，带宽就是每秒传输的数据量(比特/秒).</p><p> SPDY的功能包含： 多路复用, 压缩, 优先级, 安全等。我不打算进入SPDY的细节，在进入下一节HTTP / 2后就会明白，HTTP / 2主要受SPDY的启发。</p><p>SPDY 没有真正试图替换HTTP，它任然是存在于应用层的基于HTTP的传输层，它在请求发送前进行一些修改。 它开始成为一个事实上的标准，大多数的浏览器开始实现它。</p><p>2015年,谷歌不想存在两个相互竞争的标准，因此他们决定把它合并到HTTP中成为HTTP/2，同时放弃SPDY。</p><h2 id="HTTP-2-2015"><a href="#HTTP-2-2015" class="headerlink" title="HTTP/2 - 2015"></a>HTTP/2 - 2015</h2><p> HTTP/2 是专为低延迟传输的内容而设计。 关键特征或与 HTTP / 1.1 旧版本的差异，如下：</p><ul><li>二进制，而不是文本</li><li>多路复用- 在单个连接中多个异步HTTP请求</li><li>使用HPACK头部压缩</li><li>数据流优先级</li><li>服务端推送 - 单请求多个响应</li></ul><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p><img src="http2/http01.svg" alt=""></p><p>这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。</p><p>这样一来，客户端和服务器为了相互理解，都必须使用新的二进制编码机制：HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然。不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器会替我们完成必要的分帧工作。</p><h4 id="数据流、消息和帧"><a href="#数据流、消息和帧" class="headerlink" title="数据流、消息和帧"></a>数据流、消息和帧</h4><p><img src="http2/http02.svg" alt=""></p><p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念：</p><ul><li>数据流(Stream)：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息(Message)：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧(Frame)：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的关系总结如下：</p><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p>说通俗点就是HTTP 消息是由一个或多个帧组成的。有一个叫做 HEADERS 的帧存放元数据，真正的数据是放在 DATA 帧中的，帧类型定义在the HTTP/2 specs(HTTP/2规范)，如(HEADERS, DATA, RST_STREAM, SETTINGS, PRIORITY 等)。</p><p>每个HTTP / 2请求和响应都被赋予一个唯一的流ID且放入了帧中。帧就是一块二进制数据。 一系列帧的集合就称为流。 每个帧都有一个流id，用于标识它属于哪一个流，每一个帧都有相同的头。同时，除了流标识是唯一的，值得一提的是，客户端发起的任何请求都使用奇数和服务器的响应是偶数的流id。</p><p>除了 HEADERS和 DATA， 另外一个值得说一说帧类型是RST_STREAM，它是一个特殊的帧类型用于中止流，如：客户端发送这儿帧来告诉服务器我不再需要这个流了。在 HTTP/1.1 中只有一种方式来实现服务器停止发送响应给客户端，那就是关闭连接引起延迟增加，因为后续的请求就需要打开一个新的连接。 在HTTP/2中，客户端可以使用RST_FRAME来停止接收指定的流而不关闭连接且还可以在此连接中接收其它流。</p><p>简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。这是 HTTP/2 协议所有其他功能和性能优化的基础。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="http2/http03.svg" alt=""></p><p>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接（请参阅<a href="https://hpbn.co/http1x/#using-multiple-tcp-connections" target="_blank" rel="noopener">使用多个 TCP 连接</a>）。这是 HTTP/1.x 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。</p><p>HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。</p><p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>使用一个连接并行发送多个请求和响应。</li><li>不必再为绕过 HTTP/1.x 限制而做很多工作（请参阅<a href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x" target="_blank" rel="noopener">针对 HTTP/1.x 进行优化</a>，例如级联文件、image sprites 和域名分片。</li><li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li></ul><p>HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，应用速度更快、开发更简单、部署成本更低。</p><h3 id="头部压缩（Hpack）"><a href="#头部压缩（Hpack）" class="headerlink" title="头部压缩（Hpack）"></a>头部压缩（Hpack）</h3><p>每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：</p><ul><li>这种格式支持通过静态 Huffman 代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li><li>这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。</li></ul><p>利用 Huffman 编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。</p><p>头部压缩的过程如下图所示：</p><p><img src="http2/http05.svg" alt=""></p><ul><li>连接会维持一个查找表，该查找表中给出了62个常用字段及其默认值（来自对多个常用网站中请求的统计）。</li><li>在第一次请求时，会首先查看查找表中对应字段的值是否为本次请求携带的值，如果不是则更改这个查找表，同时增加查找表中没有的字段。在查找表中将所有头部添加完成后才根据查找表对头部进行压缩并发送请求。</li><li>在接下来的每次请求中（当前连接），报文中的压缩数据仅包含查找表中被修改的字段。鉴于一个连接中很多请求中大部分头部字段携带的值都是不常变化的，此举可以大大降低头部传输</li></ul><p>作为一种进一步优化方式，HPACK 压缩上下文包含一个静态表和一个动态表：静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表；动态表最初为空，将根据在特定连接内交换的值进行更新。因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p><p><em>注：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 :method、:scheme、:authority 和 :path 伪标头字段。</em></p><h3 id="数据流优先级"><a href="#数据流优先级" class="headerlink" title="数据流优先级"></a>数据流优先级</h3><p>在HTTP/2中，请求和响应是可以乱序传输的，因此我们需要一个机制可以确保哪些被其他响应数据所依赖的或者关键资源被优先传输，以使网页的呈现和使用具有最好的体验。HTTP/2中在流的层面，采用了“优先级树”的形式确保响应数据能够按照依赖关系和优先级顺序来传输。</p><p><img src="http2/http04.svg" alt=""></p><p>“优先级树”可以表示成如上图所示的样子。其中子节点所表示的流响应依赖于父节点流，因此父节点流应该被优先传输。在兄弟节点中，被分配权重较大的点应该被分配更多的网络资源，被优先传输。 如下图中(3)所示的“优先级树”中，A,B依赖于C，C依赖于D，因此D应该被优先传输，D传输完后才应该传输C，同理C传输完成后才应该传输A,B，A,B的数据在传输过程中所占用的网络资源应遵循3:1的关系。</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p><img src="http2/http06.svg" alt=""></p><p>HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p><p>为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p><p>事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产（请参阅资源内联），那么您就已经亲身体验过服务器推送了。对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：</p><ul><li>由客户端缓存</li><li>在不同页面之间重用</li><li>与其他资源一起复用</li><li>由服务器设定优先级</li><li>被客户端拒绝</li></ul><h4 id="PUSH-PROMISE-101"><a href="#PUSH-PROMISE-101" class="headerlink" title="PUSH_PROMISE 101"></a>PUSH_PROMISE 101</h4><p>所有服务器推送数据流都由 PUSH_PROMISE 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。满足此要求的最简单策略是先于父响应（即，DATA 帧）发送所有 PUSH_PROMISE 帧，其中包含所承诺资源的 HTTP 标头。</p><p>在客户端接收到 PUSH_PROMISE 帧后，它可以根据自身情况选择拒绝数据流（通过 RST_STREAM 帧）。 （如果资源已经位于缓存中，可能会发生这种情况。） 这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源。</p><p>使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。这些优先级在 HTTP/2 连接开始时通过 SETTINGS 帧传输，可能随时更新。</p><p>推送的每个资源都是一个数据流，与内嵌资源不同，客户端可以对推送的资源逐一复用、设定优先级和处理。 浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策：服务器对所提供内容必须具有权威性。</p><h2 id="去除某些针对HTTP-1-x的优化"><a href="#去除某些针对HTTP-1-x的优化" class="headerlink" title="去除某些针对HTTP/1.x的优化"></a>去除某些针对HTTP/1.x的优化</h2><p>在HTTP/1.x中存在一些用于Web性能提升的“奇技淫巧”，但这些技术可能在HTTP/2中起到相反的作用，因此我们第一步就是先去除这些可能会妨碍性能的优化。</p><p>###域名分片（domain sharding）<br>HTTP/1.x中，通信两端最多只有六个连接，且是通过区分不同域名来维持管理的。为了突破这个限制，通常会把请求资源至于不同的域名下（如 shard1.example.org, shard2.example.org）。而在HTTP/2中，因为不需要新开连接来解决头阻塞问题，所以不需要通过这种方式来增加通信的连接数。相反的在HTTP/2中采用域名分片会造成以下两个问题：</p><ul><li>增加DNS域名解析时间</li><li>增加传输中压缩头部的大小。前文已经提到，头部压缩中的数据复用是在一个连接上维持的，域名分片后新开的连接无法复用之前已经发送过的头部数据，造成一些不必要地数据在网络上的传输。</li></ul><h3 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h3><p>HTTP/1.x中，为了减少请求多个图片带来的头阻塞问题，通常采用把多个图片拼接成一个大图，然后一个请求将所有图片加载在浏览器中，然后使用CSS技术将所需要的部分按需展示出来。显然的，雪碧图会带来如下问题：</p><ul><li>增加代码量，需要写一些本不必要地CSS代码</li><li>在浏览器渲染过程中，内存中需要加载更多的图片内容</li></ul><p>###拼接JavaScript CSS<br>同雪碧图的原理一样，拼接JavaScript、CSS的做法同样是为了减少请求数，以避免潜在的头阻塞问题。在HTTP/2中，因为不存在头阻塞问题，因此应该避免这种优化方式带来的一些不必要地资源的加载。</p><hr><p><em>参考链接：<br><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a><br><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP/2</a><br><a href="https://juejin.im/post/59e46b2651882578b8185a05" target="_blank" rel="noopener">https://juejin.im/post/59e46b2651882578b8185a05</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。于2015年正式发布，HTTP/2解决了HTTP1.1线头阻塞、重复建立TCP连接等问题，充分利用TCP连接的高效传输，使得网络延迟大幅下降，网络传输速度大幅提升。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="HTTP/2" scheme="http://www.goyth.com/tags/HTTP-2/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket知识点梳理</title>
    <link href="http://www.goyth.com/2018/07/09/webSocket/"/>
    <id>http://www.goyth.com/2018/07/09/webSocket/</id>
    <published>2018-07-09T11:53:01.000Z</published>
    <updated>2018-12-02T08:40:27.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h2><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。</p><h2 id="WebSocket解决了什么问题"><a href="#WebSocket解决了什么问题" class="headerlink" title="WebSocket解决了什么问题"></a>WebSocket解决了什么问题</h2><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行<strong>双向数据传输</strong>。<br>简单说就是解决了浏览器和服务器之间双向数据传输的问题。</p><a id="more"></a><h2 id="HTTP协议可以实现双向数据传输吗"><a href="#HTTP协议可以实现双向数据传输吗" class="headerlink" title="HTTP协议可以实现双向数据传输吗"></a>HTTP协议可以实现双向数据传输吗</h2><p>答案肯定是可以的，在HTTP协议中我们通常使用<strong>轮询</strong>来实现双向通信。<br>轮询是通过在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><h2 id="HTTP1-1长连接与WebSocket长连接有什么区别"><a href="#HTTP1-1长连接与WebSocket长连接有什么区别" class="headerlink" title="HTTP1.1长连接与WebSocket长连接有什么区别"></a>HTTP1.1长连接与WebSocket长连接有什么区别</h2><p>HTTP1.1默认启用”Connection: Keep-Alive”，使得在发送完http请求和应答后，不会立刻将连接关闭，在后续的http请求和应答可以继续使用这个连接，避免创建新的TCP连接时三次握手及断开连接时四次挥手的额外消耗。这个keep-alive一般会有固定的时间限制。如Apache是5s，而nginx默认是75s，超过这个时间服务器就会主动把TCP连接关闭了，因为不关闭的话会有大量的TCP连接占用系统资源。所以这个keep-alive并不是为了长连接设计的，只是为了提高http请求的效率。而WebSocket长连接的关闭可以由通过调用相应的API，主动控制。<br>HTTP1.1长连接是无状态的，每一个请求对应一个应答，并且每个请求和应答里面都包含了完整的头部信息；而WebSocket长连接是有状态的，在建立连接后，WebSocket只用携带少量头部字段信息（如数据包长度、掩码），不用携带状态信息。</p><h2 id="WebSocket的优点"><a href="#WebSocket的优点" class="headerlink" title="WebSocket的优点"></a>WebSocket的优点</h2><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li></ul><h2 id="WebSocket兼容性情况"><a href="#WebSocket兼容性情况" class="headerlink" title="WebSocket兼容性情况"></a>WebSocket兼容性情况</h2><p><img src="/2018/07/09/webSocket/ws01.png" alt=""></p><!-- ## WebSocket的缺点 --><h2 id="WebSocket握手协议"><a href="#WebSocket握手协议" class="headerlink" title="WebSocket握手协议"></a>WebSocket握手协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个典型的Websocket握手请求如下：</p><p>客户端请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>服务器回应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws:<span class="comment">//example.com/</span></span><br></pre></td></tr></table></figure><h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。</li></ul><h2 id="帧协议"><a href="#帧协议" class="headerlink" title="帧协议"></a>帧协议</h2><p>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p><p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p><p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC6455 5.2节</a> 。<br><img src="/2018/07/09/webSocket/ws02" alt=""></p><p><strong>FIN</strong>：1个比特。</p><p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p><p><strong>RSV1, RSV2, RSV3</strong>：各占1个比特。</p><p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p><p><strong>Opcode</strong>: 4个比特。</p><p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p><ul><li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li><li>%x1：表示这是一个文本帧（frame）</li><li>%x2：表示这是一个二进制帧（frame）</li><li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li><li>%x8：表示连接断开。</li><li>%x9：表示这是一个ping操作。</li><li>%xA：表示这是一个pong操作。</li><li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li></ul><p><strong>Mask</strong>: 1个比特。</p><p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p><p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p><p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p><p>掩码的算法、用途在下一小节讲解。</p><p><strong>Payload length</strong>：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p><p>假设数Payload length === x，如果</p><ul><li>x为0~126：数据的长度为x字节。</li><li>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。</li><li>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。</li></ul><p>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p><p><strong>Masking-key</strong>：0或4字节（32位）</p><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p><p>备注：载荷数据的长度，不包括mask key的长度。</p><p><strong>Payload data</strong>：(x+y) 字节</p><p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p><p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p><p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p><h3 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h3><p>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p><p>首先，假设：</p><ul><li>original-octet-i：为原始数据的第i字节。</li><li>transformed-octet-i：为转换后的数据的第i字节。</li><li>j：为i mod 4的结果。</li><li>masking-key-octet-j：为mask key第j字节。</li><li>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = i MOD <span class="number">4</span></span><br><span class="line">transformed-octet-i = original-octet-i XOR masking-key-octet-j</span><br></pre></td></tr></table></figure><h3 id="数据掩码的作用"><a href="#数据掩码的作用" class="headerlink" title="数据掩码的作用"></a>数据掩码的作用</h3><p>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p><p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p><p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p><h3 id="跳动检测"><a href="#跳动检测" class="headerlink" title="跳动检测"></a>跳动检测</h3><p>在握手之后的任何时候，客户端或者服务器都可以选择向对方发送 ping 帧。 当收到一个 ping 帧，收件人必须尽快发回一个 pong 帧。 这是一次跳动。 你可以使用它来确保客户端保持着连接。</p><p>ping 帧或 pong 帧只是一个常规的帧，但它是一个控制帧。 ping 帧具有 0x9 的操作码，并且 pong 帧具有 0xA 的操作码。 当你得到一个 ping 帧，发回一个 pong 帧与 ping 帧完全相同的有效载荷数据（对于 pings 和 pongs ，最大有效载荷长度是 125 ）。 你也可能会得到一个 pong 帧返回，而无需再发送一个 ping 帧。如果它发生就忽略它。</p><p>跳动检测可能是非常有用的。 有些服务（如负载均衡器）会终止空闲连接。 另外，接收方无法查看远端是否已经终止。 只有在下一个发送时你会意识到出了问题。</p><h3 id="Sec-WebSocket-Key-Accept的作用"><a href="#Sec-WebSocket-Key-Accept的作用" class="headerlink" title="Sec-WebSocket-Key/Accept的作用"></a>Sec-WebSocket-Key/Accept的作用</h3><p>前面提到了，<code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code>在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p><p>作用大致归纳如下：</p><ul><li>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）</li><li>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）</li><li>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）</li><li>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。</li><li>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li></ul><p><strong>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</strong></p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p><p>WebSocket根据<code>opcode</code>来区分操作的类型。比如<code>0x8</code>表示断开连接，<code>0x0</code>-<code>0x2</code>表示数据交互。</p><h4 id="1、数据分片"><a href="#1、数据分片" class="headerlink" title="1、数据分片"></a>1、数据分片</h4><p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据<code>FIN</code>的值来判断，是否已经收到消息的最后一个数据帧。</p><p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p><p>此外，<code>opcode</code>在数据交换的场景下，表示的是数据的类型。<code>0x01</code>表示文本，<code>0x02</code>表示二进制。而<code>0x00</code>比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p><h4 id="2、数据分片例子"><a href="#2、数据分片例子" class="headerlink" title="2、数据分片例子"></a>2、数据分片例子</h4><p>直接看例子更形象些。下面例子来自<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">MDN</a>，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p><p><strong>第一条消息</strong></p><p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p><p><strong>第二条消息</strong></p><ol><li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li><li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li><li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"hello"</span></span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"and a"</span></span><br><span class="line">Server: (listening, <span class="keyword">new</span> message containing text started)</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"happy new"</span></span><br><span class="line">Server: (listening, payload concatenated to previous message)</span><br><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"year!"</span></span><br><span class="line">Server: (process complete message) Happy <span class="keyword">new</span> year to you too!</span><br></pre></td></tr></table></figure><h2 id="Websocket-API"><a href="#Websocket-API" class="headerlink" title="Websocket API"></a>Websocket API</h2><h3 id="WebSocket-的用法示例"><a href="#WebSocket-的用法示例" class="headerlink" title="WebSocket 的用法示例"></a>WebSocket 的用法示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>);</span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见这里。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p>readyState属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h3><p>实例对象的send()方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的onerror属性，用于指定报错时的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><em>参考链接：<br><a href="https://zh.wikipedia.org/zh-cn/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/WebSocket</a><br><a href="https://juejin.im/post/5b0a31f851882538bb0cfae2" target="_blank" rel="noopener">https://juejin.im/post/5b0a31f851882538bb0cfae2</a><br><a href="https://cloud.tencent.com/document/product/214/4150?fromSource=gwzcw.93403.93403.93403" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/214/4150?fromSource=gwzcw.93403.93403.93403</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a><br><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">https://www.zhihu.com/question/20215561</a><br><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg</a><br><a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-5" target="_blank" rel="noopener">https://www.oschina.net/translate/how-does-javascript-actually-work-part-5</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是WebSocket&quot;&gt;&lt;a href=&quot;#什么是WebSocket&quot; class=&quot;headerlink&quot; title=&quot;什么是WebSocket&quot;&gt;&lt;/a&gt;什么是WebSocket&lt;/h2&gt;&lt;p&gt;WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。&lt;/p&gt;
&lt;h2 id=&quot;WebSocket解决了什么问题&quot;&gt;&lt;a href=&quot;#WebSocket解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;WebSocket解决了什么问题&quot;&gt;&lt;/a&gt;WebSocket解决了什么问题&lt;/h2&gt;&lt;p&gt;WebSocket使得客户端和服务器之间的数据交换变得更加简单，&lt;strong&gt;允许服务端主动向客户端推送数据&lt;/strong&gt;。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建&lt;strong&gt;持久性的连接&lt;/strong&gt;，并进行&lt;strong&gt;双向数据传输&lt;/strong&gt;。&lt;br&gt;简单说就是解决了浏览器和服务器之间双向数据传输的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="webSocket" scheme="http://www.goyth.com/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>DNS知识点梳理</title>
    <link href="http://www.goyth.com/2018/07/07/DNS/"/>
    <id>http://www.goyth.com/2018/07/07/DNS/</id>
    <published>2018-07-07T10:29:09.000Z</published>
    <updated>2018-12-02T08:38:53.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。</p><a id="more"></a><p><img src="/2018/07/07/DNS/dns02.png" alt=""></p><p>全世界所有的人每天上网都会使用DNS服务器，如果大家都去同一个地方访问某一台服务器，时延将会非常大，所以DNS服务器的架构必须是分布式、高并发、高可用，如下图：</p><p><img src="/2018/07/07/DNS/dns01.jpg" alt=""></p><ul><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ul><h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>当用户在浏览器中输入<a href="http://www.abc.com并按下回车键后：" target="_blank" rel="noopener">www.abc.com并按下回车键后：</a></p><h3 id="第一步查找本地DNS缓存"><a href="#第一步查找本地DNS缓存" class="headerlink" title="第一步查找本地DNS缓存"></a>第一步查找本地DNS缓存</h3><p>本地DNS缓存有浏览器DNS缓存，操作系统（OS）DNS缓存，路由器DNS缓存，按照浏览器、操作系统、路由器的顺序依次查找<a href="http://www.abc.com对应的DNS缓存，如果缓存命中则停止。" target="_blank" rel="noopener">www.abc.com对应的DNS缓存，如果缓存命中则停止。</a></p><h4 id="1、浏览器DNS缓存"><a href="#1、浏览器DNS缓存" class="headerlink" title="1、浏览器DNS缓存"></a>1、浏览器DNS缓存</h4><p>浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。<br>当浏览器收到一个DNS解析请求后，首先会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。<br><strong>浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。</strong><br>通常每种浏览器都有一个固定的DNS缓存时间，其中Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://net-internals/#dns</span><br></pre></td></tr></table></figure></p><h4 id="2、系统（OS）DNS缓存"><a href="#2、系统（OS）DNS缓存" class="headerlink" title="2、系统（OS）DNS缓存"></a>2、系统（OS）DNS缓存</h4><p>如果用户浏览器缓存中没有数据，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，在Linux中可以通过/etc/hosts文件来设置，用户可以将任何域名解析到任何能够访问的IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以有黑客就可能通过修改用户的域名来把特定的域名解析到他指定的IP地址上，导致这些域名被劫持。</p><h3 id="第二步查找ISP-DNS缓存"><a href="#第二步查找ISP-DNS缓存" class="headerlink" title="第二步查找ISP DNS缓存"></a>第二步查找ISP DNS缓存</h3><p>如果本地DNS缓存没有对应的记录，就要用到我们网络配置中的”DNS服务器地址”了。操作系统会把这个域名发送给这个ISP，也就是本地区的域名服务器。这个DNS通常都提供给用户本地互联网接入的一个DNS解析服务，例如用户是在学校接入互联网，那么用户的DNS服务器肯定在学校；如果用户是在小区接入互联网，那么用户的DNS就是再提供接入互联网的应用提供商，即电信或联通，也就是通常说的SPA，那么这个DNS通常也会在用户所在城市的某个角落，不会很远。Windows环境下通过命令行输入ipconfig，Linux环境下通过cat /etc/resolv.conf就可以查询配置的DNS服务器了。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，所以ISP主要承担了域名的解析工作。</p><h3 id="递归搜索"><a href="#递归搜索" class="headerlink" title="递归搜索"></a>递归搜索</h3><p>在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根DNS（即一个完整域名最后面的那个点，通常省略不写）。(2)根DNS将所要查询域名中的顶级域（假设要查询<a href="http://www.abc.com，该域名的顶级域就是.com）的服务器IP地址返回到本地DNS。(3)" target="_blank" rel="noopener">www.abc.com，该域名的顶级域就是.com）的服务器IP地址返回到本地DNS。(3)</a> 本地DNS根据返回的IP地址，再向顶级域（就是.com域）发送请求。(4) .com域服务器再将域名中的权威域名服务器（abc.com）的IP地址返回给本地DNS。(5) 本地DNS再向权威域名服务器（abc.com）发送请求进行查询。(6) 权威DNS查询到对应的IP后，就将IP返回给本地DNS服务器，本地 DNS 再将 IP 地址返回客户端。</p><p><img src="/2018/07/07/DNS/dns03.jpg" alt=""></p><h2 id="DNS有关的网络性能优化"><a href="#DNS有关的网络性能优化" class="headerlink" title="DNS有关的网络性能优化"></a>DNS有关的网络性能优化</h2><p>1、减少DNS查找，避免重定向，浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</p><ul><li>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</li><li>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</li><li>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</li></ul><p>2、DNS的预解析<br>DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。 </p><p>在某些浏览器中这个预读取的行为将会与页面实际内容并行发生（而不是串行）。正因如此，某些高延迟的域名的解析过程才不会卡住资源的加载。</p><p>这样可以极大的加速（尤其是移动网络环境下）页面的加载。在某些图片较多的页面中，在发起图片加载请求之前预先把域名解析好将会有至少 5% 的图片加载速度提升。</p><ul><li>打开和关闭 DNS 预读取<br>你可以通过在服务器端发送 <code>X-DNS-Prefetch-Control</code> 报头，或是在文档中使用值为 <code>http-equiv</code> 的 <code>&lt;meta&gt;</code> 标签：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"off"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>您可以通过将 <code>content</code> 的参数设置为<code>on</code>来改变设置。</p><ul><li>强制查询特定主机名<br>你可以通过使用 <code>rel</code> 属性值为 <code>link type</code> 中的 <code>dns-prefetch</code> 的<code>&lt;link&gt;</code> 标签来对特定域名进行预读取：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://www.spreadfirefox.com/"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>在这个例子中，Firefox将预解析域名”<a href="http://www.spreadfirefox.com&quot;。" target="_blank" rel="noopener">www.spreadfirefox.com&quot;。</a></p><p>而且，<code>&lt;link&gt;</code> 元素也可以使用不完整的 URL 的主机名来标记预解析，但这些主机名前必需要有双斜线：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//www.spreadfirefox.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>强制对域名进行预读取在有的情况下很有用, 比如, 在网站的主页上，强制在整个网站上频繁引用的域名的预解析，即使它们不在主页本身上使用。即使主页的性能可能不受影响，这将提高整体站点性能。</p><p>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</p><h2 id="几种域名解析方式"><a href="#几种域名解析方式" class="headerlink" title="几种域名解析方式"></a>几种域名解析方式</h2><p>域名解析记录主要分为A记录、MX记录、CNAME记录、NS记录和TXT记录：</p><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>A代表Address，用来指定域名对应的IP地址，如将item.taobao.com指定到115.238.23.xxx，将switch.taobao.com指定到121.14.24.xxx。A记录可以将多个域名解析到一个IP地址，但是不能将一个域名解析到多个IP地址</p><h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>Mail Exchange，就是可以将某个域名下的邮件服务器指向自己的Mail Server，如taobao.com域名的A记录IP地址是115.238.25.xxx，如果将MX记录设置为115.238.25.xxx，即<a href="mailto:xxx@taobao.com" target="_blank" rel="noopener">xxx@taobao.com</a>的邮件路由，DNS会将邮件发送到115.238.25.xxx所在的服务器，而正常通过Web请求的话仍然解析到A记录的IP地址</p><h3 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h3><p>Canonical Name，即别名解析。所谓别名解析就是可以为一个域名设置一个或者多个别名，如将aaa.com解析到bbb.net、将ccc.com也解析到bbb.net，其中bbb.net分别是aaa.com和ccc.com的别名</p><h3 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h3><p>为某个域名指定DNS解析服务器，也就是这个域名由指定的IP地址的DNS服务器取解析</p><h3 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h3><p>为某个主机名或域名设置说明，如可以为ddd.net设置TXT记录为”这是XXX的博客”这样的说明</p><hr><p><em>参考链接：<br><a href="https://www.cnblogs.com/xrq730/p/4931418.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4931418.html</a><br><a href="http://imweb" target="_blank" rel="noopener">http://imweb</a>.<br><a href="https://blog.csdn.net/kkdelta/article/details/53404005io/topic/55e3ba46771670e207a16bc8s" target="_blank" rel="noopener">https://blog.csdn.net/kkdelta/article/details/53404005io/topic/55e3ba46771670e207a16bc8s</a><br><a href="https://time.geekbang.org/column/article/9895" target="_blank" rel="noopener">https://time.geekbang.org/column/article/9895</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DNS-服务器&quot;&gt;&lt;a href=&quot;#DNS-服务器&quot; class=&quot;headerlink&quot; title=&quot;DNS 服务器&quot;&gt;&lt;/a&gt;DNS 服务器&lt;/h2&gt;&lt;p&gt;DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。DNS就是这样的一位“翻译官”，它的基本工作原理可用下图来表示。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="DNS" scheme="http://www.goyth.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议知识点梳理</title>
    <link href="http://www.goyth.com/2018/07/04/TcpIp/"/>
    <id>http://www.goyth.com/2018/07/04/TcpIp/</id>
    <published>2018-07-04T06:09:31.000Z</published>
    <updated>2019-05-25T02:48:37.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><h3 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h3><p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p><a id="more"></a><p><img src="/2018/07/04/TcpIp/tcpip" alt=""></p><ul><li>物理层将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换</li><li>链路层代表驱动</li><li>网络层<ul><li>使用 IP 协议，IP 协议基于 IP 转发分包数据</li><li>IP 协议是个不可靠协议，不会重发</li><li>IP 协议发送失败会使用ICMP 协议通知失败</li><li>ARP 解析 IP 中的 MAC 地址，MAC 地址由网卡出厂提供</li><li>IP 还隐含链路层的功能，不管双方底层的链路层是啥，都能通信</li></ul></li><li>传输层<ul><li>通用的 TCP 和 UDP 协议<ul><li>TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费</li><li>UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层</li></ul></li></ul></li><li>会话层以上分层<ul><li>TCP/IP 分层中，会话层，表示层，应用层集中在一起</li><li>网络管理通过 SNMP 协议</li></ul></li></ul><h3 id="TCP-IP-协议模型封包解包"><a href="#TCP-IP-协议模型封包解包" class="headerlink" title="TCP/IP 协议模型封包解包"></a>TCP/IP 协议模型封包解包</h3><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p><p><img src="/2018/07/04/TcpIp/tcp02" alt=""></p><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p><p><img src="/2018/07/04/TcpIp/tcp03" alt=""></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><p><img src="/2018/07/04/TcpIp/tcp04" alt=""></p><p><strong>第一次握手</strong>： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br><strong>第二次握手</strong>： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br><strong>第三次握手</strong>： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。<br>如果采用两次握手，那么若Client向Server发起的包A1如果在传输链路上遇到的故障，导致传输到Server的时间相当滞后，在这个时间段由于Client没有收到Server的对于包A1的确认，那么就会重传一个包A2，假设服务器正常收到了A2的包，然后返回确认B2包。由于没有第三次握手，这个时候Client和Server已经建立连接了。再假设A1包随后在链路中传到了Server，这个时候Server又会返回B1包确认，但是由于Client已经清除了A1包，所以Client会丢弃掉这个确认包，但是Server会保持这个相当于“僵尸”的连接，浪费资源。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><p><img src="/2018/07/04/TcpIp/tcp05" alt=""></p><p><strong>第一次分手</strong>： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br><strong>第二次分手</strong>： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br><strong>第三次分手</strong>： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br><strong>第四次分手</strong>： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h4 id="为什么要四次分手？"><a href="#为什么要四次分手？" class="headerlink" title="为什么要四次分手？"></a>为什么要四次分手？</h4><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h4><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二：</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据段从网络中消失</li></ul><p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。<br>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><p><img src="/2018/07/04/TcpIp/06" alt=""></p><h4 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h4><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。</p><h4 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h4><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><h4 id="TCP和UDP协议的一些应用"><a href="#TCP和UDP协议的一些应用" class="headerlink" title="TCP和UDP协议的一些应用"></a>TCP和UDP协议的一些应用</h4><p><img src="/2018/07/04/TcpIp/tcp07" alt=""></p><h4 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><h4 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h4><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>　　原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。<br>　　影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）。RTO的值被设置过大过小都会对协议造成不利影响。<br>　　（1）RTO设长了，重发就慢，没有效率，性能差。<br>　　（2）RTO设短了，重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。<br>　　连接往返时间（RTT，Round Trip Time），指发送端从发送TCP包开始到接收它的立即响应所消耗的时间。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p>作用：（1）提供TCP的可靠性；（2）提供TCP的流控特性 </p><p><img src="/2018/07/04/TcpIp/tcp08.jpg" alt=""></p><p><img src="/2018/07/04/TcpIp/tcp09.jpg" alt=""></p><p>TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。<br>发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。<br>接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p><p><img src="/2018/07/04/TcpIp/tcp10" alt=""></p><p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制<br>TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）。</p><p>发送方维持一个 <strong>拥塞窗口 cwnd ( congestion window )</strong> 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p><img src="/2018/07/04/TcpIp/tcp11" alt=""></p><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<strong>一个传输轮次所经历的时间其实就是往返时间RTT</strong>。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下： </p><ul><li>当cwnd &lt; ssthresh时，使用慢开始算法。 </li><li>当cwnd &gt; ssthresh时，改用拥塞避免算法。 </li><li>当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p><img src="/2018/07/04/TcpIp/tcp12" alt=""></p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<br>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。<br>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p><p><img src="/2018/07/04/TcpIp/tcp13" alt=""></p><p>拥塞控制的具体过程如下：<br>（1）TCP连接初始化，将拥塞窗口设置为1<br>（2）执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长<br>（3）当网络发生拥塞，把ssthresh值更新为拥塞前cwnd值的一半，cwnd重新设置为1，按照步骤（2）执行</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p><img src="/2018/07/04/TcpIp/tcp14" alt=""></p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。<br>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p><strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</strong></p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh设置为cwnd值的一半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为ssthresh的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><p><img src="/2018/07/04/TcpIp/tcp15" alt=""></p><hr><p><em>参考链接：<br><a href="https://blog.csdn.net/qq_26499321/article/details/71429813" target="_blank" rel="noopener">https://blog.csdn.net/qq_26499321/article/details/71429813</a><br><a href="https://juejin.im/post/5ad4094e6fb9a028d7011069" target="_blank" rel="noopener">https://juejin.im/post/5ad4094e6fb9a028d7011069</a><br><a href="https://juejin.im/post/598ba1d06fb9a03c4d6464ab" target="_blank" rel="noopener">https://juejin.im/post/598ba1d06fb9a03c4d6464ab</a><br><a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h2&gt;&lt;p&gt;TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。&lt;/p&gt;
&lt;h3 id=&quot;TCP-IP-协议分层模型&quot;&gt;&lt;a href=&quot;#TCP-IP-协议分层模型&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议分层模型&quot;&gt;&lt;/a&gt;TCP/IP 协议分层模型&lt;/h3&gt;&lt;p&gt;基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。&lt;/p&gt;
    
    </summary>
    
      <category term="Network Protocol" scheme="http://www.goyth.com/categories/Network-Protocol/"/>
    
    
      <category term="TCP/IP" scheme="http://www.goyth.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制梳理</title>
    <link href="http://www.goyth.com/2018/07/01/browseCache/"/>
    <id>http://www.goyth.com/2018/07/01/browseCache/</id>
    <published>2018-07-01T00:52:09.000Z</published>
    <updated>2018-12-02T08:38:29.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><a id="more"></a><p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p><p><img src="/2018/07/01/browseCache/1.webp" alt=""></p><p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图</p><p><img src="/2018/07/01/browseCache/2.webp" alt=""></p><p>注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><p>以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。</p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img src="/2018/07/01/browseCache/3.webp" alt=""></p><p>由上图我们可以知道：</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ul><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</li></ul><p><img src="/2018/07/01/browseCache/4.webp" alt=""></p><ul><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</li></ul><p><img src="/2018/07/01/browseCache/5.webp" alt=""></p><ul><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</li></ul><p><img src="/2018/07/01/browseCache/6.webp" alt=""></p><p><strong><em>那么强制缓存的缓存规则是什么？</em></strong></p><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Control</code>优先级比<code>Expires</code>高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于<code>Expires</code>的值时，直接使用缓存结果。</p><p><strong><em>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</em></strong></p><p>到了HTTP/1.1，<code>Expire</code>已经被<code>Cache-Control</code>替代，原因在于<code>Expires</code>控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么<code>Cache-Control</code>又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，<code>Cache-Control</code>是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li><p><strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存）</p></li><li><p><strong>private</strong>：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值</p></li><li><p><strong>no-cache</strong>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</p></li><li><p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p><strong>max-age=xxx (xxx is numeric)</strong>：缓存内容将在xxx秒后失效</p></li></ul><p>接下来，我们直接看一个例子，如下：</p><p><img src="/2018/07/01/browseCache/7.png" alt=""></p><p>由上面的例子我们可以知道：</p><ul><li><p>HTTP响应报文中<code>expires</code>的时间值，是一个绝对值</p></li><li><p>HTTP响应报文中<code>Cache-Control</code>为<code>max-age=600</code>，是相对值</p></li></ul><p>由于<code>Cache-Control</code>的优先级比<code>expires</code>，那么直接根据<code>Cache-Control</code>的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p><em>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</em></p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><p><strong><em>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</em></strong></p><p><img src="/2018/07/01/browseCache/8.webp" alt=""></p><p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的<strong>Size</strong>值则代表该缓存存放的位置，分别为<strong>from memory cache</strong> 和 <strong>from disk cache</strong>。</p><p><strong><em>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</em></strong></p><p><strong>from memory cache</strong>代表使用内存中的缓存，<strong>from disk cache</strong>则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p><p><strong>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a> –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</strong></p><p>过程如下：</p><ul><li>访问<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></li></ul><p><img src="/2018/07/01/browseCache/9.webp" alt=""></p><ul><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.io/" target="_blank" rel="noopener">https://heyingye.github.io/</a></p></li></ul><p><img src="/2018/07/01/browseCache/10.jpeg" alt=""></p><ul><li>刷新</li></ul><p><img src="/2018/07/01/browseCache/11.webp" alt="from disk memory"></p><p><strong><em>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</em></strong></p><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li><p><strong>内存缓存(from memory cache)</strong>：内存缓存具有两个特点，分别是快速读取和时效性：</p><ul><li><p><strong>快速读取</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p></li><li><p><strong>时效性</strong>：一旦该进程关闭，则该进程的内存则会清空。</p></li></ul></li><li><p><strong>硬盘缓存(from disk cache)</strong>：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p></li></ul><p>在浏览器中，浏览器会在<strong>js</strong>和<strong>图片</strong>等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而<strong>css文件</strong>则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。主要有以下两种情况：</p><ul><li>协商缓存生效，返回<strong>304</strong>，如下</li></ul><p><img src="/2018/07/01/browseCache/12.webp" alt="协商缓存生效，返回304"></p><ul><li>协商缓存失效，返回<strong>200</strong>和请求结果结果，如下</li></ul><p><img src="/2018/07/01/browseCache/13.webp" alt="协商缓存失效，返回200"></p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高。</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h4><ul><li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</li></ul><p><img src="/2018/07/01/browseCache/14.webp" alt="Last-Modified"></p><ul><li><strong>If-Modified-Since</strong> 则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有<code>If-Modified-Since</code>字段，则会根据<code>If-Modified-Since</code>的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为<strong>200</strong>；否则则返回<strong>304</strong>，代表资源无更新，可继续使用缓存文件，如下。</li></ul><p><img src="/2018/07/01/browseCache/15.webp" alt="If-Modified-Since"></p><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><ul><li><strong>Etag</strong> 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</li></ul><p><img src="/2018/07/01/browseCache/16.webp" alt="Etag"></p><ul><li><strong>If-None-Match</strong> 是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，一致则返回<strong>304</strong>，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为<strong>200</strong>，如下。</li></ul><p><img src="/2018/07/01/browseCache/17.webp" alt="If-None-Match"></p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(<code>Expires</code>和<code>Cache-Control</code>)生效则直接使用缓存，若不生效则进行协商缓存(<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回<code>304</code>，继续使用缓存，主要过程如下：</p><p><img src="/2018/07/01/browseCache/18.webp" alt=""></p><p><em>转载自：<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.goyth.com/categories/JavaScript/"/>
    
    
      <category term="browserCache" scheme="http://www.goyth.com/tags/browserCache/"/>
    
  </entry>
  
</feed>
