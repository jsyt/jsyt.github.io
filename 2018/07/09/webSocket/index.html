<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><script src="/js/pace.min.js"></script><link rel="stylesheet" href="https://github.com/HubSpot/pace/raw/master/themes/orange/pace-theme-flash.css"><title>websocket知识点梳理 | GOYTH</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="webSocket"><meta name="description" content="什么是WebSocketWebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。 WebSocket解决了什么问题WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。简单说就是解决了浏览器"><meta name="keywords" content="webSocket"><meta property="og:type" content="article"><meta property="og:title" content="WebSocket知识点梳理"><meta property="og:url" content="http://www.goyth.com/2018/07/09/webSocket/index.html"><meta property="og:site_name" content="GOYTH"><meta property="og:description" content="什么是WebSocketWebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。 WebSocket解决了什么问题WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。简单说就是解决了浏览器"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://www.goyth.com/2018/07/09/webSocket/webSocket/ws01.png"><meta property="og:image" content="http://www.goyth.com/2018/07/09/webSocket/webSocket/ws02"><meta property="og:updated_time" content="2018-12-02T08:40:27.445Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="WebSocket知识点梳理"><meta name="twitter:description" content="什么是WebSocketWebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。 WebSocket解决了什么问题WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。简单说就是解决了浏览器"><meta name="twitter:image" content="http://www.goyth.com/2018/07/09/webSocket/webSocket/ws01.png"><link rel="alternate" href="/atom.xml" title="GOYTH" type="application/atom+xml"><link rel="icon" href="/css/images/favicon.ico"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css"><link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><style type="text/css">@font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal}@font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal}@font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal}@font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic}</style><link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all"><link rel="stylesheet" href="/css/style.css"><script src="/js/jquery-3.1.1.min.js"></script><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/hiero.css"><link rel="stylesheet" href="/css/glyphs.css"><link rel="stylesheet" href="/css/vdonate.css"><link rel="stylesheet" href="/css/my.css"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-0123456789ABCDEF",enable_page_level_ads:!0})</script></head></html><script>var themeMenus={"/":"Home","/archives":"Archives","/categories":"Categories","/tags":"Tags","/about":"About"}</script><body data-spy="scroll" data-target="#toc" data-offset="50"><header id="allheader" class="site-header" role="banner"><div class="clearfix container"><div class="site-branding"><h1 class="site-title"> <a href="/" title="GOYTH" rel="home">GOYTH</a></h1><div class="site-description">I hear and I forget, I see and I remember, I do and I understand.</div><nav id="main-navigation" class="main-navigation" role="navigation"> <a class="nav-open">Menu</a> <a class="nav-close">Close</a><div class="clearfix sf-menu"><ul id="main-nav" class="nmenu sf-js-enabled"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">Tags</a></li><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a></li></ul></div></nav></div></div></header><div id="originBgDiv" style="background:#fff;width:100%"><div style="max-height:600px;overflow:hidden;display:flex;display:-webkit-flex;align-items:center"> <img id="originBg" width="100%" alt="" src=""></div></div><script>function setAboutIMG(){var t="css/images/pose.jpg,https://source.unsplash.com/collection/954550/1920x1080".split(","),e=Math.floor(Math.random()*t.length);t[e].startsWith("http")||0<=t[e].indexOf("://")?document.getElementById("originBg").src=t[e]:document.getElementById("originBg").src="/"+t[e]}bgDiv=document.getElementById("originBgDiv"),location.pathname.match("about")?(setAboutIMG(),bgDiv.style.display="block"):bgDiv.style.display="none"</script><div id="container"><div id="wrap"><div id="content" class="outer"><section id="main" style="float:none"><article id="post-webSocket" style="width:66%;float:left" class="article article-type-post" itemscope itemprop="blogPost"><div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template"><header class="article-header"><h1 class="thumb" class="article-title" itemprop="name"> WebSocket知识点梳理</h1></header><div class="article-meta"> Posted on <a href="/2018/07/09/webSocket/" class="article-date"><time datetime="2018-07-09T11:53:01.000Z" itemprop="datePublished">July 9, 2018</time></a> <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span></div><div class="article-entry" itemprop="articleBody"><h2 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h2><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。它与HTTP协一样，同属于应用层协议。</p><h2 id="WebSocket解决了什么问题"><a href="#WebSocket解决了什么问题" class="headerlink" title="WebSocket解决了什么问题"></a>WebSocket解决了什么问题</h2><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行<strong>双向数据传输</strong>。<br>简单说就是解决了浏览器和服务器之间双向数据传输的问题。</p><a id="more"></a><h2 id="HTTP协议可以实现双向数据传输吗"><a href="#HTTP协议可以实现双向数据传输吗" class="headerlink" title="HTTP协议可以实现双向数据传输吗"></a>HTTP协议可以实现双向数据传输吗</h2><p>答案肯定是可以的，在HTTP协议中我们通常使用<strong>轮询</strong>来实现双向通信。<br>轮询是通过在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><h2 id="HTTP1-1长连接与WebSocket长连接有什么区别"><a href="#HTTP1-1长连接与WebSocket长连接有什么区别" class="headerlink" title="HTTP1.1长连接与WebSocket长连接有什么区别"></a>HTTP1.1长连接与WebSocket长连接有什么区别</h2><p>HTTP1.1默认启用”Connection: Keep-Alive”，使得在发送完http请求和应答后，不会立刻将连接关闭，在后续的http请求和应答可以继续使用这个连接，避免创建新的TCP连接时三次握手及断开连接时四次挥手的额外消耗。这个keep-alive一般会有固定的时间限制。如Apache是5s，而nginx默认是75s，超过这个时间服务器就会主动把TCP连接关闭了，因为不关闭的话会有大量的TCP连接占用系统资源。所以这个keep-alive并不是为了长连接设计的，只是为了提高http请求的效率。而WebSocket长连接的关闭可以由通过调用相应的API，主动控制。<br>HTTP1.1长连接是无状态的，每一个请求对应一个应答，并且每个请求和应答里面都包含了完整的头部信息；而WebSocket长连接是有状态的，在建立连接后，WebSocket只用携带少量头部字段信息（如数据包长度、掩码），不用携带状态信息。</p><h2 id="WebSocket的优点"><a href="#WebSocket的优点" class="headerlink" title="WebSocket的优点"></a>WebSocket的优点</h2><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li></ul><h2 id="WebSocket兼容性情况"><a href="#WebSocket兼容性情况" class="headerlink" title="WebSocket兼容性情况"></a>WebSocket兼容性情况</h2><p><img src="webSocket/ws01.png" alt></p> <h2 id="WebSocket握手协议"><a href="#WebSocket握手协议" class="headerlink" title="WebSocket握手协议"></a>WebSocket握手协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个典型的Websocket握手请求如下：</p><p>客户端请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>服务器回应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws:<span class="comment">//example.com/</span></span><br></pre></td></tr></table></figure><h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。</li></ul><h2 id="帧协议"><a href="#帧协议" class="headerlink" title="帧协议"></a>帧协议</h2><p>客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。</p><p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p><p>发送端：将消息切割成多个帧，并发送给服务端；<br>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；<br>本节的重点，就是讲解数据帧的格式。详细定义可参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC6455 5.2节</a> 。<br><img src="webSocket/ws02" alt></p><p><strong>FIN</strong>：1个比特。</p><p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p><p><strong>RSV1, RSV2, RSV3</strong>：各占1个比特。</p><p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p><p><strong>Opcode</strong>: 4个比特。</p><p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p><ul><li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li><li>%x1：表示这是一个文本帧（frame）</li><li>%x2：表示这是一个二进制帧（frame）</li><li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li><li>%x8：表示连接断开。</li><li>%x9：表示这是一个ping操作。</li><li>%xA：表示这是一个pong操作。</li><li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li></ul><p><strong>Mask</strong>: 1个比特。</p><p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p><p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p><p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p><p>掩码的算法、用途在下一小节讲解。</p><p><strong>Payload length</strong>：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p><p>假设数Payload length === x，如果</p><ul><li>x为0~126：数据的长度为x字节。</li><li>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。</li><li>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。</li></ul><p>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p><p><strong>Masking-key</strong>：0或4字节（32位）</p><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p><p>备注：载荷数据的长度，不包括mask key的长度。</p><p><strong>Payload data</strong>：(x+y) 字节</p><p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p><p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p><p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p><h3 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h3><p>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p><p>首先，假设：</p><ul><li>original-octet-i：为原始数据的第i字节。</li><li>transformed-octet-i：为转换后的数据的第i字节。</li><li>j：为i mod 4的结果。</li><li>masking-key-octet-j：为mask key第j字节。</li><li>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = i MOD <span class="number">4</span></span><br><span class="line">transformed-octet-i = original-octet-i XOR masking-key-octet-j</span><br></pre></td></tr></table></figure><h3 id="数据掩码的作用"><a href="#数据掩码的作用" class="headerlink" title="数据掩码的作用"></a>数据掩码的作用</h3><p>WebSocket协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p><p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。</p><p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p><h3 id="跳动检测"><a href="#跳动检测" class="headerlink" title="跳动检测"></a>跳动检测</h3><p>在握手之后的任何时候，客户端或者服务器都可以选择向对方发送 ping 帧。 当收到一个 ping 帧，收件人必须尽快发回一个 pong 帧。 这是一次跳动。 你可以使用它来确保客户端保持着连接。</p><p>ping 帧或 pong 帧只是一个常规的帧，但它是一个控制帧。 ping 帧具有 0x9 的操作码，并且 pong 帧具有 0xA 的操作码。 当你得到一个 ping 帧，发回一个 pong 帧与 ping 帧完全相同的有效载荷数据（对于 pings 和 pongs ，最大有效载荷长度是 125 ）。 你也可能会得到一个 pong 帧返回，而无需再发送一个 ping 帧。如果它发生就忽略它。</p><p>跳动检测可能是非常有用的。 有些服务（如负载均衡器）会终止空闲连接。 另外，接收方无法查看远端是否已经终止。 只有在下一个发送时你会意识到出了问题。</p><h3 id="Sec-WebSocket-Key-Accept的作用"><a href="#Sec-WebSocket-Key-Accept的作用" class="headerlink" title="Sec-WebSocket-Key/Accept的作用"></a>Sec-WebSocket-Key/Accept的作用</h3><p>前面提到了，<code>Sec-WebSocket-Key/Sec-WebSocket-Accept</code>在主要作用在于提供基础的防护，减少恶意连接、意外连接。</p><p>作用大致归纳如下：</p><ul><li>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）</li><li>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）</li><li>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）</li><li>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。</li><li>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li></ul><p><strong>强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws客户端、ws服务端，其实并没有实际性的保证。</strong></p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p><p>WebSocket根据<code>opcode</code>来区分操作的类型。比如<code>0x8</code>表示断开连接，<code>0x0</code>-<code>0x2</code>表示数据交互。</p><h4 id="1、数据分片"><a href="#1、数据分片" class="headerlink" title="1、数据分片"></a>1、数据分片</h4><p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据<code>FIN</code>的值来判断，是否已经收到消息的最后一个数据帧。</p><p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p><p>此外，<code>opcode</code>在数据交换的场景下，表示的是数据的类型。<code>0x01</code>表示文本，<code>0x02</code>表示二进制。而<code>0x00</code>比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p><h4 id="2、数据分片例子"><a href="#2、数据分片例子" class="headerlink" title="2、数据分片例子"></a>2、数据分片例子</h4><p>直接看例子更形象些。下面例子来自<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">MDN</a>，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p><p><strong>第一条消息</strong></p><p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p><p><strong>第二条消息</strong></p><ol><li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li><li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li><li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"hello"</span></span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x1</span>, msg=<span class="string">"and a"</span></span><br><span class="line">Server: (listening, <span class="keyword">new</span> message containing text started)</span><br><span class="line">Client: FIN=<span class="number">0</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"happy new"</span></span><br><span class="line">Server: (listening, payload concatenated to previous message)</span><br><span class="line">Client: FIN=<span class="number">1</span>, opcode=<span class="number">0x0</span>, msg=<span class="string">"year!"</span></span><br><span class="line">Server: (process complete message) Happy <span class="keyword">new</span> year to you too!</span><br></pre></td></tr></table></figure><h2 id="Websocket-API"><a href="#Websocket-API" class="headerlink" title="Websocket API"></a>Websocket API</h2><h3 id="WebSocket-的用法示例"><a href="#WebSocket-的用法示例" class="headerlink" title="WebSocket 的用法示例"></a>WebSocket 的用法示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>);</span><br><span class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><p>实例对象的所有属性和方法清单，参见这里。</p><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p>readyState属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h3><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用addEventListener方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h3><p>实例对象的send()方法用于向服务器发送数据。</p><p>发送文本的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure><p>发送 Blob 对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送 ArrayBuffer 对象的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h3><p>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h3><p>实例对象的onerror属性，用于指定报错时的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><em>参考链接：<br><a href="https://zh.wikipedia.org/zh-cn/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/WebSocket</a><br><a href="https://juejin.im/post/5b0a31f851882538bb0cfae2" target="_blank" rel="noopener">https://juejin.im/post/5b0a31f851882538bb0cfae2</a><br><a href="https://cloud.tencent.com/document/product/214/4150?fromSource=gwzcw.93403.93403.93403" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/214/4150?fromSource=gwzcw.93403.93403.93403</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a><br><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">https://www.zhihu.com/question/20215561</a><br><a href="https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7aXMdnajINt0C5dcJy2USg</a><br><a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-5" target="_blank" rel="noopener">https://www.oschina.net/translate/how-does-javascript-actually-work-part-5</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></em></p></div><footer class="entry-meta entry-footer"><span class="ico-folder"></span> <a class="article-category-link" href="/categories/Network-Protocol/">Network Protocol</a><span class="ico-tags"></span><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webSocket/">webSocket</a></li></ul><div id="donation_div"></div><script src="/js/vdonate.js"></script><script>var a=new Donate({title:"如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!",btnText:"Donate",el:document.getElementById("donation_div"),wechatImage:"https://raw.githubusercontent.com/jsyt/jsyt.github.io/master/images/WeChat.JPG",alipayImage:"https://raw.githubusercontent.com/jsyt/jsyt.github.io/master/images/ALiPay.JPG"})</script><div id="comment"><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5"><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&((n=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></div></footer></div><nav id="article-nav"> <a href="/2018/07/11/http2/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title"> HTTP知识点整理</div></a> <a href="/2018/07/07/DNS/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">DNS知识点梳理</div></a></nav></article><aside id="sidebar"><div id="toc" class="toc-article"> <strong class="toc-title">Contents</strong><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是WebSocket"><span class="nav-number">1.</span> <span class="nav-text">什么是WebSocket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket解决了什么问题"><span class="nav-number">2.</span> <span class="nav-text">WebSocket解决了什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议可以实现双向数据传输吗"><span class="nav-number">3.</span> <span class="nav-text">HTTP协议可以实现双向数据传输吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-1长连接与WebSocket长连接有什么区别"><span class="nav-number">4.</span> <span class="nav-text">HTTP1.1长连接与WebSocket长连接有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket的优点"><span class="nav-number">5.</span> <span class="nav-text">WebSocket的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket兼容性情况"><span class="nav-number">6.</span> <span class="nav-text">WebSocket兼容性情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket握手协议"><span class="nav-number">7.</span> <span class="nav-text">WebSocket握手协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">7.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段说明"><span class="nav-number">7.2.</span> <span class="nav-text">字段说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#帧协议"><span class="nav-number">8.</span> <span class="nav-text">帧协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#掩码算法"><span class="nav-number">8.1.</span> <span class="nav-text">掩码算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据掩码的作用"><span class="nav-number">8.2.</span> <span class="nav-text">数据掩码的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳动检测"><span class="nav-number">8.3.</span> <span class="nav-text">跳动检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sec-WebSocket-Key-Accept的作用"><span class="nav-number">8.4.</span> <span class="nav-text">Sec-WebSocket-Key/Accept的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据传递"><span class="nav-number">8.5.</span> <span class="nav-text">数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、数据分片"><span class="nav-number">8.5.1.</span> <span class="nav-text">1、数据分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、数据分片例子"><span class="nav-number">8.5.2.</span> <span class="nav-text">2、数据分片例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Websocket-API"><span class="nav-number">9.</span> <span class="nav-text">Websocket API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-的用法示例"><span class="nav-number">9.1.</span> <span class="nav-text">WebSocket 的用法示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-构造函数"><span class="nav-number">9.2.</span> <span class="nav-text">WebSocket 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-readyState"><span class="nav-number">9.3.</span> <span class="nav-text">webSocket.readyState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-onopen"><span class="nav-number">9.4.</span> <span class="nav-text">webSocket.onopen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-onclose"><span class="nav-number">9.5.</span> <span class="nav-text">webSocket.onclose</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-onmessage"><span class="nav-number">9.6.</span> <span class="nav-text">webSocket.onmessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-send"><span class="nav-number">9.7.</span> <span class="nav-text">webSocket.send()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-bufferedAmount"><span class="nav-number">9.8.</span> <span class="nav-text">webSocket.bufferedAmount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-onerror"><span class="nav-number">9.9.</span> <span class="nav-text">webSocket.onerror</span></a></li></ol></li></ol></div></aside></section></div><footer id="footer" class="site-footer"><div class="clearfix container"><div class="site-info"> &copy; 2020 GOYTH All Rights Reserved. <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div class="site-credit"> Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a></div></div></footer><script>var contentdiv=document.getElementById("content");contentdiv.style.minHeight=document.body.offsetHeight-document.getElementById("allheader").offsetHeight-document.getElementById("footer").offsetHeight+"px"</script><script src="/js/my.js"></script></div><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script><script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/scripts.js"></script><script src="/js/bootstrap.js"></script><script src="/js/main.js"></script><div style="display:none"><script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script></div><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><a id="rocket" href="#top" class=""></a><script type="text/javascript" src="/js/totop.js" async=""></script></body>