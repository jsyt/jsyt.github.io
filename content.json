{"meta":{"title":"GOYTH","subtitle":"记录学习的技能和遇到的问题","description":"get busy living or get busy dying","author":"Luke Hu","url":"http://www.goyth.com"},"pages":[{"title":"about","date":"2018-03-30T13:05:14.000Z","updated":"2018-03-30T13:05:14.807Z","comments":true,"path":"about/index.html","permalink":"http://www.goyth.com/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-03-30T12:55:05.000Z","updated":"2018-03-30T13:07:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.goyth.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-03-30T12:44:24.000Z","updated":"2018-03-30T14:13:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.goyth.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript之函数防抖与节流","slug":"debounceAndThrottle","date":"2018-05-10T08:31:07.000Z","updated":"2018-05-11T06:15:12.481Z","comments":true,"path":"2018/05/10/debounceAndThrottle/","link":"","permalink":"http://www.goyth.com/2018/05/10/debounceAndThrottle/","excerpt":"函数防抖（debounce)函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。 根据描述，我们可以用setTimeout来实现一个简单版的防抖函数 第一版1234567891011／*** @ fn 回调函数 * @ delay 延迟时间 *／function debounce(fn, delay)&#123; let timer = null; return function()&#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125;","text":"函数防抖（debounce)函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。 根据描述，我们可以用setTimeout来实现一个简单版的防抖函数 第一版1234567891011／*** @ fn 回调函数 * @ delay 延迟时间 *／function debounce(fn, delay)&#123; let timer = null; return function()&#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; 由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数 第二版123456789101112131415／*** @ fn 回调函数 * @ delay 延迟时间 *／function debounce(fn, delay)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, arg); &#125;, delay); &#125;&#125; 现在我们新增一个立即执行的需求，就是第一次触发后就立即执行，然后再等待n秒后再执行，n秒内如果有触发则重新计时。我们新增一个参数immediate，true表示立即执行，false表示非立即执行 第三版123456789101112131415161718192021222324252627／*** @ fn 回调函数 * @ delay 延迟时间 * @ immediate 是否立即执行 *／function debounce(fn, delay, immediate)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; if(timer)&#123; clearTimeout(timer); &#125; if(immediate)&#123; if(!timer)&#123; fn.apply(context, arg); &#125; timer = setTimeout(function()&#123; timer = null; &#125;, delay); &#125;else&#123; timer = setTimeout(function()&#123; fn.apply(context, arg); &#125;, delay); &#125; &#125;&#125; underscore 实现版本：123456789101112131415161718192021222324252627_.debounce = function(func, wait, immediate) &#123; var timeout, args, context, timestamp, result; var later = function() &#123; var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = _.now(); var callNow = immediate &amp;&amp; !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125;; 函数节流（throttle）函数节流是指每隔n秒钟就执行一次事件，不管你在n秒内触发了多少次事件，都是每隔n秒才执行一次。 可以用定时器和时间戳两种方式实现 时间戳版本123456789101112131415／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let pre = 0; return function()&#123; let now = +new Data(); let remain = now - pre; if(remain &gt;= wait || remain &lt;= 0 )&#123; fn.apply(this, arguments); pre = now; &#125; &#125;&#125; 时间戳版本，第一次会立即触发并执行回调函数，但是最后一次触发如果是在最后一个n秒内发生的，则最后一次触发并不会执行回调函数 定时器版本1234567891011121314151617／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; fn.apply(context, arg); timer = null; &#125;, wait); &#125; &#125;&#125; 定时器版本第一次触发后会在n秒后再执行回调函数，最后一次触发如果是在最后一个n秒内发生，则最后一次触发也会执行回调函数 我们可以结合两个版本的优点实现一个首次会立即执行，最后一次也会执行的版本 时间戳定时器混合版本123456789101112131415161718192021222324252627282930／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let pre = 0， timer = null; return function()&#123; let context = this, arg = arguments, now = +new Data(), remaining = wait - (now - pre); if((remaining &lt; 0 || remaining &gt;= wait))&#123; if(!timer)&#123; fn.apply(this, arguments); pre = now; &#125; timer = setTimeout(function()&#123; pre = now; fn.apply(context, arg); &#125;, wait); &#125;else&#123; clearTimeout(timer); timer = setTimeout(function()&#123; pre = now; fn.apply(context, arg); &#125;, remaining); &#125; &#125;&#125; underscore实现版本12345678910111213141516171819202122232425262728293031323334353637／*** @ func 回调函数 * @ wait 间隔时间 * @ options options.leading = true 表示首次立即执行 options.leading = false 表示首次不立即执行 ；* @ options.trailing = true 表示最后一次执行 options.trailing = false 表示最后一次不执行 *／_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;;&#125;; underscore 的版本有一个很好的地方就是当事件频繁触发时不用一直设置定时器和清除定时器。但是这个版本有两个问题，第一个就是当设置options.leading = false 和 options.trailing = false 首次调用时 remaining = wait if 和 else if 分支都不会进去，这是一个bug；第二个问题就是当设置options.leading = true 和 options.trailing = true 首次调用时 previous = 0 now 等于一个很大的正数，remaining = wait - (now - 0) &lt; 0 数一个很大的负数，timeout = null; !timeout = true 进入 else if 分支的时候，执行timeout = setTimeout(later, remaining);的时候，给定时器设延迟执行，这应该","categories":[{"name":"debounce debounce","slug":"debounce-debounce","permalink":"http://www.goyth.com/categories/debounce-debounce/"}],"tags":[{"name":"debounce","slug":"debounce","permalink":"http://www.goyth.com/tags/debounce/"},{"name":"throttle","slug":"throttle","permalink":"http://www.goyth.com/tags/throttle/"}]},{"title":"基于 Docker 构建前端持续集成开发环境","slug":"dockerDeploy","date":"2018-05-08T09:24:13.000Z","updated":"2018-05-08T09:35:54.892Z","comments":true,"path":"2018/05/08/dockerDeploy/","link":"","permalink":"http://www.goyth.com/2018/05/08/dockerDeploy/","excerpt":"本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。 前置知识： CI（持续集成）：阮一峰老师的关于 CI 的介绍 Docker： Docker 快速入门 目标： 代码无需在本地构建 只需将代码推上 Github ，自动构建 -&gt; 部署 版本易管理，可轻松回退版本","text":"本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。 前置知识： CI（持续集成）：阮一峰老师的关于 CI 的介绍 Docker： Docker 快速入门 目标： 代码无需在本地构建 只需将代码推上 Github ，自动构建 -&gt; 部署 版本易管理，可轻松回退版本 现在开始进入主题第一步： 初始化 Vue 项目（使用vue官方脚手架 vue-cli) 初始化 vue 项目：vue init webpack vue-docker-demo 在项目根目录下编 Dockerfile Dockerfile 内容如下（如果是构建其他项目，比如 angular4，只需安装 angular-cli，将构建参数改成 ng build 即可，大同小异） 1234567891011121314151617181920212223242526272829# 使用 node 6.10.3 的精简版作为基础镜像FROM node:6.10.3-slim# 安装nginxRUN apt-get update \\ &amp;&amp; apt-get install -y nginx# 指定工作目录WORKDIR /app# 将当前目录下的所有文件拷贝到工作目录下COPY . /app/# 声明运行时容器提供服务端口EXPOSE 80# 1. 安装依赖# 2. 运行 npm run buil# 3. 将 dist 目录的所有文件拷贝到 nginx 的目录下# 4. 删除工作目录的文件，尤其是 node_modules 以减小镜像体积# 由于镜像构建的每一步都会产生新层# 为了减小镜像体积，尽可能将一些同类操作，集成到一个步骤中，如下RUN npm install \\ &amp;&amp; npm run build \\ &amp;&amp; cp -r dist/* /var/www/html \\ &amp;&amp; rm -rf /app# 以前台方式启动 nginx CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] 初始化 git， 连接并将代码推送到 Github 仓库 第二步：使用 DaoCloud 搭建 Devops 流程（也可以使用其他公有云服务，差别不大，本文将以简单易操作并且对个人开发者免费的 DaoCloud 为例）1. 注册一个 DaoCloud 账号2. 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 注册一个 DaoCloud 账号 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目，点击“开始创建” 先手动构建一个镜像版本，便于下面用这个镜像版本创建一个应用 连接自有主机（没有自有主机的，也可以使用云端测试环境） tips：可以去购买 vultr 等主机，按照指示流程完成主机接入，大概很简单的三四步操作，注意在完成主机连接后，需要手动在主机上启动 docker（service docker start） 太酷了，我们已经将我们的主机接入了 DaoCloud，接下来就来完成最有意思的一步。 创建一个应用 进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境 稍等片刻，便可以点击“立即部署” 等待完成镜像拉取，待容器列表中的容器起来后，通过地址查看我们部署的 vue 应用 我们已经可以访问到我们刚才部署的 vue 应用了，也表示我们已经将我们的镜像部署到我们的自有主机上去了，此时进入主机查看容器运行情况，可以看到有一个正在运行中的容器，正是我们刚刚部署的，一切都是完美的。 完成到这里，我们可以说已经完成了 99% 的工作，但是还非常重要的最后 1%，那就是真正的自定义持续集成流程，让一切都自动化起来，现在让我们回到刚才 Devops 项目的【流程定义】中去 定义自动构建，自动发布任务回到 Devops 项目里对自动化流程进行定义 首先我们来定义一下自动构建任务，我们设定规则是只有在有新 tag 时才执行构建任务，构建时查找根目录下的 Dockerfile，并以此构建镜像 其次，我们再来定义自动发布任务，当构建任务完成时自动触发自动发布任务，并发布到自有主机的应用上去 至此，我们已经完成了，所有流程控制工作，去测试一下整个流程是否能走通？ 第三步： 测试整个流程回到我们本地，修改一下文本内容，提交，并推送到远端，并且打下我们的第一个版本tag 1.1.1，并将 tag 推送到远端 可以看到，与此同时，我们打 tag 的操作触发了我们定义的 CI 流程 稍等片刻，可以看到我们的应用更新了，对应的版本就是我们刚刚推上去的 1.1.1 我们还可以对应用的版本进行切换，回退等操作 至此，我们在只编写了一个 Dockerfile 配置文件，没有编写脚本的情况下，成功地搭建了一套前端的持续集成开发环境，之后我们只需要专心编写我们的业务代码就好了，打一个 Tag 便可以轻松地完成自动部署上线。 参考链接：https://juejin.im/post/5a142d7b6fb9a0451170c2c7","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.goyth.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.goyth.com/tags/Docker/"}]},{"title":"JavaScript 原型链与继承","slug":"prototypeAndExtend","date":"2018-04-23T04:23:43.000Z","updated":"2018-04-25T02:35:12.000Z","comments":true,"path":"2018/04/23/prototypeAndExtend/","link":"","permalink":"http://www.goyth.com/2018/04/23/prototypeAndExtend/","excerpt":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。","text":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。 12function Person()&#123;&#125; 当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象 1234let person = new Person();person.__proto__ === Person.prototype // truelet person1 = new Person();person1.__proto__ === Person.prototype // true 由于同一个构造函数创建的所有实例对象的__proto__ 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。 1234567891011function Person()&#123;&#125;Person.prototype.name = &quot;Luke&quot;;Person.prototype.age = 18;let person1 = new Person();let person2 = new Person();alert(person1.name) // &quot;Luke&quot;alert(person2.name) // &quot;Luke&quot;Person.prototype.name = &quot;Jack&quot;;alert(person1.name) // &quot;Jack&quot;alert(person2.name) // &quot;Jack&quot; 重写原型对象我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示 12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 在上面的代码中，我们将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。 123let friend = new Person();alert(friend.constructor === Person); //false alert(friend.constructor === Object); //true 如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 原型链及原型链继承每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 1234567891011121314151617181920212223function Super()&#123; this.property = true;&#125;Super.prototype.getSuperValue = function()&#123; return this.property;&#125;function Sub()&#123; this.subproperty = false;&#125;Sub.prototype = new Super(); //继承了 Super Sub.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;let instance = new Sub();console.log(instance.getSuperValue()); //trueconsole.log(instance.__proto__ === Sub.prototype); //trueconsole.log(Sub.prototype.__proto__ === Super.prototype); //true 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。 原型链搜索机制当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。 原型链问题原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 123456789101112131415function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123;&#125;Sub.prototype = new Super(); // 继承了Superlet instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green, black&quot; 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。 构造函数继承（经典继承）即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。 1234567891011121314function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123; Super.call(this); //继承了Super &#125;let instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green&quot; 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。 构造函数继承问题如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。 组合继承是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 123456789101112131415161718192021222324252627282930function Super(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Super.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 (第二次调用Sup构造函数) this.age = age;&#125;Sub.prototype = new Super(); // 继承了Super 原型链上的方法 (第一次调用Sup构造函数)Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。但是美中不足的是，上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。 优化后的组合继承12345678910111213141516171819202122232425262728293031323334function Super(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Super.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 this.age = age;&#125;function F()&#123;&#125;F.prototype = Super.prototype; Sub.prototype = new F(); // 继承了Super 原型链上的方法Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。这是最理想的继承方式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"extend","slug":"JavaScript/extend","permalink":"http://www.goyth.com/categories/JavaScript/extend/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"http://www.goyth.com/tags/prototype/"},{"name":"extend","slug":"extend","permalink":"http://www.goyth.com/tags/extend/"}]},{"title":"JS 的正则表达式","slug":"JSRegExp","date":"2018-04-01T08:22:03.000Z","updated":"2018-04-02T15:32:21.000Z","comments":true,"path":"2018/04/01/JSRegExp/","link":"","permalink":"http://www.goyth.com/2018/04/01/JSRegExp/","excerpt":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符","text":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 先简单的介绍一下语法基本元字符 .： 匹配除了换行符之外的任何单个字符 \\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\\的&#39;b&#39;通常匹配小写&#39;b&#39;，无论它们出现在哪里。如果加了&#39;\\&#39;,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\\*/ 将 ‘ * ‘ 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。 | ： 逻辑或操作符 [ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 . ，\\这些字符都表示其本身 [^ ] ：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*, +, ?, {} 后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \\$ ： 匹配表达式的结束 \\b ：匹配单词边界 \\B ：匹配非单词边界 (?=p) ：匹配 p 前面的位置 (?!p) ：匹配不是 p 前面的位置 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 matchmatch 接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 123456789101112131415161718var str = &apos;For more information, see Chapter 3.4.5.1&apos;; var re = /see (chapter \\d+(\\.\\d)*)/i; var found = str.match(re); console.log(found); // (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;] // 0:&quot;see Chapter 3.4.5.1&quot; // 1:&quot;Chapter 3.4.5.1&quot; // 2:&quot;.1&quot; // index:22 // input:&quot;For more information, see Chapter 3.4.5.1&quot; // length:3 // __proto__:Array(0) // &apos;see Chapter 3.4.5.1&apos; 是整个匹配。 // &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \\d+(\\.\\d)*)&apos;捕获。 // &apos;.1&apos; 是被&apos;(\\.\\d)&apos;捕获的最后一个值。 // &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。 // &apos;input&apos; 属性是被解析的原始字符串。 123456var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replacereplace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer);// newString abc - 12345 - #$*% split接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的&quot;hello&quot;这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪默认贪婪 123var regex = /\\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\\d\\D\\s\\S\\w\\W)都可以等价成这种。比如123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 最多保留2位小数的数字/^([1-9]\\d*|0)(\\.\\d{1,2})?$/ 电话号码/(\\+86)?1\\d{10}/ 身份证/^(\\d{15}|\\d{17}([xX]|\\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o* ， *代表位置 上面说到了 6 种位置元字符 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \\w([a-zA-Z0-9_]) 和 \\W 之间的位置，包括 \\w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\\b/g, &#39;#&#39;) 结果是#hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 &#39;&#39;，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\\Be\\Bl\\Bl\\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\\B\\B\\Be\\Bl\\Bl\\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子-. 千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 &#39;,&#39; 就好了，写成正则就是123123213.replace(/(?=(\\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 &#39;,&#39; 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\\d(?=(\\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 &#39;,&#39; 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组分组主要是括号的使用 分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\\d{4}-\\d{2}-\\d{2}/，这个正则还可以改成分组形式的/(\\d{4})-(\\d{2})-(\\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以1234var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种123452017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\\d{4})[-/.](\\d{2})[-/.](\\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\\d{4})([-/.])(\\d{2})\\2(\\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\\1就匹配\\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 &#39;abbbc&#39; 和这么一个正则 /ab{1,3}bbc/ /ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;)前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则读懂其他人写的正则也是一个很重要的方面。 结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。 操作符： 转义符 \\ 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \\元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f,g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是 以这种模式来分析，再复杂的正则都可以看懂。有一个可视化的正则分析网站 转载自网易考拉前端团队","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"RegExp","slug":"JavaScript/RegExp","permalink":"http://www.goyth.com/categories/JavaScript/RegExp/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"http://www.goyth.com/tags/RegExp/"}]},{"title":"hello","slug":"hello","date":"2018-03-29T14:26:35.000Z","updated":"2018-04-01T09:21:45.000Z","comments":true,"path":"2018/03/29/hello/","link":"","permalink":"http://www.goyth.com/2018/03/29/hello/","excerpt":"hello Hexo Makedown 语法测试一","text":"hello Hexo Makedown 语法测试一 链接个人博客地址I get 10 times more traffic from Google than fromYahoo or MSN. 图片 指定大小图片 引用Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Code普通代码块1alert(&apos;Hello World!&apos;); 指定语言代码块1alert('Hello World!'); 反引号代码块1hello hexo","categories":[{"name":"Diary","slug":"Diary","permalink":"http://www.goyth.com/categories/Diary/"},{"name":"Life","slug":"Diary/Life","permalink":"http://www.goyth.com/categories/Diary/Life/"}],"tags":[{"name":"TEST","slug":"TEST","permalink":"http://www.goyth.com/tags/TEST/"},{"name":"HYT","slug":"HYT","permalink":"http://www.goyth.com/tags/HYT/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-03T08:46:06.221Z","updated":"2018-03-30T13:57:01.000Z","comments":true,"path":"2018/03/03/hello-world/","link":"","permalink":"http://www.goyth.com/2018/03/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick TestsCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://www.goyth.com/categories/test/"}],"tags":[{"name":"TEST","slug":"TEST","permalink":"http://www.goyth.com/tags/TEST/"}]}]}