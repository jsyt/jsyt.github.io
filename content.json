{"meta":{"title":"GOYTH","subtitle":"记录学习的技能和遇到的问题","description":"I hear and I forget, I see and I remember, I do and I understand.","author":"Luke Hu","url":"http://www.goyth.com"},"pages":[{"title":"about","date":"2018-03-30T13:05:14.000Z","updated":"2018-03-30T13:05:14.807Z","comments":true,"path":"about/index.html","permalink":"http://www.goyth.com/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-03-30T12:55:05.000Z","updated":"2018-03-30T13:07:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.goyth.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-03-30T12:44:24.000Z","updated":"2018-03-30T14:13:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.goyth.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript之apply、call和bind的模拟实现","slug":"applyAndCall","date":"2018-05-27T09:25:50.000Z","updated":"2018-05-27T13:29:50.706Z","comments":true,"path":"2018/05/27/applyAndCall/","link":"","permalink":"http://www.goyth.com/2018/05/27/applyAndCall/","excerpt":"apply()apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 null 时，函数上下文为 window。 123456789var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;func.apply(obj, [18, &apos;male&apos;]); // luke 18 male","text":"apply()apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。当第一个参数为 null 时，函数上下文为 window。 123456789var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;func.apply(obj, [18, &apos;male&apos;]); // luke 18 male apply模拟实现12345678910111213141516171819202122Function.prototype.apply2 = function(context, arrArgs)&#123; context = context || window; context.fn = this; let args = []; for(let i=0, len=arrArgs.length; i&lt;len; i++)&#123; args.push(&apos;arrArgs[&apos;+i+&apos;]&apos;); &#125; let result = eval(&apos;context.fn(&apos;+args+&apos;)&apos;); delete context.fn; return result;&#125;// 测试一下var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;func.apply2(obj, [18, &apos;male&apos;]); // luke 18 male call()call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。当第一个参数为 null 时，函数上下文也是 window。 123456789var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;func.call(obj, 18, &apos;male&apos;); // luke 18 male call模拟实现12345678910111213141516171819202122Function.prototype.call2 = function(context)&#123; context = context || window; context.fn = this; let args = []; for(let i=1, len=arguments.length; i&lt;len; i++)&#123; args.push(&apos;arguments[&apos;+i+&apos;]&apos;) &#125; let result = eval(&apos;context.fn(&apos;+args+&apos;)&apos;); delete context.fn; return result;&#125;// 测试一下var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;func.call2(obj, 18, &apos;male&apos;); // luke 18 male bind()bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 12345678910var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;let bindfn = func.bind(obj, 18);bindfn(&apos;male&apos;) // luke 18 male bind模拟实现12345678910111213141516171819202122Function.prototype.bind2 = function()&#123; let context = [].shift.call(arguments) || window; let args = [].slice.call(arguments); let self = this; function Bd()&#123; return self.apply(this instanceof Bd ? this : context, args.concat([].slice.call(arguments))); &#125; Bd.prototype = Object.create(self.prototype); return Bd;&#125;// 测试一下var obj = &#123; name : &apos;luke&apos;&#125;function func(age, gender)&#123; console.log(this.name + &apos; &apos; + age + &apos; &apos; + gender);&#125;let bindfn = func.bind2(obj, 18);bindfn(&apos;male&apos;) // luke 18 male","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"}]},{"title":"浏览器渲染之回流（Reflow）与重绘（Repaint）","slug":"reflowAndRepaint","date":"2018-05-25T10:39:42.000Z","updated":"2018-05-25T14:12:36.378Z","comments":true,"path":"2018/05/25/reflowAndRepaint/","link":"","permalink":"http://www.goyth.com/2018/05/25/reflowAndRepaint/","excerpt":"浏览器渲染流程浏览器渲染流程如下图所示： 大概可以划分成以下几个步骤： 通过HTML解析器解析HTML文本并构建DOM tree 通过CSS解析器解析CSS样式表并构建CSSOM tree 根据DOM tree 和 CSSOM tree 构建 \bRender tree Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Reflow(Layout)进行\b布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。 遍历渲染树，对每一个元素节点进行绘制（Painting） 回流（Reflow）与重绘（Repaint）就分别发生在第四步和第五步","text":"浏览器渲染流程浏览器渲染流程如下图所示： 大概可以划分成以下几个步骤： 通过HTML解析器解析HTML文本并构建DOM tree 通过CSS解析器解析CSS样式表并构建CSSOM tree 根据DOM tree 和 CSSOM tree 构建 \bRender tree Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Reflow(Layout)进行\b布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。 遍历渲染树，对每一个元素节点进行绘制（Painting） 回流（Reflow）与重绘（Repaint）就分别发生在第四步和第五步 回流（Reflow）和重绘（Repaint）的定义回流（Reflow）对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算，并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 重绘（Repaint）当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。 回流（Reflow）和重绘（Repaint）会对性能产生一定的影响，尤其是当引发全局的回流和重绘时。 导致回流（Reflow）和重绘（Repaint）的操作 调整窗口大小 改变字体 增加或者移除样式表 内容变化，比如用户在input框中输入文字 激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活) 操作 class 属性 脚本操作 DOM 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 如何尽量避免回流（Reflow）和重绘（Repaint） 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className，即将多次改变样式属性的操作合并成一次操作： 12345678// 不好的写法var left = 10,top = 10;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;;el.style.background = &apos;#eee&apos;; // 比较好的写法el.className += &quot; theclassname&quot;; 让要操作的元素进行”离线处理”，处理完后一起更新 使用documentFragment对象进行缓存操作,引发一次回流和重绘； 使用display:none技术，只引发两次回流和重绘。原理：由于display属性为none的元素不在渲染树中，对隐藏的元素操 作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 先克隆Dom节点(cloneNode) 修改完后，再用克隆的Dom节点将原来的节点替换掉，只引发一次回流和重绘； 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。因为,它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低 不要用tables布局的一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。因为改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 避免使用CSS的JavaScript表达式，如果css里有expression，每次都会重新计算一遍。","categories":[{"name":"Browser","slug":"Browser","permalink":"http://www.goyth.com/categories/Browser/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"http://www.goyth.com/tags/Browser/"}]},{"title":"N-Sum 问题","slug":"nsum","date":"2018-05-25T09:26:18.000Z","updated":"2018-05-28T02:42:30.343Z","comments":true,"path":"2018/05/25/nsum/","link":"","permalink":"http://www.goyth.com/2018/05/25/nsum/","excerpt":"问题描述给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。 解题思路通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解","text":"问题描述给定一个包含多个整数且排好序的数组 nums 和一个目标值 target，判断 nums 中是否存在 N(N&gt;1) 个元素，使得 N 个元素之和与 target 相等？找出所有满足条件且不重复的N元组。 解题思路通过递归降幂将 N-Sum问题 降幂到 2-Sum 问题，然后采用两边加逼的办法求解 JavaScript 版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @param &#123;number&#125; n * @param &#123;number[]&#125; result * @param &#123;number[]&#125; results 结果集 */function findNsum(nums, target, n, result, results) &#123; if(n&lt;2 || nums.length &lt; n || target &lt; nums[0] * n || target &gt; nums[nums.length-1] * n) return ; if(n === 2)&#123; let l = 0, r = nums.length - 1; while(l &lt; r)&#123; let s = nums[l] + nums[r]; if(s == target)&#123; results.push(result.concat(nums[l], nums[r])); l++; r--; while(l &lt; r &amp;&amp; nums[l] == nums[l-1])&#123; l++; &#125; while(l&lt;r &amp;&amp; nums[r] == nums[r+1])&#123; r--; &#125; &#125;else if(s &lt; target)&#123; l++; while(l &lt; r &amp;&amp; nums[l] == nums[l-1])&#123; l++; &#125; &#125;else&#123; r--; while(l&lt;r &amp;&amp; nums[r] == nums[r+1])&#123; r--; &#125; &#125; &#125; &#125;else&#123; let len = nums.length - n + 1 for(let i = 0 ; i &lt; len; i++)&#123; if(i == 0 || ( i&gt;0 &amp;&amp; nums[i] != nums[i - 1]))&#123; findNsum(nums.slice(i+1), target - nums[i], n - 1, result.concat(nums[i]), results); &#125; &#125; &#125;&#125; Python 版本12345678910111213141516171819202122232425262728def findNsum(nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: # early termination return if N == 2: # two pointers solve sorted 2-sum problem l,r = 0,len(nums)-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 while l &lt; r and nums[r] == nums[r+1]: r -= 1 elif s &lt; target: l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 else: r -= 1 while l &lt; r and nums[r] == nums[r+1]: r -= 1 else: # recursively reduce N for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.goyth.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.goyth.com/tags/Algorithm/"}]},{"title":"浏览器页面渲染流程梳理","slug":"browserRendering","date":"2018-05-23T09:14:52.000Z","updated":"2018-05-25T11:48:33.584Z","comments":true,"path":"2018/05/23/browserRendering/","link":"","permalink":"http://www.goyth.com/2018/05/23/browserRendering/","excerpt":"浏览器渲染基本流程浏览器渲染流程如下图所示： 图片来源：https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ 大概可以划分成以下几个步骤： 通过HTML解析器解析HTML文本并构建DOM tree 通过CSS解析器解析CSS样式表并构建CSSOM tree 根据DOM tree 和 CSSOM tree 构建 \bRender tree Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Layout(Reflow)进行\b布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。 遍历渲染树，对每一个元素节点进行绘制（Painting）","text":"浏览器渲染基本流程浏览器渲染流程如下图所示： 图片来源：https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ 大概可以划分成以下几个步骤： 通过HTML解析器解析HTML文本并构建DOM tree 通过CSS解析器解析CSS样式表并构建CSSOM tree 根据DOM tree 和 CSSOM tree 构建 \bRender tree Render tree 刚构建完后是没有元素节点坐标、尺寸大小等信息的，此时需要通过Layout(Reflow)进行\b布局处理，计算出元素在屏幕上显示的位置，尺寸大小等信息。 遍历渲染树，对每一个元素节点进行绘制（Painting） 解析（Parsing）解析的过程分为两个\b\b步骤：\b词法分析和语法分析。词法分析负责将输入内容分解成一个个有效标记；而语法分析负责根据语言的语法规则分析文档的结构，从而构建解析树。通过词法分析可以将无关的字符（比如空格和换行符）分离出来。 图：从源文档到解析树 解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。 如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。 转译(Translation)\b很多时候，解析树还不是最终产品。解析通常是在转译过程中使用的，而转译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。 图：编译流程 HTML解析解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。 DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：12345678&lt;html&gt; &lt;body&gt; &lt;p&gt; Hello World &lt;/p&gt; &lt;div&gt; &lt;img src=&quot;example.png&quot;/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 可翻译成如下的 DOM 树： 图：示例标记的 DOM 树 解析算法HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。 标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。 标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。 图：HTML 解析流程（摘自 HTML5 规范） CSS解析和 HTML 不同，CSS 是上下文无关的语法。事实上，CSS 规范定义了 CSS 的词法和语法。 WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。 图：解析 CSS 处理脚本和样式表的顺序脚本网络的模型是同步的。网页解析器遇到 &lt;script&gt; 标记时文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。你可以在&lt;script&gt; 标签上添加“defer”属性（&lt;script defer&gt;），这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个async属性，可将脚本标记为异步&lt;script async&gt;），以便由其他线程解析和执行。 预解析WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 样式表另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。 Render tree构建 图：Render tree构建 Render tree是由 DOM 和 CSSOM 组合构建而成的。也是页面可视化元素按照其显示顺序而组成的树，是文档的可视化表示。它的作用是让浏览器按照正确的顺序绘制内容。 Firefox 将Render tree中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。呈现器知道如何布局并将自身及其子元素绘制出来。 呈现树和 DOM 树的关系呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。 有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。 图：呈现树及其对应的 DOM 树 布局（Layout/Reflow）当Render Tree刚构建完时，并不包含元素节点的位置和大小信息。计算这些值的过程称为布局或重排。 HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历。 坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。 布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。 根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。 Dirty 位系统为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。 有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。 全局布局和增量布局全局布局是指触发了整个呈现树范围的布局，触发原因可能包括： 影响所有呈现器的全局样式更改，例如字体大小更改。 屏幕大小调整。 布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。 图：增量布局 - 只有 dirty 呈现器及其子代进行布局 绘制在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。 全局绘制和增量绘制和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。 绘制顺序CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下： 背景颜色 背景图片 边框 子代 轮廓 WebKit 矩形存储在重新绘制之前，WebKit 会将原来的矩形另存为一张位图(Bitmap)，然后只绘制新旧矩形之间的差异部分。 动态变化在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。 参考链接 https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ https://www.youtube.com/watch?v=SmE4OwHztCc https://www.youtube.com/watch?v=0IsQqJ7pwhw","categories":[{"name":"Browser","slug":"Browser","permalink":"http://www.goyth.com/categories/Browser/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"http://www.goyth.com/tags/Browser/"}]},{"title":"JavaScript之函数防抖与节流","slug":"debounceAndThrottle","date":"2018-05-10T08:31:07.000Z","updated":"2018-05-23T15:24:19.853Z","comments":true,"path":"2018/05/10/debounceAndThrottle/","link":"","permalink":"http://www.goyth.com/2018/05/10/debounceAndThrottle/","excerpt":"函数防抖（debounce)函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。 根据描述，我们可以用setTimeout来实现一个简单版的防抖函数","text":"函数防抖（debounce)函数防抖是指在函数调用动作触发n秒后才开始执行，n秒内若再次触发，则重新开始计时，再次等待n秒后才开始执行。如果n秒内不断触发，那就不断重新开始计时，一直等到有一个n秒内没有触发，才开始执行此函数。 根据描述，我们可以用setTimeout来实现一个简单版的防抖函数 第一版1234567891011／*** @ fn 回调函数 * @ delay 延迟时间 *／function debounce(fn, delay)&#123; let timer = null; return function()&#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; 由于setTimeout的回调函数内的this是指向window，如果不传参数则argument对象为空，所以我们得修复this的指向，并将argument对象也传给回调函数 第二版123456789101112131415／*** @ fn 回调函数 * @ delay 延迟时间 *／function debounce(fn, delay)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, arg); &#125;, delay); &#125;&#125; 现在我们新增一个立即执行的需求，就是第一次触发后就立即执行，然后再等待n秒后再执行，n秒内如果有触发则重新计时。我们新增一个参数immediate，true表示立即执行，false表示非立即执行 第三版123456789101112131415161718192021222324252627／*** @ fn 回调函数 * @ delay 延迟时间 * @ immediate 是否立即执行 *／function debounce(fn, delay, immediate)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; if(timer)&#123; clearTimeout(timer); &#125; if(immediate)&#123; if(!timer)&#123; fn.apply(context, arg); &#125; timer = setTimeout(function()&#123; timer = null; &#125;, delay); &#125;else&#123; timer = setTimeout(function()&#123; fn.apply(context, arg); &#125;, delay); &#125; &#125;&#125; underscore 实现版本：123456789101112131415161718192021222324252627_.debounce = function(func, wait, immediate) &#123; var timeout, args, context, timestamp, result; var later = function() &#123; var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = _.now(); var callNow = immediate &amp;&amp; !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125;; 函数节流（throttle）函数节流是指每隔n秒钟就执行一次事件，不管你在n秒内触发了多少次事件，都是每隔n秒才执行一次。 可以用定时器和时间戳两种方式实现 时间戳版本123456789101112131415／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let pre = 0; return function()&#123; let now = +new Data(); let remain = now - pre; if(remain &gt;= wait || remain &lt;= 0 )&#123; fn.apply(this, arguments); pre = now; &#125; &#125;&#125; 时间戳版本，第一次会立即触发并执行回调函数，但是最后一次触发如果是在最后一个n秒内发生的，则最后一次触发并不会执行回调函数 定时器版本1234567891011121314151617／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let timer = null; return function()&#123; let context = this, arg = arguments; if(!timer)&#123; timer = setTimeout(function()&#123; fn.apply(context, arg); timer = null; &#125;, wait); &#125; &#125;&#125; 定时器版本第一次触发后会在n秒后再执行回调函数，最后一次触发如果是在最后一个n秒内发生，则最后一次触发也会执行回调函数 我们可以结合两个版本的优点实现一个首次会立即执行，最后一次也会执行的版本 时间戳定时器混合版本123456789101112131415161718192021222324252627282930／*** @ fn 回调函数 * @ wait 间隔时间 *／function throttle(fn, wait)&#123; let pre = 0， timer = null; return function()&#123; let context = this, arg = arguments, now = +new Data(), remaining = wait - (now - pre); if((remaining &lt; 0 || remaining &gt;= wait))&#123; if(!timer)&#123; fn.apply(this, arguments); pre = now; &#125; timer = setTimeout(function()&#123; pre = now; fn.apply(context, arg); &#125;, wait); &#125;else&#123; clearTimeout(timer); timer = setTimeout(function()&#123; pre = now; fn.apply(context, arg); &#125;, remaining); &#125; &#125;&#125; underscore实现版本12345678910111213141516171819202122232425262728293031323334353637／*** @ func 回调函数 * @ wait 间隔时间 * @ options options.leading = true 表示首次立即执行 options.leading = false 表示首次不立即执行 ；* @ options.trailing = true 表示最后一次执行 options.trailing = false 表示最后一次不执行 *／_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;;&#125;; underscore 的版本有一个很好的地方就是当事件频繁触发时不用一直设置定时器和清除定时器。但是这个版本有两个问题，第一个就是当设置options.leading = false 和 options.trailing = false 首次调用时 remaining = wait if 和 else if 分支都不会进去，这是一个bug；第二个问题就是当设置options.leading = true 和 options.trailing = true 首次调用时 previous = 0 now 等于一个很大的正数，remaining = wait - (now - 0) &lt; 0 数一个很大的负数，timeout = null; !timeout = true 进入 else if 分支的时候，执行timeout = setTimeout(later, remaining);的时候，给定时器设延迟执行，这应该","categories":[{"name":"debounce debounce","slug":"debounce-debounce","permalink":"http://www.goyth.com/categories/debounce-debounce/"}],"tags":[{"name":"debounce","slug":"debounce","permalink":"http://www.goyth.com/tags/debounce/"},{"name":"throttle","slug":"throttle","permalink":"http://www.goyth.com/tags/throttle/"}]},{"title":"基于 Docker 构建前端持续集成开发环境","slug":"dockerDeploy","date":"2018-05-08T09:24:13.000Z","updated":"2018-05-08T09:35:54.892Z","comments":true,"path":"2018/05/08/dockerDeploy/","link":"","permalink":"http://www.goyth.com/2018/05/08/dockerDeploy/","excerpt":"本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。 前置知识： CI（持续集成）：阮一峰老师的关于 CI 的介绍 Docker： Docker 快速入门 目标： 代码无需在本地构建 只需将代码推上 Github ，自动构建 -&gt; 部署 版本易管理，可轻松回退版本","text":"本文将以一个标准的 Vue 项目为例，完全抛弃传统的前端项目开发部署方式，基于 Docker 容器技术打造一个精简的前端持续集成的开发环境。 前置知识： CI（持续集成）：阮一峰老师的关于 CI 的介绍 Docker： Docker 快速入门 目标： 代码无需在本地构建 只需将代码推上 Github ，自动构建 -&gt; 部署 版本易管理，可轻松回退版本 现在开始进入主题第一步： 初始化 Vue 项目（使用vue官方脚手架 vue-cli) 初始化 vue 项目：vue init webpack vue-docker-demo 在项目根目录下编 Dockerfile Dockerfile 内容如下（如果是构建其他项目，比如 angular4，只需安装 angular-cli，将构建参数改成 ng build 即可，大同小异） 1234567891011121314151617181920212223242526272829# 使用 node 6.10.3 的精简版作为基础镜像FROM node:6.10.3-slim# 安装nginxRUN apt-get update \\ &amp;&amp; apt-get install -y nginx# 指定工作目录WORKDIR /app# 将当前目录下的所有文件拷贝到工作目录下COPY . /app/# 声明运行时容器提供服务端口EXPOSE 80# 1. 安装依赖# 2. 运行 npm run buil# 3. 将 dist 目录的所有文件拷贝到 nginx 的目录下# 4. 删除工作目录的文件，尤其是 node_modules 以减小镜像体积# 由于镜像构建的每一步都会产生新层# 为了减小镜像体积，尽可能将一些同类操作，集成到一个步骤中，如下RUN npm install \\ &amp;&amp; npm run build \\ &amp;&amp; cp -r dist/* /var/www/html \\ &amp;&amp; rm -rf /app# 以前台方式启动 nginx CMD [ &quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] 初始化 git， 连接并将代码推送到 Github 仓库 第二步：使用 DaoCloud 搭建 Devops 流程（也可以使用其他公有云服务，差别不大，本文将以简单易操作并且对个人开发者免费的 DaoCloud 为例）1. 注册一个 DaoCloud 账号2. 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 注册一个 DaoCloud 账号 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目，点击“开始创建” 先手动构建一个镜像版本，便于下面用这个镜像版本创建一个应用 连接自有主机（没有自有主机的，也可以使用云端测试环境） tips：可以去购买 vultr 等主机，按照指示流程完成主机接入，大概很简单的三四步操作，注意在完成主机连接后，需要手动在主机上启动 docker（service docker start） 太酷了，我们已经将我们的主机接入了 DaoCloud，接下来就来完成最有意思的一步。 创建一个应用 进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境 稍等片刻，便可以点击“立即部署” 等待完成镜像拉取，待容器列表中的容器起来后，通过地址查看我们部署的 vue 应用 我们已经可以访问到我们刚才部署的 vue 应用了，也表示我们已经将我们的镜像部署到我们的自有主机上去了，此时进入主机查看容器运行情况，可以看到有一个正在运行中的容器，正是我们刚刚部署的，一切都是完美的。 完成到这里，我们可以说已经完成了 99% 的工作，但是还非常重要的最后 1%，那就是真正的自定义持续集成流程，让一切都自动化起来，现在让我们回到刚才 Devops 项目的【流程定义】中去 定义自动构建，自动发布任务回到 Devops 项目里对自动化流程进行定义 首先我们来定义一下自动构建任务，我们设定规则是只有在有新 tag 时才执行构建任务，构建时查找根目录下的 Dockerfile，并以此构建镜像 其次，我们再来定义自动发布任务，当构建任务完成时自动触发自动发布任务，并发布到自有主机的应用上去 至此，我们已经完成了，所有流程控制工作，去测试一下整个流程是否能走通？ 第三步： 测试整个流程回到我们本地，修改一下文本内容，提交，并推送到远端，并且打下我们的第一个版本tag 1.1.1，并将 tag 推送到远端 可以看到，与此同时，我们打 tag 的操作触发了我们定义的 CI 流程 稍等片刻，可以看到我们的应用更新了，对应的版本就是我们刚刚推上去的 1.1.1 我们还可以对应用的版本进行切换，回退等操作 至此，我们在只编写了一个 Dockerfile 配置文件，没有编写脚本的情况下，成功地搭建了一套前端的持续集成开发环境，之后我们只需要专心编写我们的业务代码就好了，打一个 Tag 便可以轻松地完成自动部署上线。 参考链接：https://juejin.im/post/5a142d7b6fb9a0451170c2c7","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.goyth.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.goyth.com/tags/Docker/"}]},{"title":"JavaScript 原型链与继承","slug":"prototypeAndExtend","date":"2018-04-23T04:23:43.000Z","updated":"2018-04-25T02:35:12.000Z","comments":true,"path":"2018/04/23/prototypeAndExtend/","link":"","permalink":"http://www.goyth.com/2018/04/23/prototypeAndExtend/","excerpt":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。","text":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。 12function Person()&#123;&#125; 当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象 1234let person = new Person();person.__proto__ === Person.prototype // truelet person1 = new Person();person1.__proto__ === Person.prototype // true 由于同一个构造函数创建的所有实例对象的__proto__ 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。 1234567891011function Person()&#123;&#125;Person.prototype.name = &quot;Luke&quot;;Person.prototype.age = 18;let person1 = new Person();let person2 = new Person();alert(person1.name) // &quot;Luke&quot;alert(person2.name) // &quot;Luke&quot;Person.prototype.name = &quot;Jack&quot;;alert(person1.name) // &quot;Jack&quot;alert(person2.name) // &quot;Jack&quot; 重写原型对象我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示 12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 在上面的代码中，我们将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。 123let friend = new Person();alert(friend.constructor === Person); //false alert(friend.constructor === Object); //true 如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 原型链及原型链继承每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 1234567891011121314151617181920212223function Super()&#123; this.property = true;&#125;Super.prototype.getSuperValue = function()&#123; return this.property;&#125;function Sub()&#123; this.subproperty = false;&#125;Sub.prototype = new Super(); //继承了 Super Sub.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;let instance = new Sub();console.log(instance.getSuperValue()); //trueconsole.log(instance.__proto__ === Sub.prototype); //trueconsole.log(Sub.prototype.__proto__ === Super.prototype); //true 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。 原型链搜索机制当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。 原型链问题原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 123456789101112131415function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123;&#125;Sub.prototype = new Super(); // 继承了Superlet instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green, black&quot; 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。 构造函数继承（经典继承）即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。 1234567891011121314function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123; Super.call(this); //继承了Super &#125;let instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green&quot; 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。 构造函数继承问题如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。 组合继承是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 123456789101112131415161718192021222324252627282930function Super(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Super.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 (第二次调用Sup构造函数) this.age = age;&#125;Sub.prototype = new Super(); // 继承了Super 原型链上的方法 (第一次调用Sup构造函数)Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。但是美中不足的是，上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。 优化后的组合继承12345678910111213141516171819202122232425262728293031323334function Super(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Super.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 this.age = age;&#125;function F()&#123;&#125;F.prototype = Super.prototype; Sub.prototype = new F(); // 继承了Super 原型链上的方法Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。这是最理想的继承方式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"extend","slug":"JavaScript/extend","permalink":"http://www.goyth.com/categories/JavaScript/extend/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"http://www.goyth.com/tags/prototype/"},{"name":"extend","slug":"extend","permalink":"http://www.goyth.com/tags/extend/"}]},{"title":"JS 的正则表达式","slug":"JSRegExp","date":"2018-04-01T08:22:03.000Z","updated":"2018-04-02T15:32:21.000Z","comments":true,"path":"2018/04/01/JSRegExp/","link":"","permalink":"http://www.goyth.com/2018/04/01/JSRegExp/","excerpt":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符","text":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 先简单的介绍一下语法基本元字符 .： 匹配除了换行符之外的任何单个字符 \\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\\的&#39;b&#39;通常匹配小写&#39;b&#39;，无论它们出现在哪里。如果加了&#39;\\&#39;,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\\*/ 将 ‘ * ‘ 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。 | ： 逻辑或操作符 [ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 . ，\\这些字符都表示其本身 [^ ] ：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*, +, ?, {} 后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \\$ ： 匹配表达式的结束 \\b ：匹配单词边界 \\B ：匹配非单词边界 (?=p) ：匹配 p 前面的位置 (?!p) ：匹配不是 p 前面的位置 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 matchmatch 接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 123456789101112131415161718var str = &apos;For more information, see Chapter 3.4.5.1&apos;; var re = /see (chapter \\d+(\\.\\d)*)/i; var found = str.match(re); console.log(found); // (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;] // 0:&quot;see Chapter 3.4.5.1&quot; // 1:&quot;Chapter 3.4.5.1&quot; // 2:&quot;.1&quot; // index:22 // input:&quot;For more information, see Chapter 3.4.5.1&quot; // length:3 // __proto__:Array(0) // &apos;see Chapter 3.4.5.1&apos; 是整个匹配。 // &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \\d+(\\.\\d)*)&apos;捕获。 // &apos;.1&apos; 是被&apos;(\\.\\d)&apos;捕获的最后一个值。 // &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。 // &apos;input&apos; 属性是被解析的原始字符串。 123456var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replacereplace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer);// newString abc - 12345 - #$*% split接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的&quot;hello&quot;这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪默认贪婪 123var regex = /\\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\\d\\D\\s\\S\\w\\W)都可以等价成这种。比如123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 最多保留2位小数的数字/^([1-9]\\d*|0)(\\.\\d{1,2})?$/ 电话号码/(\\+86)?1\\d{10}/ 身份证/^(\\d{15}|\\d{17}([xX]|\\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o* ， *代表位置 上面说到了 6 种位置元字符 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \\w([a-zA-Z0-9_]) 和 \\W 之间的位置，包括 \\w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\\b/g, &#39;#&#39;) 结果是#hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 &#39;&#39;，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\\Be\\Bl\\Bl\\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\\B\\B\\Be\\Bl\\Bl\\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子-. 千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 &#39;,&#39; 就好了，写成正则就是123123213.replace(/(?=(\\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 &#39;,&#39; 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\\d(?=(\\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 &#39;,&#39; 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组分组主要是括号的使用 分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\\d{4}-\\d{2}-\\d{2}/，这个正则还可以改成分组形式的/(\\d{4})-(\\d{2})-(\\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以1234var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种123452017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\\d{4})[-/.](\\d{2})[-/.](\\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\\d{4})([-/.])(\\d{2})\\2(\\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\\1就匹配\\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 &#39;abbbc&#39; 和这么一个正则 /ab{1,3}bbc/ /ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;)前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则读懂其他人写的正则也是一个很重要的方面。 结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。 操作符： 转义符 \\ 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \\元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f,g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是 以这种模式来分析，再复杂的正则都可以看懂。有一个可视化的正则分析网站 转载自网易考拉前端团队","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"RegExp","slug":"JavaScript/RegExp","permalink":"http://www.goyth.com/categories/JavaScript/RegExp/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"http://www.goyth.com/tags/RegExp/"}]},{"title":"排序算法之冒泡排序","slug":"bubbleSort","date":"2018-03-08T02:40:24.000Z","updated":"2018-05-28T03:29:21.320Z","comments":true,"path":"2018/03/08/bubbleSort/","link":"","permalink":"http://www.goyth.com/2018/03/08/bubbleSort/","excerpt":"","text":"常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。这里主要介绍冒泡排序 排序算法总览： 冒泡排序冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序”。 算法原理编辑冒泡排序算法的运作如下：（从前往后）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法描述JavaScript12345678910111213141516function bubbleSort(arr)&#123; for(let i = arr.length-1; i&gt;0; i--)&#123; for(let j=0; j&lt;i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]] // 利用es6解构语法进行\bswap &#125; &#125; &#125; return arr;&#125;// 测试var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];var arrSorted = bubbleSort(arr);console.log(arrSorted);// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9] 冒泡算法优化12345678910111213141516171819function bubbleSort(arr)&#123; let flag = true; for(let i=arr.length-1; flag &amp;&amp; i&gt;0; i--)&#123; flag = false; //只要flag在下一次外循环条件检测的时候值为false，就说明已经排好序，不用继续循环 for(let j=0; j&lt;i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; flag = true; //如果有交换，就将标记变量赋true [arr[j], arr[j+1]] = [arr[j+1], arr[j]] // 利用es6解构语法进行\bswap &#125; &#125; &#125; return arr;&#125;// 测试var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];var arrSorted = bubbleSort(arr);console.log(arrSorted);// 控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.goyth.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.goyth.com/tags/Algorithm/"}]}]}