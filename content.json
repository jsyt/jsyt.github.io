{"meta":{"title":"GOYTH","subtitle":"记录学习的技能和遇到的问题","description":"get busy living or get busy dying","author":"Luke Hu","url":"http://www.goyth.com"},"pages":[{"title":"about","date":"2018-03-30T13:05:14.000Z","updated":"2018-03-30T13:05:14.807Z","comments":true,"path":"about/index.html","permalink":"http://www.goyth.com/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-03-30T12:55:05.000Z","updated":"2018-03-30T13:07:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.goyth.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-03-30T12:44:24.000Z","updated":"2018-03-30T14:13:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.goyth.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 原型链与继承","slug":"prototypeAndExtend","date":"2018-04-23T04:23:43.000Z","updated":"2018-04-24T04:08:42.000Z","comments":true,"path":"2018/04/23/prototypeAndExtend/","link":"","permalink":"http://www.goyth.com/2018/04/23/prototypeAndExtend/","excerpt":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。","text":"原型对象无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数。 12function Person()&#123;&#125; 当我们用构造函数创建一个实例时，也会为这个实例创建一个 __proto__ 属性，这个__proto__ 属性是一个指针指向构造函数的原型对象 1234let person = new Person();person.__proto__ === Person.prototype // truelet person1 = new Person();person1.__proto__ === Person.prototype // true 由于同一个构造函数创建的所有实例对象的__proto__ 属性都指向这个构造函数的原型对象，因此所有的实例对象都会共享构造函数的原型对象上所有的属性和方法，一旦原型对象上的属性或方法发生改变，所有的实例对象都会受到影响。 1234567891011function Person()&#123;&#125;Person.prototype.name = &quot;Luke&quot;;Person.prototype.age = 18;let person1 = new Person();let person2 = new Person();alert(person1.name) // &quot;Luke&quot;alert(person2.name) // &quot;Luke&quot;Person.prototype.name = &quot;Jack&quot;;alert(person1.name) // &quot;Jack&quot;alert(person2.name) // &quot;Jack&quot; 重写原型对象我们经常用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示 12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 在上面的代码中，我们将 Person.prototype 设置为一个新对象，而这个对象中没有constructor属性，这导致 constructor 属性不再指向 Person，而是指向 Object。 123let friend = new Person();alert(friend.constructor === Person); //false alert(friend.constructor === Object); //true 如果 constructor 的值很重要，我们可以像下面这样特意将它设置回设置回适当的值 1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, name : &quot;Luke&quot;, age : 18, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name) &#125;&#125; 原型链及原型链继承每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor)，而实例都包含一个指向原型对象的内部指针(__proto__)。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个构造函数的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。 1234567891011121314151617181920212223function Super()&#123; this.property = true;&#125;Super.prototype.getSuperValue = function()&#123; return this.property;&#125;function Sub()&#123; this.subproperty = false;&#125;Sub.prototype = new Super(); //继承了 Super Sub.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;let instance = new Sub();console.log(instance.getSuperValue()); //trueconsole.log(instance.__proto__ === Sub.prototype); //trueconsole.log(Sub.prototype.__proto__ === Super.prototype); //true 上面的代码中Sub.prototype = new Super();通过创建Super的实例，并将该实例赋值给Sub.prototype来实现继承。此时存在于Super的实例和原型对象中的所有属性和方法，也都存在于Sub.prototype中。instanse的__proto__属性指向Sub的原型对象Sub.prototype，Sub原型对象的__proto__属性又指向Super的原型对象Super.prototype。 原型链搜索机制当访问一个实例的属性时，首先会在该实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链继承的情况下，搜索过程就得以沿着原型链继续向上查找，直到找到该属性为止，或者搜索到最高级的原型链Object.prototype中，任然没有找到则返回undefined。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索Sub.prototype;3）搜索Super.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链的末端才会停下。 原型链问题原型链继承最大的问题是来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。而这正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 123456789101112131415function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123;&#125;Sub.prototype = new Super(); // 继承了Superlet instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green, black&quot; 上面的代码中，Super 构造函数定义了一个colors 属性，该属性是一个数组。Super 的每个实例都会有各自包含自己数组的colors 属性。当Sub 通过原型链继承了Super之后，Sub.prototype 就变成了Super 的一个实例，因此它也拥有了一个它自己的colors 属性。结果是所有的Sub 实例都会共享这一个colors 属性。原型链的第二个问题是没有办法在不影响所有对象实例的情况下，给超类的构造函数传递参数。 构造函数继承（经典继承）即在子类构造函数的中调用父类构造函数，此时当构建一个子类实例时，此实例也会拥有父类实例的属性和方法。 1234567891011121314function Super()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function Sub()&#123; Super.call(this); //继承了Super &#125;let instance1 = new Sub();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;let instance2 = new Sub();alert(instance2.colors); //&quot;red, blue, green&quot; 上面的代码，当构建Sub的实例时，也会调用Super 的构造函数，这样就会在新Sub对象上执行Super()函数中定义的所有对象初始化代码。结果，Sub 的每个实例就都会具有自己的colors 属性的副本了。 构造函数继承问题如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数服用就无从谈起。而且，在超类原型中定义的方法，对子类而已也是不可见的。 组合继承是指将原型链和构造函数的相结合，发挥二者之长的一种继承模式。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 123456789101112131415161718192021222324252627282930function Sup(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Sup.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 (第二次调用Sup构造函数) this.age = age;&#125;Sub.prototype = new Super(); // 继承了Super 原型链上的方法 (第一次调用Sup构造函数)Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 在上面的例子中，Sup构造函数定义了两个属性：name和colors。Sup的原型定义了一个方法sayName()。Sub构造函数在调用Sup构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将Sup的实例赋值给Sub的原型，然后又在该新原型上定义了sayAge()方法。这样就可以让两个不同的Sub 实例即分别拥有自己的属性————包括colors 属性，又可以使用相同的方法了。组合继承避免了原型链和构造函数的缺陷，融合了它们的优点，是JavaScript中最常用的继承模式。但是美中不足的是，上面的代码中调用了两次父类构造函数。Sub.prototype = new Super(); 第一次调用父类构造函数时，将Sup父类构造函数的实例赋值给了Sub子类的原型对象Sub.prototype。此时也会将父类构造函数实例上的属性赋值给子类的原型对象Sub.prototype。而第二次是在子类的构造函数中调用父类的构造函数 Super.call(this)，此时会将父类构造函数实例上的属性赋值给子类的构造函数的实例。根据原型链搜索原则，实例上的属性会屏蔽原型链上的属性。因此我们没有必要将父类构造函数实例的属性赋值给子类的原型对象，这是浪费资源而又没有意义的行为。 优化后的组合继承12345678910111213141516171819202122232425262728293031323334function Sup(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;Sup.prototype.sayName = function ()&#123; alert(this.name);&#125;;function Sub(name, age)&#123; Super.call(this); //继承了Super 属性 this.age = age;&#125;function F()&#123;&#125;F.prototype = Super.prototype; Sub.prototype = new F(); // 继承了Super 原型链上的方法Sub.prototype.constructor = Sub;Sub.prototype.sayAge = function ()&#123; alert(this.age);&#125;;var instance1 = new Sub(&quot;Luke&quot;, 18);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red, blue, green, black&quot;instance1.sayName(); //&quot;Luke&quot;instance1.sayAge() //18var instance2 = new Sub(&quot;Jack&quot;, 20);alert(instance2.colors); //&quot;red, blue, green&quot;instance2.sayName(); //&quot;Jack&quot;instance2.sayAge() //20 上面的例子通过将父类的原型对象直接赋值给一个中间构造函数的原型对象，然后将这个中间构造函数的实例赋值给子类的原型对象Sub.prototype，从而完成原型链继承。它的高效性体现在只调用了一个父类构造函数Super，并且原型链保持不变。这是最理想的继承方式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"extend","slug":"JavaScript/extend","permalink":"http://www.goyth.com/categories/JavaScript/extend/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"http://www.goyth.com/tags/prototype/"},{"name":"extend","slug":"extend","permalink":"http://www.goyth.com/tags/extend/"}]},{"title":"JS 的正则表达式","slug":"JSRegExp","date":"2018-04-01T08:22:03.000Z","updated":"2018-04-02T15:32:21.000Z","comments":true,"path":"2018/04/01/JSRegExp/","link":"","permalink":"http://www.goyth.com/2018/04/01/JSRegExp/","excerpt":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符","text":"正则表达式一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 先简单的介绍一下语法基本元字符 .： 匹配除了换行符之外的任何单个字符 \\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\\的&#39;b&#39;通常匹配小写&#39;b&#39;，无论它们出现在哪里。如果加了&#39;\\&#39;,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 a。相反，模式 /a\\*/ 将 ‘ * ‘ 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。 | ： 逻辑或操作符 [ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 . ，\\这些字符都表示其本身 [^ ] ：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*, +, ?, {} 后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \\$ ： 匹配表达式的结束 \\b ：匹配单词边界 \\B ：匹配非单词边界 (?=p) ：匹配 p 前面的位置 (?!p) ：匹配不是 p 前面的位置 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 matchmatch 接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 123456789101112131415161718var str = &apos;For more information, see Chapter 3.4.5.1&apos;; var re = /see (chapter \\d+(\\.\\d)*)/i; var found = str.match(re); console.log(found); // (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;] // 0:&quot;see Chapter 3.4.5.1&quot; // 1:&quot;Chapter 3.4.5.1&quot; // 2:&quot;.1&quot; // index:22 // input:&quot;For more information, see Chapter 3.4.5.1&quot; // length:3 // __proto__:Array(0) // &apos;see Chapter 3.4.5.1&apos; 是整个匹配。 // &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \\d+(\\.\\d)*)&apos;捕获。 // &apos;.1&apos; 是被&apos;(\\.\\d)&apos;捕获的最后一个值。 // &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。 // &apos;input&apos; 属性是被解析的原始字符串。 123456var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replacereplace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer);// newString abc - 12345 - #$*% split接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的&quot;hello&quot;这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪默认贪婪 123var regex = /\\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\\d\\D\\s\\S\\w\\W)都可以等价成这种。比如123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 最多保留2位小数的数字/^([1-9]\\d*|0)(\\.\\d{1,2})?$/ 电话号码/(\\+86)?1\\d{10}/ 身份证/^(\\d{15}|\\d{17}([xX]|\\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o* ， *代表位置 上面说到了 6 种位置元字符 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \\w([a-zA-Z0-9_]) 和 \\W 之间的位置，包括 \\w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\\b/g, &#39;#&#39;) 结果是#hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 &#39;&#39;，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\\Be\\Bl\\Bl\\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\\B\\B\\Be\\Bl\\Bl\\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子-. 千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 &#39;,&#39; 就好了，写成正则就是123123213.replace(/(?=(\\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 &#39;,&#39; 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\\d(?=(\\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 &#39;,&#39; 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组分组主要是括号的使用 分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\\d{4}-\\d{2}-\\d{2}/，这个正则还可以改成分组形式的/(\\d{4})-(\\d{2})-(\\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以1234var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种123452017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\\d{4})[-/.](\\d{2})[-/.](\\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\\d{4})([-/.])(\\d{2})\\2(\\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\\1就匹配\\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 &#39;abbbc&#39; 和这么一个正则 /ab{1,3}bbc/ /ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;)前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则读懂其他人写的正则也是一个很重要的方面。 结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。 操作符： 转义符 \\ 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \\元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f,g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是 以这种模式来分析，再复杂的正则都可以看懂。有一个可视化的正则分析网站 转载自网易考拉前端团队","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/categories/JavaScript/"},{"name":"RegExp","slug":"JavaScript/RegExp","permalink":"http://www.goyth.com/categories/JavaScript/RegExp/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.goyth.com/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"http://www.goyth.com/tags/RegExp/"}]},{"title":"hello","slug":"hello","date":"2018-03-29T14:26:35.000Z","updated":"2018-04-01T09:21:45.000Z","comments":true,"path":"2018/03/29/hello/","link":"","permalink":"http://www.goyth.com/2018/03/29/hello/","excerpt":"hello Hexo Makedown 语法测试一","text":"hello Hexo Makedown 语法测试一 链接个人博客地址I get 10 times more traffic from Google than fromYahoo or MSN. 图片 指定大小图片 引用Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Code普通代码块1alert(&apos;Hello World!&apos;); 指定语言代码块1alert('Hello World!'); 反引号代码块1hello hexo","categories":[{"name":"Diary","slug":"Diary","permalink":"http://www.goyth.com/categories/Diary/"},{"name":"Life","slug":"Diary/Life","permalink":"http://www.goyth.com/categories/Diary/Life/"}],"tags":[{"name":"TEST","slug":"TEST","permalink":"http://www.goyth.com/tags/TEST/"},{"name":"HYT","slug":"HYT","permalink":"http://www.goyth.com/tags/HYT/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-03T08:46:06.221Z","updated":"2018-03-30T13:57:01.000Z","comments":true,"path":"2018/03/03/hello-world/","link":"","permalink":"http://www.goyth.com/2018/03/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick TestsCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://www.goyth.com/categories/test/"}],"tags":[{"name":"TEST","slug":"TEST","permalink":"http://www.goyth.com/tags/TEST/"}]}]}